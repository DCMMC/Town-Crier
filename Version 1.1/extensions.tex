%\section{Extensions}

%\elaine{TODO: there are some uncolored fee notations that need to be changed}

\elaine{TODO: ethan changed leq to equality. change proof as well}

\subsection{Handling Transaction Fees}

To mitigate potential Denial-of-Service (DoS) attacks, 
Ethereum employs a fee mechanism, referred to as ``gas'', 
where the submitter of a transaction (that invokes
an entry point in the contract) pays a  
transaction fee
roughly proportional to the execution time of the 
corresponding entry point.

\paragraph{Notations and assumed execution model.}
In Figure \elaine{fill}, we
use the notation $\gas$
to denote transaction fees (i.e., gas), 
where $\$$ is a type annotation 
and ${\tt g}$ denotes the numerical amount of the  
gas. Other non-gas, normal currency units 
are denoted as $\fee$ where $\$$ is a type annotation,
and ${\tt f}$ denotes the amount of the currency. 
For simplicity, our notational system assumes 
that gas and normal currency adopt
the same currency unit. 

We assume that the blockchain contract adopts the following execution model
for gas which closely resembles Ethereum's execution model:
\begin{itemize}[leftmargin=5mm]
\item
{\it Providing gas.} 
When a transaction is submitted, it invokes an entry point in the contract.
The transaction submitter provides a gas amount to activate the entry point. 
\item
{\it Extra gas.} 
If extra gas remains at the end of the execution (after invoking an entry point),
{\it all extra gas is refunded to the caller at the end}.
\item
{\it Gas exhaustion.} 
Gas exhaustion is dealt with in the following manner.
Consider each entry point of the contract as a function. 
Functions can call other functions.
Each function can specify a gas upper bound not to exceed
the remaining gas of the parent function (and if left unspecified,
the upper bound is implicitly set to all remaining gas of the parent function).
If execution of the function exhausted the per-function gas 
upper bound, the function execution is aborted and 
state reverted to before the function is invoked.
\end{itemize}

\begin{figure}
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf Town Crier blockchain contract \tcont with fees}} \\ [1ex]
  {\bf Request:} & On recv $(\dgform, 
\dgcallback,  
%{\color{blue} \Time_{\text{timeout}}},
\gasrequest$ $+$ 
$\fee)$ from some $\reqcont$: \\
%		& Assert ${\color{blue} \Time_{\text{timeout}}} > {\sf cur\_time}$\\
		& $\dgid$ := Counter; \ \  Counter := Counter + 1\\
                 & Record $(\dgid, \dgform, \dgcallback, \fee, \reqcont)$
%\elaine{this makes it look like it's sending money}
\\[-10pt]
%    & {\it {\color{gray} {//~at most ${{\Delta F_{\textrm{request}}}}$ {gas consumed}}} }\\[-10pt]
%    & {\it {\color{gray} {//~all remaining {gas returned to $\reqcont$}}} }\\[-10pt]
    & {\it {\color{gray} {//~$\fee$} held by contract}} \\
  {\bf Deliver:} & On recv $(\dgid, \dgform, \dgm, 
\gasdeliver )$ from $\tcadd$: \\
	& If ${\sf bCanceled}[\dgid]$ and not ${\sf bDelivered}[\dgid]$:\\
		& \quad Send $\feecancel$ to $\tcadd$  \\
		& \quad Set ${\sf bDelivered}[\dgid]$ and return\\

                 & Let $(\dgid, \dgform', \dgcallback, \fee, \_)$ be the first recorded tuple for $\dgid$ \sgray{\it //~abort if not found}\\
% & Assert ${\color{blue} \Time_{\text{timeout}}} > {\sf cur\_time}$ \\
                 & Assert $\dgform = \dgform'$\\
                &   Assert $\fee = \gasdeliver$\\
		& Set ${\sf bDelivered}[\dgid]$ \ \ \  \sgray{//~(*)}\\
                 & Send $\smaroon{\$F}$ to $\tcadd$ \ \ \ \sgray{//~(**)} \\
                 & Call $\dgcallback(\dgm)$ \\[2pt] %[-10pt]
%    & {\it {\color{gray} {//~at most ${{\Delta F_{\textrm{deliver}}}}$ {gas consumed}}} }\\[-10pt]
%    & {\it {\color{gray} {//~all remaining {gas returned to $\tcadd$}}} }\\

{\bf Cancel:} & On recv $(\dgid, \gascancel + \feecancel)$ 
from some $\reqcont$\\
  & Let $(\dgid, \_, \_, \smaroon{\$ F}, \reqcont')$ be the first recorded tuple for $\dgid$ \ \  \sgray{\it //~abort if not found}\\
   & Assert $\reqcont = \reqcont'$\\
%& Assert $\dgid$ has been seen \\
   & Assert ${\sf bDelivered}[\dgid]$ not set \\
   & Assert ${\sf bCanceled[\dgid]}$ not set \\ 
%   & Assert ${\sf cur\_time} \geq {\color{blue} \Time_{\text{timeout}}}$\\
& Assert $\feecancel \geq \constgascancel $ \\
  & Set ${\sf bCanceled[\dgid]}$\\
  & Send $\fee$ to \reqcont\\[-10pt]
    & {\it {\color{gray} {//~$\feecancel$} held by contract}} \\
  \hline
\end{tabularx}
\caption{
Town Crier contract \tcont reflecting fees.
An honest requester would set $\smaroon{\$ F}$ to be the gas amount 
required to execute the {\bf Deliver} entry point including $\dgcallback$. 
Town Crier sets $\gasdeliver := \fee$,
and this amount will be refunded if the datagram delivery 
succeeds.
\ethan{As per a previous discussion, this is subtly different from the implementation.
  I think this is fine for the protocol and formal reasoning, but we do need to explain the difference somewhere any why it doesn't matter.}
If the datagram delivery happens after 
cancellation, then unspent portions of $\gasdeliver$ 
gets refunded by Ethereum's underlying gas operational semantics,
whereas a small amount of gas spent $\constgascancel$ gets  
refunded through an amount deposited
by the requester
necessary for invoking the {\bf Cancel} entry point.
%$\sbrown{\$ G_{\text{request}}}$ denotes the gas for executing the {\bf Request} 
%entry point. 
%$\sbrown{\$ G_{\text{deliver}}}$ denotes the gas for executing the {\bf Deliver} entry point.
%%that includes the user-defined ${\sf callback}$.
%\smaroon{\$F_{\text{deliver}}} denotes 
%${\tt F_{\text{deliver}}}$ amount of 
%explicit, non-gas currency units.
%Essentially, the requester first pays 
%$\smaroon{\$ F_{\text{deliver}}}$ currency units which will be used to refund
%the $\sbrown{\$ G_{\text{deliver}}}$ amount of gas
%that $\pksgx$ will need to advance to call the {\bf Deliver} entry point.
%$\smaroon{\overline{F}_{\text{deliver}}}$ denotes the amount of gas
%refunded to Town Crier 
%in case Town Crier sends in a datagram  
%after the request has been cancelled (e.g., due to a race condition).
}
\label{tbl:tc-contract}
\end{figure}






%\begin{figure}
%\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
%  \hline
%
%  \multicolumn{2}{|c|}{{\bf Town Crier blockchain contract \tcont with fees}} \\ [1ex]
%  {\bf Request:} & On recv $({\sf params}, 
%{\sf callback},  
%{\color{blue} \Time_{\text{timeout}}},
%\sbrown{\Delta F_{\text{request}}}$ $+$ 
%$\smaroon{\$F_{\text{deliver}}})$ from some $\reqcont$: \\
%		& Assert ${\color{blue} \Time_{\text{timeout}}} > {\sf cur\_time}$\\
%		& ${\sf id}$ := Counter; \ \  Counter := Counter + 1\\
%                 & Record $({\sf id}, {\sf params}, {\sf callback}, \smaroon{\$ F_{\text{deliver}}}, {\color{blue} \Time_{\text{timeout}}}, {\reqcont})$
%%\elaine{this makes it look like it's sending money}
%\\[-10pt]
%    & {\it {\color{gray} {//~at most ${{\Delta F_{\textrm{request}}}}$ {gas consumed}}} }\\[-10pt]
%    & {\it {\color{gray} {//~all remaining {gas returned to $\reqcont$}}} }\\[-10pt]
%    & {\it {\color{gray} {//~$\smaroon{\$ F_{\text{deliver}}}$} held by contract}} \\
%  {\bf Deliver:} & On recv $({\sf id}, {\sf params}, {\sf data}, 
%$\sbrown{\Delta {\tt F_{\text{deliver}}}}$ )$ from $\tcadd$: \\
%                 & Let $({\sf id}, {\sf params'}, {\sf callback}, \smaroon{\$ F'_{\text{deliver}}}, {\color{blue} \Time_{\text{timeout}}}, \_)$ be the first recorded tuple for ${\sf id}$\\
% & Assert ${\color{blue} \Time_{\text{timeout}}} > {\sf cur\_time}$ \\
%                 & Assert ${\sf params} = {\sf params}'$\\
%                &   Assert $\smaroon{\$ F'_{\text{deliver}}} \leq \sbrown{\Delta F_{\text{deliver}}}$\\
%		& Set ${\sf bDelivered}[{\sf id}]$ \\
%                 & Send $\smaroon{\$F'_{\text{deliver}}}$ to $\tcadd$ \\
%                 & Call ${\sf callback}({\sf data})$ \\[-10pt]
%    & {\it {\color{gray} {//~at most ${{\Delta F_{\textrm{deliver}}}}$ {gas consumed}}} }\\[-10pt]
%    & {\it {\color{gray} {//~all remaining {gas returned to $\tcadd$}}} }\\
%
%{\bf Cancel:} & On recv $({\sf id}, \sbrown{\Delta F_{\text{cancel}}})$ 
%from some $\reqcont$\\
%  & Let $({\sf id}, \_, \_, \smaroon{\$ F_{\text{deliver}}}, {\color{blue} \Time_{\text{timeout}}}, \reqcont')$ be the first recorded tuple for ${\sf id}$ \\
%   & Assert $\reqcont = \reqcont'$\\
%   & Assert ${\sf bDelivered}[{\sf id}]$ not set \\ 
%   & Assert ${\sf cur\_time} \geq {\color{blue} \Time_{\text{timeout}}}$\\
%  & Send $\smaroon{\$ F_{\text{deliver}}}$ to \reqcont\\
%  \hline
%\end{tabularx}
%\caption{
%Town Crier contract \tcont reflecting fees.
%$\sbrown{\Delta F_{\text{request}}}$ denotes the gas for executing the {\bf Request} 
%entry point. 
%$\sbrown{\Delta F_{\text{deliver}}}$ denotes the gas for executing the {\bf Deliver} entry point
%that includes the user-defined ${\sf callback}$.
%\smaroon{\$F_{\text{deliver}}} denotes 
%${\tt F_{\text{deliver}}}$ amount of 
%explicit, non-gas currency units.
%Essentially, the requester first pays 
%$\smaroon{\$ F_{\text{deliver}}}$ currency units which will be used to refund
%the $\sbrown{\Delta F_{\text{deliver}}}$ amount of gas
%that $\pksgx$ will need to put in to call the {\bf Deliver} entry point.
%}
%\label{tbl:tc-contract}
%\end{figure}

\begin{figure}[!h]
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Program for Town Crier \medname $\relay$}
\end{center}
\begin{tabular}{l}
{\bf Initialize}: Same as Figure~\ref{fig:relayprotocol} \\[5pt]
%Send \initcall to $\fsgx[\enclaveprog, \relay]$\\
%On recv $(\pkTC, \sigatt)$ from $\fsgx[\enclaveprog, \relay]$:\\
%\quad Publish $(\pkTC, \sigatt)$\\[5pt]

{\bf Handle}$(T, \dgid, \dgform, \fee)$: \\
Wait until $\clock() \geq T$\\
Assert $\constgasmin \leq  \fee \leq \constgasmax $ \\
Send $(\text{\resumecall}, (\dgid, \dgform, {\tt F} )$ to $\fsgx[\enclaveprog, \relay]$) \\
On recv $((\dgid, \dgform, \dgm), \sigma)$ from $\fsgx[\enclaveprog, \relay]$:\\ 
\quad \sgray{\it //send out ~{\bf msg.}~$m_3$}\\
\quad {\sf AuthSend} $((\dgid, \dgform, \dgm, \fee))$ to \tcont as \tcadd \\[5pt]

{\bf  Main}: \\
%{\bf Request}:
Loop Forever:\\ 
\quad Wait until \tcont records a request \\
\quad \ $(\dgid, \dgform, \_, \_,$ $\gasrequest$ $+ \fee)$:  \\  %\sgray{{\it //~{\bf msg.}~$m_2$}}\\
\quad Parse \dgform as $(\weburl, \dgspec, T)$\\
\quad Fork a process of {\bf Handle}($T, \dgid, \dgform, \fee$)\\
End \\
\end{tabular}
\end{boxedminipage}
\caption{The Town Crier \medname \relay (with fees).}
\label{fig:relayprotgas}
\end{figure}

\begin{figure}[!h]
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Program for \tcs~\encname ($\enclaveprog$)}
\end{center}
\begin{tabular}{l}
%{\bf Inputs}:  ${\sf params}$, \\[5pt]
%{\bf Initialize}:  On recv (\initcall, $T_0)$: \\ %{\it //~called only once upfront}\\
{\bf Initialize}:  
Same as Figure \elaine{refer}
\\[3pt]

%{\bf Attest}:  On recv \attcall: \\ %{\it //~called only once upfront}\\
%\quad $T := \clock()$\\
%\quad Call quoting enclave with supp.~data $(\pkTC, T)$
%\\[5pt]

{\bf Resume:} On recv (\resumecall, $(\dgid, \dgform, {\tt F}))$\\
\quad Same as before except the last two statements:\\
\quad Let $\gasdeliver := {\tt F}$\\
\quad $\sigma := \Sigma.{\sf Sign}({\skTC}, (\dgid, \dgform, \dgm,
\gasdeliver))$\\
\quad Output $((\dgid, \dgform, \dgm, \gasdeliver), \sigma)$
\end{tabular}
\end{boxedminipage}
\caption{
The \tcs~\encname \engine.
} 
\label{fig:engineprot}
\end{figure}

More specifically, We will use the following notations to denote regular currency units and gas. 

\begin{table}[!h]
\begin{tabular}{m{0.13\columnwidth}m{0.8\columnwidth}}
\hline
$\fee$ & currency a requester deposits to refund the gas Town Crier
must advance to deliver a datagram\\
\hline
$\feecancel$ & currency deposited upon cancellation 
to refund the gas Town Crier  
expends should a datagram be delivered after cancellation\\
\hline
$\gasdeliver$
$\gasrequest$
$\gascancel$ & 
gas attached when invoking the {\bf Deliver}, {\bf Request}, {\bf Cancel} entries points
respectively \\
\hline
$\constgascancel$
& gas needed to execute {\bf Deliver} should it happen after cancellation\\
\hline
$\constgasmax$
& amount of gas deposited in Town Crier's account $\tcadd$ 
  \ethan{Ethereum actually imposes a gas limit for a transaction that is currently a bit over 3.1 million.
  Do we want to mention that here? That's how I actually picked $\constgasmax$ when I wrote the code.} \\
\hline
$\constgasmin$
& gas needed for the {\bf Deliver} entry point when $\dgcallback$ is empty \\
\hline
\end{tabular}
\end{table}

Note that $\constgascancel$, 
$\constgasmax$, and $\constgasmin$
are fixed system parameters;
whereas 
$\fee$
and 
$\feecancel$
are chosen 
by the requester (and can be malicious values if the requester is malicious).
Similarly, 
$\gasdeliver$,
$\gasrequest$,
and $\gascancel$
denote gas
chosen by Town Crier, and can be malicious values if the Town Crier Relay is malicious.  
\ethan{I don't think this is true.
  I believe the gas is specified as part of the transaction, which means the enclave picks the number.
  The only thing a malicious relay can do is make it so $\tcadd$ doesn't have $\constgasmax$ to front.}
Later in Section \elaine{refer}, 
we will prove that our protocol ensures that Town Crier does not lose gas,
and that the 
requester's loss is limited even against a malicious Town Crier.

\paragraph{Town Crier protocol with transaction fees.}
Our basic Town Crier implements a policy where the requester pays for all gas 
needed and Town Crier in effect pays nothing.
We now describe how this can be realized by modifying
the fee-free protocol described in Section \elaine{refer}. 

\begin{itemize}[leftmargin=5mm]
\item
{\it Initialization.}
To initialize the system, we assume that Town Crier 
deposits a fixed amount $\constgasmax$ 
into the wallet account $\pksgx$.
\item
{\it Town Crier blockchain contract.}
Figure \elaine{refer} describes the  
Town Crier blockchain contract reflecting fees.
Since Town Crier's account 
$\pksgx$ has to invoke the {\bf Deliver} entry point, it 
advances a gas payment 
$\gasdeliver := \fee$.
If the deliver operation is successful, 
this amount will be entirely refunded through money deposited in the contract 
by the requester.
Otherwise, should the deliver operation happen after the request has already
been cancelled, 
a small amount of gas equal to $\constgascancel$ 
is consumed from $\gasdeliver$
which will be entirely refunded 
to $\tcadd$ (since the requester must deposit $\feecancel \geq \constgascancel$) for cancellation;
%(denoted by $\smaroon{\overline{F}_{\text{deliver}}}$); 
and further all gas remaining  
from $\gasdeliver$ will automatically 
be refunded to $\tcadd$ due to Ethereum's operational semantics for gas. 
\item
{\it Town Crier Relay.}
The Town Crier relay monitors
the blockchain, and whenever
the blockchain contract \tcont
receives a new request $(\dgform, \dgcallback, 
\gasrequest+\fee)$,
it asserts that 
\[
\constgasmin
\leq \fee \leq \constgasmax
\]
where $\constgasmax$ is the total amount of money
in Town Crier's account $\pksgx$, 
and $\constgasmin$
is the cost of executing the {\bf Deliver} entry point 
when the user-defined callback is empty.
The check 
$\fee \leq \constgasmax$
ensures that Town Crier's enclave  
has sufficient funds to advance
for the {\bf Deliver} phase.
The check 
$\constgasmin \leq \fee$
ensures that 
the {\bf Deliver} entry point should 
have sufficient gas to execute everything excluding the user-defined
callback -- this guarantees that the statement
where Town Crier gets refunded for the gas is always reached.
\ethan{Right now we're running this check inside \tcont and the request isn't even recorded if the check fails.
  This means the relay only has to watch for valid (recorded) requests, and it doesn't have to sanity check anything.}


Finally, the Town Crier relay passes
the tuple $({\tt resume}, (\dgid, \dgform, {\tt f}))$
as input to the enclave.


\item
{\it Town Crier enclave.}
We make the following small modification to the fee-free protocol
described in Figure \elaine{refer}.
Instead of signing the tuple $(\dgid, \dgform, \dgm)$
at the end of the enclave's execution, the enclave now signs 
the tuple $(\dgid, \dgform, \dgm, \gasdeliver)$
instead, where signing 
$\gasdeliver$ authorizes a
gas amount of $\gasdeliver$ to be advanced
to the contract (which will be refunded later).
\item
{\it Requester.}
The honest requester would behave the same way as in Figure \elaine{refer},
except for additionally putting 
in $\gasrequest + \fee$ 
amount with each request, 
where the honest 
requester would set  
$\gasrequest$
to the gas cost of executing the  
{\bf Request} entry point,
and set $\fee$ to be the cost 
of executing the {\bf Deliver} entry point (including
the cost of executing the user-defined $\dgcallback$ function).

If the honest request $\reqcont$ did not receive
a callback for some $\dgid$,  
%before the specified deadline ${\color{blue} \Time_{\text{timeout}}}$,
it can invoke {\bf Cancel}
with ($\dgid$, $\gascancel + \feecancel$),
where $\gascancel$ is the amount of gas needed 
to execute the {\bf Cancel} entry point, and $\feecancel := \constgascancel$
is a small amount of money paid to perform cancellation, 
such that Town Crier will be refunded for the small amount of gas expended,
should it deliver a datagram after a cancellation happened.

\ethan{It sounds like you're expecting an honest \reqcont to pass in $(\dgid, \gascancel + \feecancel)$ and get $\fee$ back out.
I don't have a problem with the model, but the implementation has \reqcont pass in $(\dgid, \gascancel)$ and get $\fee - \constgascancel$ back out.
This actually eliminates the need for $\feecancel$ entirely and works if $\constgascancel \leq \constgasmin$.}
\end{itemize}


