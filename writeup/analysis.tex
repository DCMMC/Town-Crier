\section{Security Analysis}
\label{sec:analysis}


\subsection{Definition and Proof: Authenticity of Data Feed}
Roughly speaking, authenticity means that 
an adversary (including a corrupt
user, a corrupt relay, or the collusion thereof)
cannot convince   
the Town Crier blockchain contract 
$\tcont$ to accept 
a wrong data feed. 
Here a wrong data feed means any content
that differs from the expected content
obtained by crawling the specified \weburl at 
the specified time $T$.

In formally defining 
authenticity, 
we assume that the user and the blockchain
contract $\tcont$ behave honestly.
Recall that the user must verify 
upfront the attestation $\sigatt$ 
that vouches 
for the enclave's public key $\pksgx$.

\elaine{the proof may need to be fixed since the protocol was modified.}

\begin{definition}[Authenticity]
We say that the Town Crier protocol 
satisifies {\it authenticity} of data feed,
if for any polynomial-time adversary
that can interact arbitrarily with $\fsgx$,
it cannot 
persuade an honest verifier to accept
a tuple $(\pksgx, \sigatt, {\sf params}:=(\weburl, \pkurl, T), {\sf data}, \sigma)$
%${\sf params} := (\weburl, \pkurl, T)$).
where ${\sf data}$ is not 
the contents of 
\weburl with the public key $\pkurl$ at time $T$.
More formally, 
for any probablistic polynomial-time adversary $\algA$
\[
\begin{array}{l}
\Pr\left[
\begin{array}{l}
(\pksgx, \sigatt, {\sf id}, {\sf params}, {\sf data}, \sigma) \leftarrow 
\algA^{\fsgx}(1^\lambda) :\\
\quad \left(\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pksgx)) = 1\right) \wedge \\
\quad \left(\Sigma.{\sf Verify}(\pksgx, {\sf id}, {\sf params}, {\sf data})  = 1\right) \wedge\\
\quad {\sf data} \neq \enclaveprog({\sf params}) 
\end{array}
\right] \\[3pt] 
\leq {\sf negl}(\lambda)
\end{array}
\]
\label{defn:auth}
\end{definition}


\begin{theorem}[Authenticity]
Assume that $\sigsgx$
and $\Sigma$ are secure signature schemes (recall
that we follow Shi et al. \elaine{cite} who show
how to abstractly  
model SGX's group signature as a regular signature
scheme under a manufacturer public key $\pkM$),
%and assume that the cryptographic protocol used to realize the secure channel
%with $\pkurl$ is secure;
then, the above 
protocol achieves authenticity of data feed by Definition~\ref{defn:auth}.
\end{theorem}
\begin{proof} (sketch.)
We show that if the 
adversary $\algA$ succeeds in a forgery with non-negligible probability,
we can construct an adversary $\algB$ that can either
break $\sigsgx$ or $\Sigma$ with non-neligible probability.
We consider two cases. 
The reduction $\algB$ will flip a random coin to guess which
case it is, and if the guess is wrong, simply abort.
\begin{itemize}[leftmargin=5mm]
\item
Case 1: $\algA$ outputs a signature $\sigma$ that uses the same  
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will try to break $\Sigma$. 
$\algB$ interacts with a signature challenger ${\sf Ch}$ who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates 
$\fsgx$ by implicitly letting $\pksgx := \pk^*$.
Whenever $\fsgx$ needs to sign a query, $\algB$ passes the signing query
onto the signature challenger ${\sf Ch}$.

Since ${\sf data} \neq \enclaveprog({\sf params})$,
$\algB$ cannot have queried ${\sf Ch}$  
on a tuple of the form $(\_, {\sf params}, {\sf data})$. 
Therefore, $\algB$ simply outputs 
what $\algA$ 
outputs (suppressing unnecessary terms) as the signature forgery. 

\item
Case 2:
 $\algA$ outputs a signature $\sigma$ that uses a different 
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will seek to break $\sigsgx$.
$\algB$ interacts with a signature challenger ${\sf Ch}$, who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates $\fsgx$ by implicitly setting
$\pkM := \pk^*$.
Whenever $\fsgx$ needs to make a signature
with $\skM$, 
$\algB$ simply passes the signature query onto ${\sf Ch}$.
In this case, in order for $\algA$ to succeed,
it must produce a valid signature $\sigatt$ 
for a different public key $\pk'$.
Therefore, $\algB$ simply outputs this as a signature forgery.
\end{itemize}
\end{proof}




\subsection{Gas Neutrality}


\begin{theorem}[Gas neutrality for Town Crier]
If the \tc~\medname is honest,
Town Crier's wallet $\tcadd$ will have at least $\constgasmax$ remaining after each {\bf Deliver} call.
\end{theorem}


\begin{theorem}[Fair Expenditure for Honest Requester]
For any request $(\dgform, \dgcallback, \fee)$ submitted by an honest user $\reqcont$,
at most $\constgascancel$ of the user's total payment will not be spent on computation requested by and executed on behalf of that user.
\end{theorem}



%\subsection{Gas neutrality}
%
%\begin{theorem}[Gas neutrality for Town Crier]
%Assuming that the Town Crier relay is honest, 
%then Town Crier's wallet account $\pksgx$ 
%will have at least $\sbrown{\$ G_{\text{max}}}$
%amount remaining after each {\bf Deliver}  
%call finishes execution.
%\end{theorem}
%\begin{proof}[(sketch).]
%Since the relay is honest, every time 
%$\pksgx$ invokes the {\bf Deliver}
%entry point, the following holds:
%1) 
%$\sbrown{\$ G_{\text{deliver}}}
%= \smaroon{\$ F}$;
%i.e., the gas $\tcadd$ advances is equal
%to the fees the 
%requester deposited with the \tcont contract;
%2)
%the amount gas sent 
%$\sbrown{\$ G_{\text{deliver}}} 
%\leq 
%\sbrown{\$ G_{\text{max}}} 
%$;
%in other words, 
%$\tcadd$ has sufficient funds  
%if it starts out with $\sbrown{\$ G_{\text{max}}}$
%in its wallet;
%and
%3) 
%$\sbrown{\$ G_{\text{min}}} \leq
%\sbrown{\$ G_{\text{deliver}}}$; in other words, the statement that refunds
%$\tcadd$ 
%$\smaroon{\$ F}$
%amount, denoted (**) in Figure \elaine{fill in ref}, will definitely be invoked. This 
%ensures that the full gas amount 
%$\sbrown{\$ G_{\text{deliver}}}$
%that $\tcadd$ advanced will be refunded (and anything more left
%at the end of the execution will also be refunded);
%\end{proof}
%
%
%
%
%
%\begin{theorem}[Bounded loss for honest requester]
%Suppose request $({\sf params}, {\sf callback}, \_)$ was submitted
%by an honest requester $\reqcont$;
%%and got assigned a unique identifier
%%${\sf id}$ by $\tcont$;
%then 
%either 
%\begin{itemize}[leftmargin=5mm]
%\item ${\sf callback}$ will be invoked  
%with a valid datagram matching requested parameters
%${\sf params}$,
%and the requester consumes at most
%$\sbrown{\$ \overline{G}_{\text{request}}} + \sbrown{\$ \overline{G}_{\text{deliver}}} + 
%\sbrown{\$ \overline{G}_{\text{cancel}}}
%+ \sbrown{\$ \overline{G}_{\emptyset}}$;
%or 
%\item
%$\reqcont$ 
%consumes at most 
%$\sbrown{\$ \overline{G}_{\text{request}}} + \sbrown{\$ \overline{G}_{\text{cancel}}} + 
%\sbrown{\$ \overline{G}_{\emptyset}}$ after calling {\bf Cancel}.
%%after ${\color{blue} \Time_{\text{timeout}}}$.
%\end{itemize}
%In the above, $\sbrown{\overline{G}_{\text{request}}}$,
%$\sbrown{\$ \overline{G}_{\text{deliver}}}$,
%and $\sbrown{\$ \overline{G}_{\text{cancel}}}$ 
%denotes the maximum gas required
%to execute the {\bf Request}, {\bf Cancel} entry points respectively;
%and $\sbrown{\$ \overline{G}_{\emptyset}}$ denotes the 
%gas needed for {\bf Deliver} -- should the datagram delivery
%happen after a cancellation has happened.
%\end{theorem}
%
%\begin{proof}[(sketch.)]
%%An honest requester $\reqcont$  
%%picks a random, sufficiently long ${\sf id}$ such
%%that the probability of collision with an existing ${\sf id}$ 
%%is negligible.
%%Recall that $\tcont$ ignores all future occurrences of ${\sf id}$, i.e.,
%%only the first occurrence of ${\sf id}$ is preserved. 
%An honest requester $\reqcont$  
%puts in 
%$\sbrown{\$ \overline{G}_{\text{request}}} + 
%\sbrown{\$ \overline{G}_{\text{deliver}}}$
%amount with each request to $\tcont$,
%
%\paragraph{Case 1.}
%For a specific ${\sf id}$,
%if the line marked (*) %``Set ${\sf bDelivered[{\sf id}]}$''
%in \tcont
%is reached,
%%for some ${\sf id}$ at any point,
%then it is guaranteed that the following assertions
%hold:
%%${\color{blue} \Time_{\text{timeout}}} > {\sf cur\_time}$,
%${\sf params} = {\sf params}'$,
%and $\smaroon{\$ F} = \sbrown{\$ \overline{G}_{\text{deliver}}} \leq 
%\sbrown{\$ G_{\text{deliver}}}$.
%In this case, 
%\tcont will finish execution and the requester
%would have obtained the resulting 
%datagram for the correct ${\sf params}$ specified in the request.
%%and before the requested deadline ${\color{blue} \Time_{\text{timeout}}}$.
%Now the honest requester may have invoked {\bf Cancel}
%before it receives the delivered datagram. 
%In this case, the honest requester pays $\sbrown{\overline{G}_{\text{cancel}}} + 
%\sbrown{\overline{G}_\emptyset}$
%upfront for the cancellation request.
%Therefore, the total the honest requester loses in this case
%is bounded by 
%$\sbrown{\$ \overline{G}_{\text{request}}} + \sbrown{\$ \overline{G}_{\text{deliver}}} + 
%\sbrown{\$ \overline{G}_{\text{cancel}}}
%+ \sbrown{\$ \overline{G}_{\emptyset}}$.
%
%
%\paragraph{Case 2.}
%%Else, if 
%%the line ``Set ${\sf bDelivered[{\sf id}]}$''
%%in \tcont
%%is never reached for some ${\sf id}$ before the requested deadline 
%%${\color{blue} \Time_{\text{timeout}}}$, 
%Else, if 
%${\sf bCanceled}[{\sf id}]$ is set before 
%the line marked (*) 
%is reached --- note that in this case, the line 
%marked (*) will never be reached for ${\sf id}$ --- 
%then the honest requester would have invoked  $\reqcont$.
%An honest requester pays $\sbrown{\overline{G}_{\text{cancel}}} + 
%\sbrown{\overline{G}_\emptyset}$
%upfront for the cancellation request --- this ensures that
%the requester will be refunded the amount $\smaroon{\${F}} := \sbrown{\overline{G}_{\text{deliver}}}$, and since
%It is not hard to see that the honest requester loses at most
%$\sbrown{\$ \overline{G}_{\text{request}}} + 
%\sbrown{\$ \overline{G}_{\text{cancel}}}
%+ \sbrown{\$ \overline{G}_{\emptyset}}$ in this case.
%%can invoke the {\bf Cancel}
%%entry point to obtain a refund 
%%of $\smaroon{\$F_{\text{deliver}}}$ before ${\color{blue} \Time_{\text{timeout}}}$ ---
%%in this case the honest requester would have lost
%%no more than $\sbrown{\$ G_{\text{request}}} + \sbrown{\$ G_{\text{cancel}}}$.
%\end{proof}



%Here we assume an adversary which is active on the blockchain, the network, and within the untrusted executable running on the Town Crier server.
%However, we assume that the adversary will not execute an arbitrary denial of service attack, but will rather delay messages indefinitely and deliver bogus data whenever such data will be accepted as valid.
%Because operations on the blockchain are verifiable and the SGX enclave can attest to what it is running, we assume those are honest.
%
%In this model we show that, for every request which provides a sufficient fee,
%a valid authenticated datagram will be delivered to the requested callback location in finite time.
%If the request includes an insufficient fee (but is otherwise valid),
%the datagram will not be delivered, but the (too-small) fee will still be collected.
%
%\begin{lemma} \label{lem:non-bankrupt-p_sgx}
%If seeded with at least $F_{\rm max}$ ether, the \sgxadd wallet will have
%at least as much money after each transaction as it had before that transaction.
%\end{lemma}
%
%\begin{proof}
%\ethan{This is actually a proof sketch, I just put it in a proof tag.}
%
%Because all blockchain transactions from \sgxadd must be initiated by the SGX enclave and the SGX only calls \tcont.Deliver,
%we need only reason about what happens inside that function.
%Because transactions including \tcont are transmitted securely into the SGX enclave, it will only see valid requests (ones for which $F_{\rm min} \leq \${\sf fee} \leq F_{\rm max}$) and the arguments it sees for those requests will be correct.
%Moreover, it saves the transaction ID of each request it fulfills and never fulfills a request with the same transaction ID twice.
%This means that whenever deliver is called, it will be called in connection with a valid request that has not already been delivered.
%Thus it suffices to show that:
%\begin{enumerate}
%  \item The first time a valid request is delivered, \tcont will contain at least $\${\sf fee}$ ether.
%  \item $\${\sf fee}$ is never lower than the amount \sgxadd must spend in gas.
%  \item The execution of Deliver will never run out of gas (and thus always succeed).
%\end{enumerate}
%
%To prove claim 1 we first note that ether can only be removed from \tcont as part of a call to Deliver from \sgxadd.
%Because \sgxadd is honest, it will only make this call in connection with a valid request, and the specified value of $\${\sf fee}$ will always be the fee submitted with that request.
%Because \tcont pays out the specified $\${\sf fee}$ on the call to Deliver, the ether is always exactly the ether stored from a previous, valid, undelivered request, and thus will always be present in \tcont.
%
%To prove claim 2 first note that a request is only considered valid if $\${\sf fee} \geq F_{\rm min}$.
%$F_{\rm min}$ is defined so that it is high enough to cover gas costs for all of Deliver except the execution of the provided ${\sf callback}$.
%However, ${\sf callback}$ is only given $\${\sf fee} - F_{\rm min}$ ether worth of gas to execute.
%Therefore it is impossible for the entire call of Deliver to spend more than $F_{\rm min} + (\${\sf fee} - F_{\rm min}) = \${\sf fee}$ ether on gas.
%
%To prove claim 3 we note that $\${\sf fee} \leq F_{\rm max}$ and, by construction, \sgxadd will always provide at least $F_{\rm max}$ in gas for the execution of Deliver.
%Therefore we have that \sgxadd will always provide at least $\${\sf fee}$ in gas to execute Deliver.
%By the argument above, Deliver can never use more than $\${\sf fee}$ in gas, so therefore an SGX-initialized call to Deliver will never run out of gas.
%\end{proof}
%
%
%
%\begin{lemma} \label{lem:authentic-delivery}
%Any data given as an argument to ${\sf callback}$ in \tcont's Deliver method is verifiably authentic.
%\end{lemma}
%

\subsection{Other security concerns}
We treat side-channel attacks as outside the scope of our initial \tc architecture. Such attacks would be of particular concern should the \medname be compromised. Intel explicitly disclaims protections against side-channel attacks in SGX. The ability for the OS to monitor page faults incurred by a process running in an enclave is an example shown to be potentially serious in practice~\cite{}. Additionally, the \medname or any network adversary can potentially perform traffic analysis to determine what content the \encname is retrieving from a remote server~\cite{}, a potential threat to the confidentiality of private datagrams.


