\section{Security Analysis}


\subsection{Definition and Proof: Authenticity of Data Feed}
Roughly speaking, authenticity means that 
an adversary (including a corrupt
user, a corrupt relay, or the collusion thereof)
cannot convince   
the Town Crier blockchain contract 
$\tcont$ to accept 
a wrong data feed. 
Here a wrong data feed means any content
that differs from the expected content
obtained by crawling the specified \weburl at 
the specified time $T$.

In formally defining 
authenticity, 
we assume that the user and the blockchain
contract $\tcont$ behave honestly.
Recall that the user must verify 
upfront the attestation $\sigatt$ 
that vouches 
for the enclave's public key $\pksgx$.

\elaine{the proof may need to be fixed since the protocol was modified.}

\begin{definition}[Authenticity]
We say that the Town Crier protocol 
satisifies {\it authenticity} of data feed,
if for any polynomial-time adversary
that can interact arbitrarily with $\fsgx$,
it cannot 
persuade an honest verifier to accept
a tuple $(\pksgx, \sigatt, {\sf params}:=(\weburl, \pkurl, T), {\sf data}, \sigma)$
%${\sf params} := (\weburl, \pkurl, T)$).
where ${\sf data}$ is not 
the contents of 
\weburl with the public key $\pkurl$ at time $T$.
More formally, 
for any probablistic polynomial-time adversary $\algA$
\[
\begin{array}{l}
\Pr\left[
\begin{array}{l}
(\pksgx, \sigatt, {\sf id}, {\sf params}, {\sf data}, \sigma) \leftarrow 
\algA^{\fsgx}(1^\lambda) :\\
\quad \left(\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pksgx)) = 1\right) \wedge \\
\quad \left(\Sigma.{\sf Verify}(\pksgx, {\sf id}, {\sf params}, {\sf data})  = 1\right) \wedge\\
\quad {\sf data} \neq \enclaveprog({\sf params}) 
\end{array}
\right] \\[3pt] 
\leq {\sf negl}(\lambda)
\end{array}
\]
\label{defn:auth}
\end{definition}


\begin{theorem}[Authenticity]
Assume that $\sigsgx$
and $\Sigma$ are secure signature schemes (recall
that we follow Shi et al. \elaine{cite} who show
how to abstractly  
model SGX's group signature as a regular signature
scheme under a manufacturer public key $\pkM$),
%and assume that the cryptographic protocol used to realize the secure channel
%with $\pkurl$ is secure;
then, the above 
protocol achieves authenticity of data feed by Definition~\ref{defn:auth}.
\end{theorem}
\begin{proof} (sketch.)
We show that if the 
adversary $\algA$ succeeds in a forgery with non-negligible probability,
we can construct an adversary $\algB$ that can either
break $\sigsgx$ or $\Sigma$ with non-neligible probability.
We consider two cases. 
The reduction $\algB$ will flip a random coin to guess which
case it is, and if the guess is wrong, simply abort.
\begin{itemize}[leftmargin=5mm]
\item
Case 1: $\algA$ outputs a signature $\sigma$ that uses the same  
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will try to break $\Sigma$. 
$\algB$ interacts with a signature challenger ${\sf Ch}$ who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates 
$\fsgx$ by implicitly letting $\pksgx := \pk^*$.
Whenever $\fsgx$ needs to sign a query, $\algB$ passes the signing query
onto the signature challenger ${\sf Ch}$.

Since ${\sf data} \neq \enclaveprog({\sf params})$,
$\algB$ cannot have queried ${\sf Ch}$  
on a tuple of the form $(\_, {\sf params}, {\sf data})$. 
Therefore, $\algB$ simply outputs 
what $\algA$ 
outputs (suppressing unnecessary terms) as the signature forgery. 

\item
Case 2:
 $\algA$ outputs a signature $\sigma$ that uses a different 
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will seek to break $\sigsgx$.
$\algB$ interacts with a signature challenger ${\sf Ch}$, who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates $\fsgx$ by implicitly setting
$\pkM := \pk^*$.
Whenever $\fsgx$ needs to make a signature
with $\skM$, 
$\algB$ simply passes the signature query onto ${\sf Ch}$.
In this case, in order for $\algA$ to succeed,
it must produce a valid signature $\sigatt$ 
for a different public key $\pk'$.
Therefore, $\algB$ simply outputs this as a signature forgery.
\end{itemize}
\end{proof}




\subsection{Gas neutrality}

\begin{theorem}[Gas neutrality for Town Crier]
Assuming that the Town Crier relay is honest, 
then Town Crier's wallet account $\pksgx$ 
will have at least $\sbrown{\Delta F_{\text{max}}}$
amount remaining after each {\bf Deliver}  
call finishes execution.
\end{theorem}
\begin{proof}[(sketch).]
Since the relay is honest, every time 
$\pksgx$ invokes the {\bf Deliver}
entry point, the following holds:
1) 
$\smaroon{\$ F_{\text{deliver}}}
= \sbrown{\Delta F_{\text{deliver}}}$;
i.e., the gas $\tcadd$ advances is equal
to the fees the 
requester deposited with the \tcont contract;
2)
the amount gas sent 
$\sbrown{\Delta F_{\text{deliver}}} = 
\smaroon{\$ F_{\text{deliver}}}
\leq 
\sbrown{\Delta F_{\text{max}}} 
$;
in other words, 
$\tcadd$ has sufficient funds  
if it starts out with $\sbrown{\Delta F_{\text{max}}}$
in its wallet;
and
3) 
$\sbrown{\Delta F_{\text{min}}} \leq
\sbrown{\Delta F_{\text{deliver}}} = 
\smaroon{\$ F_{\text{deliver}}}
$; in other words, the statement that refunds
$\tcadd$ 
$\smaroon{\$ F_{\text{deliver}}}$
amount will definitely be invoked. This 
ensures that the full gas amount 
$\sbrown{\Delta F_{\text{deliver}}}$
that $\tcadd$ advanced will be refunded (and anything more left
at the end of the execution will also be refunded);
\end{proof}





\begin{theorem}[Bounded loss for honest requester]
Suppose request $({\sf id}, {\sf params}, {\sf callback}, 
{\color{blue} \Time_{\text{timeout}}}, \_)$ was submitted
by an honest requester $\reqcont$;
then 
$\reqcont$ will  either obtain 
a valid datagram matching requested parameters
${\sf params}$
before the specified deadline  
${\color{blue} \Time_{\text{timeout}}}$;
or 
$\reqcont$ will have lost at most 
$\sbrown{\Delta F_{\text{request}}} + \sbrown{\Delta F_{\text{cancel}}}$
after ${\color{blue} \Time_{\text{timeout}}}$.

\end{theorem}

\begin{proof}[(sketch.)]
%An honest requester $\reqcont$  
%picks a random, sufficiently long ${\sf id}$ such
%that the probability of collision with an existing ${\sf id}$ 
%is negligible.
%Recall that $\tcont$ ignores all future occurrences of ${\sf id}$, i.e.,
%only the first occurrence of ${\sf id}$ is preserved. 
An honest requester $\reqcont$  
puts in 
$\sbrown{\Delta F_{\text{request}}} + \smaroon{\$ F_{\text{deliver}}}$
amount with each request to $\tcont$,
where $\sbrown{\Delta F_{\text{request}}}$
is equal to the gas cost of executing the
{\bf Request} entry point,
and $\smaroon{\$ F_{\text{deliver}}}$ is the gas cost
of executing the {\bf Deliver} entry point (including
the cost of executing the user-defined ${\sf callback}$ function).

Regardless of what the adversary does,  
if the line ``Set ${\sf bDelivered[{\sf id}]}$''
in \tcont
is reached for some ${\sf id}$ at any point,
then it is guaranteed that the following assertions
hold:
${\color{blue} \Time_{\text{timeout}}} > {\sf cur\_time}$,
${\sf params} = {\sf params}'$,
and $\smaroon{\$ F'_{\text{deliver}}} \leq 
\sbrown{\Delta F_{\text{deliver}}}$.
In this case, \tcont will finish execution and the requester
would have obtained the resulting 
datagram for the correct ${\sf params}$ specified in the request,
and before the requested deadline ${\color{blue} \Time_{\text{timeout}}}$.
Else, if this line 
the line ``Set ${\sf bDelivered[{\sf id}]}$''
in \tcont
is never reached for some ${\sf id}$ before the requested deadline 
${\color{blue} \Time_{\text{timeout}}}$, then 
the honest requester $\reqcont$ can invoke the {\bf Cancel}
entry point to obtain a refund 
of $\smaroon{\$F_{\text{deliver}}}$ before ${\color{blue} \Time_{\text{timeout}}}$ ---
in this case the honest requester would have lost
no more than $\sbrown{\Delta F_{\text{request}}} + \sbrown{\Delta F_{\text{cancel}}}$.
\end{proof}



%Here we assume an adversary which is active on the blockchain, the network, and within the untrusted executable running on the Town Crier server.
%However, we assume that the adversary will not execute an arbitrary denial of service attack, but will rather delay messages indefinitely and deliver bogus data whenever such data will be accepted as valid.
%Because operations on the blockchain are verifiable and the SGX enclave can attest to what it is running, we assume those are honest.
%
%In this model we show that, for every request which provides a sufficient fee,
%a valid authenticated datagram will be delivered to the requested callback location in finite time.
%If the request includes an insufficient fee (but is otherwise valid),
%the datagram will not be delivered, but the (too-small) fee will still be collected.
%
%\begin{lemma} \label{lem:non-bankrupt-p_sgx}
%If seeded with at least $F_{\rm max}$ ether, the \sgxadd wallet will have
%at least as much money after each transaction as it had before that transaction.
%\end{lemma}
%
%\begin{proof}
%\ethan{This is actually a proof sketch, I just put it in a proof tag.}
%
%Because all blockchain transactions from \sgxadd must be initiated by the SGX enclave and the SGX only calls \tcont.Deliver,
%we need only reason about what happens inside that function.
%Because transactions including \tcont are transmitted securely into the SGX enclave, it will only see valid requests (ones for which $F_{\rm min} \leq \${\sf fee} \leq F_{\rm max}$) and the arguments it sees for those requests will be correct.
%Moreover, it saves the transaction ID of each request it fulfills and never fulfills a request with the same transaction ID twice.
%This means that whenever deliver is called, it will be called in connection with a valid request that has not already been delivered.
%Thus it suffices to show that:
%\begin{enumerate}
%  \item The first time a valid request is delivered, \tcont will contain at least $\${\sf fee}$ ether.
%  \item $\${\sf fee}$ is never lower than the amount \sgxadd must spend in gas.
%  \item The execution of Deliver will never run out of gas (and thus always succeed).
%\end{enumerate}
%
%To prove claim 1 we first note that ether can only be removed from \tcont as part of a call to Deliver from \sgxadd.
%Because \sgxadd is honest, it will only make this call in connection with a valid request, and the specified value of $\${\sf fee}$ will always be the fee submitted with that request.
%Because \tcont pays out the specified $\${\sf fee}$ on the call to Deliver, the ether is always exactly the ether stored from a previous, valid, undelivered request, and thus will always be present in \tcont.
%
%To prove claim 2 first note that a request is only considered valid if $\${\sf fee} \geq F_{\rm min}$.
%$F_{\rm min}$ is defined so that it is high enough to cover gas costs for all of Deliver except the execution of the provided ${\sf callback}$.
%However, ${\sf callback}$ is only given $\${\sf fee} - F_{\rm min}$ ether worth of gas to execute.
%Therefore it is impossible for the entire call of Deliver to spend more than $F_{\rm min} + (\${\sf fee} - F_{\rm min}) = \${\sf fee}$ ether on gas.
%
%To prove claim 3 we note that $\${\sf fee} \leq F_{\rm max}$ and, by construction, \sgxadd will always provide at least $F_{\rm max}$ in gas for the execution of Deliver.
%Therefore we have that \sgxadd will always provide at least $\${\sf fee}$ in gas to execute Deliver.
%By the argument above, Deliver can never use more than $\${\sf fee}$ in gas, so therefore an SGX-initialized call to Deliver will never run out of gas.
%\end{proof}
%
%
%
%\begin{lemma} \label{lem:authentic-delivery}
%Any data given as an argument to ${\sf callback}$ in \tcont's Deliver method is verifiably authentic.
%\end{lemma}
%

\subsection{Other security concerns}
We treat side-channel attacks as outside the scope of our initial \tc architecture. Such attacks would be of particular concern should the \medname be compromised. Intel explicitly disclaims protections against side-channel attacks in SGX. The ability for the OS to monitor page faults incurred by a process running in an enclave is an example shown to be potentially serious in practice~\cite{}. Additionally, the \medname or any network adversary can potentially perform traffic analysis to determine what content the \encname is retrieving from a remote server~\cite{}, a potential threat to the confidentiality of private datagrams.


