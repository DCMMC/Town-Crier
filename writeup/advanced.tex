\section{Future Work}
\label{sec:future}

We plan to develop \tc after its initial deployment and expect it to evolve to incorporate a number of additional features. These fall into two categories: (1) Expanding the security model to address threats outside the scope of the initial version and (2) Extending the functionality of \tc. Here we briefly discuss a few of these extensions.

\subsection{Expanding \tc threat model}

\begin{itemize}
\item{\em Freeloading protection.} Serious concerns have  arisen in the Ethereum community about ``parasite contracts'' that forward or resell datagrams---particularly those from fee-based data feeds~\cite{parasite}. We plan to deploy a novel mechanism in \tc to address this concern. Suppose contract \reqcont involves a set of parties / users $U = \{U_i\}_{i=1}^n$. Each player $U_i$ generates an individual share $(\sk_i, \pk_i)$ of a global keypair $(\pk, \sk)$, where $\sk = \sum_{i=1} \sk_i$ and $\pk = \prod_{i=1} \pk_i$, and communicates a ciphertext $E_{\pkTC}[\sk_i]$ to \tcont, e.g., by including it in a datagram request. Players then jointly set  up under public key $\pk$ a wallet $\specialwallet$ for datagram transmission by \tcont. 

Thanks to the homomorphic properties of ECDSA, \tcont can compute $\sk$ (non-interactively) and send datagrams from $\specialwallet$. But the users $U$ collaboratively \emph{can also compute $\sk$ and send messages from $\specialwallet$}. Consequently, while each user $U_i$ can individually be assured that a datagram sent to \reqcont by \tcont from $\specialwallet$ is valid (as $P[i]$ didn't collude in its creation), other players cannot determine whether a datagram was produced by $\tcont$ or $U$, and thus whether or not it is valid. Such a \emph{source-equivocal datagram} renders data from parasite contracts less trustworthy and thus less attractive. 
\item{\em Traffic-analysis protection.} As noted in the body of the paper, \medname can observe the pattern of data sources accesses made by \tc. By correlating with activity in \tcont, an adversarial \medname can thus infer the data source targeted by private datagrams, as well as the timing---and potentially, based on traffic analysis, of the \encname's HTTPS requests. (See, e.g.,~\cite{chen2010side}.) In the example contract {\sf FlightIns} in Section~\ref{sec:applications}, this issue is partially addressed through the insertion of random delays into \tc responses. We intend to develop a comprehensive approach to mitigating traffic analysis in \tc. This approach will include, for the problem of traffic analysis of web scraping, the incorporation of facilities in the \encname to make chaff or decoy data requests, i.e., false requests, to both the true data source and well as non-target data sources. 

\item{\em Revocation support.} Revocation of two forms can impact the \tc service. 

First, the certificates of data sources may be revoked. To address this issue, given its ability to establish external HTTPS connections, \tc could easily make use of Online Certificate Status Protocol (OCSP) certificate checking. This functionality would amount to an additional form of web scraping, and could be executed in parallel with web scraping to support datagram requests, resulting in minimal additional latency.

Second, an SGX host could become compromised, prompting revocation of its EPID signatures by Intel. The Intel Attestation Service (IAS) will reportedly provide support for online attestation verification and thus for revocation. Conveniently, clients use the IAS when checking the attestation $\sigatt$, so no modification to \tc is required to support the service.


\item{\em SLAs.} Were \tc to be deployed as a fee-for-service system, requesters might wish to see Service Level Agreements (SLAs) enforced. A temporary outage on a \tc host or a malicious \medname could cause a delay in datagram delivery, potentially with aftereffects in relying contracts. An SLA could be implemented as an indemnity paid to a contract if a datagram is not delivered within a specified period of time. This feature could itself be implemented, for example, as an entry point in $\tcont$. (Naturally care would be required to ensure that $\tcont$ holds funds sufficient for payout in the case of a general delivery failure.)

\item{\em Hedging against SGX compromise.} We discussed in Section~\ref{subsec:enhanced_robustness} and demonstrated in Section~\ref{subsec:hedging} how \tc can support majority voting across SGX hosts and/or data sources to hedge against failures in either (outside \tc's basic security model) via majority voting. It would be possible to reduce the latency and gas costs of such voting with design enhancements to \tc. Specifically, for the case of SGX voting, we plan to investigate a scheme in which consensus on a datagram value $X$ is reached off-chain among SGX-enable \tc hosts  via Byzantine consensus. These hosts may then use a threshold digital signature scheme to sign the datagram response from ${\cal W}_{TC}$. To ensure that the response is delivered to the blockchain, each participating host can monitor the blockchain and itself transmit the response in the case of an observed delivery failure. This approach will largely eliminate the incremental gas cost of majority voting across SGX instances.

\end{itemize}

\subsection{Expanding \tc functionality}

\begin{itemize}
\item{\em New opcodes.} Ethereum's developers~\cite{Buterinpersonal} have indicated an intention to expand the range of supported cryptographic primitives in Ethereum and stated that they are amenable to the authors' suggestion of incorporating opcodes supporting Intel's EPID in particular, which would enable efficient attestation verification within the blockchain. 
\item{\em Migration to data-source feeds.} Ultimately, we envision that data sources may wish themselves to serve as authenticated data feeds. To do so, they could simply stand up \tc as a front end. As a first step along this path, however, an independent \tc service might provide support for XML-labelled data from data sources, enabling more accurate and direct scraping and intentional identification of what data should be served. We plan to build support for such explicit data labeling into \tc should this approach prove attractive to data sources.
\item{\em Generalized custom datagrams.} In our example smart contract {\sf SteamTrade}, we demonstrated a custom datagram that is essentially hardwired: It employs a user's credentials to scrape her individual online account. A more general approach would be to allow contract owners to specify their own generalized functionalities--scrapers and/or confidential contract modules---as general purpose code, achieving a data-source-enriched emulation of private contracts as in Hawk~\cite{hawk}, but with much lower resource requirements. Furnishing large custom datagrams on the blockchain would be prohibitively expensive, but off-chain loading of code would be quite feasible. Of course, many security and confidentiality considerations arise in a system that allows users to deploy arbitrary code, giving rise to programming language challenges that deployment of this feature in \tc would need to address.
\end{itemize}


