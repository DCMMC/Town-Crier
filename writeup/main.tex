\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix,epsfig,endnotes}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tabularx}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}

\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}

\newcommand{\kyle}[1]{\textcolor{blue}{[[\textsf{Kyle:  #1}]]}}
\newcommand{\fan}[1]{\textcolor{red}{[\textsf{Fan:  #1}]}}
\definecolor{darkgreen}{rgb}{0,0.6,0}
\newcommand{\ari}[1]{\textcolor{darkgreen}{[\textsf{Ari:  #1}]}}
\definecolor{purple}{rgb}{0.75,0,1}
\newcommand{\ethan}[1]{\textcolor{purple}{[\textsf{Ethan: #1}]}}

\newtheorem{lemma}{Lemma}

%don't want date printed
\date{}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Town Crier}

%for single author (just remove % characters)
\author{
{\rm Your N.\ Here}\\
Your Institution
\and
{\rm Second Name}\\
Second Institution
\and
{\rm Name}\\
Name Institution
} % end author


\begin{document}
\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
% \thispagestyle{empty}

\subsection*{Abstract}
Smart contracts are programs that execute autonomously on blockchains. Many of their envisioned uses (e.g., as financial instruments) require them to consume data (e.g., equity prices) from outside the blockchain. Trustworthy data feeds that can interface with smart contracts will thus be a critical component of any smart-contract ecosystem, but are scarcely available today.

	We present an authenticated data feed system called Town Crier (TC). TC builds on the observation that many web sites, such as major news and finance sites, already serve as trusted data sources for non-blockchain uses. TC acts as a bridge between such servers and smart contract systems, using trusted hardware to authenticate and scrape data from HTTPS-enabled websites. 
	
	TC delivers authenticated, timestamped datagrams to relying smart contracts. It also includes a range of advanced features, such as private datagrams, which are produced by evaluating encrypted, contract-supplied predicates within TC's hardware.
	
	%, support for a rich array of trust models on data sources, including options to combine data from multiple sources, and a feature (``deniable datagrams'') for preventing freeloaders from recycling datagrams in a fee-for-service version of TC.
	
	We describe the TC architecture, its underlying trust model, and its applications, and report on an implementation that uses the newly released SGX software development kit. We will soon launch TC as an online public service.
	
\section{Introduction}

\section{Background}
\subsection{SGX}
\subsection{HTTPS}
\subsection{Smart contracts}
\subsection{Applications of ADFs for smart contracts}

\section{Architectural Overview: Basic TC System}
\subsection{Client API}
\subsection{TC server}
\subsubsection{Trusted executable}
\subsubsection{Untrusted executable}
\subsection{TC Blockchain resources}
These include the TC contract and the addresses from which it sends messages and manages its wallet

\section{Security Model}

\section{Applications and Example}

Give flight insurance as running example

\begin{itemize}
\item micro-insurance:
    \begin{itemize}
    \item weather
    \item item delivery
    \item flight delay (note: something we could implement easily ourselves...)
    \end{itemize}
\item Microloans: Establish reputation as collateral by associating loan with Facebook page or Keybase.io or other identity service
\item Ethereum and USD exchange
\item stock price
\item BTC exchange (with and without ADF)
\item Simple derivatives
\item sports betting
\end{itemize}

\section{Architectural Details}
\subsection{Trusted Executable}
\subsection{TC smart contract}
\subsubsection{Ensuring against gas depletion}

\section{Applications}

\section{Custom and Private Datagrams}

Discuss flight insurance as an example: We'd like to conceal the flight number and date. We might also want to conceal payment, so TC might ingest encrypted addresses and mix them internally.


\section{Future Features}
\subsection{Full-blockchain scraping}
As a means of reducing communication costs...
\subsection{Use of new opcodes}
New opcodes would enable processing of fresh attestation
\subsection{Protecting against freeloading}
\subsection{Principled data extraction}
Ultimately, we servers might themselves to act as ADFs. Possible migration path: (1) Town Crier; (2) XML labels on data; (3) Integration of Town Crier features into source directly
\subsection{Off-chain communication}
Mention use of Lamport signatures, etc.

\section{Conclusion}
	
\pagebreak
\appendix 

OLD MATERIAL

\section{Introduction}

\section{Identifying Client Contracts}
The Authenticated Data Feed (ADF) needs some method to identify and serve prospective clients.  There are two on-chain methods: registration and client flags.  The registration method requires an additional transaction and will therefore incur an additional fee.  The flags method must scan all contracts at every block update to support dynamic data requests.  It may therefore be useful to support both methods, using the blockchain crawler for one-time requests and registration for more complicated contracts, depending on the resource costs of the crawler.
\subsection{Registration / Explicit Requests for Data}
	This requires the client to initiate communication to the ADF with a \emph{Initial Client Request} message, which consists of a (potentially zero-value) transaction to the ADF address with a message specifying what signed data it wants. 
	
\subsection{Client Flags / ADF Blockchain Crawler}
	This method requires only that the client contract has in its key/value store a flag indicating its request for service from the ADF and the specifics of the data it wants.  The ADF can then crawl the blockchain looking for contracts with this specific flag set and read the data requested.
	
\subsection{Off Chain Communication}
	The ADF may be notified of prospective clients by any manner of off-chain communication however there will be no public record of this request.  The ADF may then selectively deny service.  Malicious clients may also have an easier time flooding the ADF with requests, compared to the other two methods which have an Ether cost (contract creation).\\

\subsection{Migration Path}

Ultimately, we expect sources themselves to act as ADFs. The migration path is : (1) Town Crier; (2) XML labels on data; (3) Integration of Town Crier features into source directly

\section{Payment Methods}	
\subsection{Separate Fair Exchange Contracts}
    The ADF or the client contract creates or uses an existing \emph{fair exchange contract} for each data request.  This contract requires input from the client in the form of some amount of Ether (this can happen during the creation of the contract), and the signed data from the ADF.  Once both inputs have been received, the contract sends the Ether to the ADF and the data to the client. Note the client should send the currency first as once the ADF publishes the signed data it will be publicly visible (unless we use zero-knowledge proofs). If the ADF fails to deliver the data within a time period then the client's money is refunded.\\
    \indent The main benefit of this method is that the fair exchange contract should be easier to verify for both parties.  Depending on the specifics of the attestation it needs to check, it may be possible for the contracts to be completely templated.  Also note that creating a new contract will incur a transaction fee.  These data fair exchange contracts can potentially batch data requests and verification and can be re-used for subsequent requests if desired. \fan{the client and the ADF should agree on the content of this contract. In my mind this template could be provided by an ADF service provider along with other information on their website. For example, clients can browse ADF's website for pricing info, the public address, an template for generating request and ensuring fair exchange and the public key. Then clients can embed these information in there own contract.}\\
    \kyle{This is my thought as well.  A client may extract the address, pricing info, and a code template for fair exchange from the ADF website.  The issue I was trying to get at was that verifying the bytecode of one function in a contract may be more difficult than simply verifying an entire contract's bytecode due to having to isolate the function.  I don't know whether isolating a function is hard or if the bytecode may change depending on the client contract (offsets, compilers, etc), but at the very least it involves the extra step of checking the function entry point in addition to simply matching the hash of the bytecode}
    
\subsection{Payment Built-in to the Client Contract}
    The client contract includes a function that accepts signed data and pays out the specified amount of coins to the sender if the data is correct.  This requires the ADF to verify the correctness of the function and that the client has sufficient funds.  It would be potentially useful for this function to be templated for ease of use and verification, and at the very least it needs to conform to some specification agreed upon by the client and ADF. 
    
\subsection{Payment built-in to the ADF}
    The client may send payment directly to an ADF contract as part of its initial request.  The ADF contract code must maintain a list of clients and their corresponding requests.  It must also verify the attestation on the data before forwarding it to the client since it has already been paid.  The client must verify that the ADF contract code is correct.
    
\fan{Do all of 9 combinations of (2.1, 2.2, 2.3) and (3.1, 3.2, 3.3) make sense? Or we should point out the best combinations?}
\kyle{All combinations make sense to me with the exception of client flags and payment built-in to the ADF (2.2, 3.3)}
    
\section{Privacy}
Everything posted to the blockchain is publicly visible, including all data requests directed towards the ADF.  It is possible to encrypt data requests, as the ADF may decrypt and process them off-chain.  It is not always possible to encrypt the responses, as the contract requesting the data will often need to process the data.

\subsection{Privacy From Peers}
    In some cases clients may want to keep their requests for data private.  For example a client requesting information about the weather may need to provide his zip code for accurate local results.  However he may not wish for his zip code to be publicly visible.  To solve this, he may encrypt his zip code (or his entire request) with the ADF's public key before posting it to the blockchain.  Note that all encryption and decryption operations can be done off-chain to avoid incurring excessive gas fees.\\

\subsection{Partial Privacy From ADFs}
    Clients may also wish to keep some information private from the ADF.  Consider again a client requesting information about the weather who wishes to keep his zip code private not only from the public, but from the ADF as well.  This can be accomplished by utilizing two ADFs $A_1$ and $A_2$.  The client creates $n-1$ randomized decoy requests for data along with his actual request.  He orders these requests such that his actual request appears at a randomly chosen index $i$.  He then encrypts all requests under the public key of $A_1$ and submits all $n$ encryptions in order to $A_1$.  He encrypts $i$ under the public key of $A_2$ and submits the encryption to $A_2$.  $A_1$ decrypts and computes the results for all $n$ queries and submits the results to $A_2$.  $A_2$ returns to the client the $i$th result.  So long as the two ADFs do not collude (in the context of the weather example, this means neither ADF can know both the zip codes and the index $i$), $A_1$ can only guess the clients true data with probability $\frac{1}{n}$.  \kyle{There is definitely some leakage here if the response returned by $A_2$ is in plaintext} 
    
    
    \kyle{The issue is that the information has to appear in plaintext somewhere on the blockchain in order for a contract to use it, otherwise $A_2$ could simply encrypt the response under the public key of the client.  We could obfuscate the result with a mask, but the client contract will still need to unmask the data to use it, and when it does anyone can read it.  Then in our example $A_1$ knows what the weather was at the clients zipcode and may cross reference with the zipcodes he was given}
    \ari{As regards leakage, that's right. If the output of the contract depends on the zip code, information will leak}
    \ari{Remember the compression trick as well. Let $G$ be an additive group over 5-decimal-digit numbers. Let $PRF_k: \{0,1\}^{*} \rightarrow G$ be a PRF. To send a correct zip code $z$ in list of $n$ zip codes, of which $n-1$ are ``decoys'', the client selects a key $k$ and index $i \in [1,n]$ at random. The client sends $(k,p = PRF_k[i] - z)$. The ADF decodes the list as $\{PRF_k[1] - p, \ldots, PRF_k[n]  - p\}$.}

\subsection{Fully Private Requests}
    If a client wishes to keep the entirety of the request private, he may do so by leveraging the ADF's trusted hardware.  The initial request is encrypted under a public key stored in the trusted hardware, which processes the request.  A malicious ADF operator may only determine the sources which are contacted as a result of the request, and if necessary these can be masked with decoy queries as well.

\subsection{Decoy Requests}
Decoy requests for partially private protocols should be in the same class as the real request.  In the weather example, all zipcodes provided as decoy requests should be experiencing the same weather as in the actual request.  As the outcome of the contract is public, the ADF will be able to determine the value of the weather at the client's zipcode and can discount all decoys that do not match.\\\\
If the class of decoy requests can be pseudorandomly generated, we can save data transmission fees by sending only a random function, a seed, and a mask to ensure that the real request is computed.

\section{Example: Travel Insurance}
An insurance company may provide insurance for canceled flights by maintaining an Ethereum contract on the blockchain.  The source code of this contract should be public to allow potential customers to verify its correctness.  A customer may then purchase insurance by paying a predetermined amount of ether into the contract.  In addition, this transaction should include identifying information (flight number) for the flight for which the customer wishes to be insured.  However, the customer may wish to hide the flight number in order to avoid publicly revealing which flight he/she will be on.  To achieve this, the customer may encrypt the flight number under a public key whose corresponding private key is stored only in the ADF's trusted hardware.  Thus only enclave code will be able to view the unencrypted flight number, preventing even a malicious ADF or data center operator from compromising privacy. Once the ADF is made aware of the requests (as detailed in section 2), it proceeds by decrypting the flight number and determining whether or not the relevant flight was canceled. It strips all identifying information from response, and returns either ``Canceled'' or ``Not canceled.''  

\section{Applications}


\begin{itemize}
\item micro-insurance:
    \begin{itemize}
    \item weather
    \item item delivery
    \item flight delay (note: something we could implement easily ourselves...)
    \end{itemize}
\item Ethereum and USD exchange
\item stock price
\item BTC exchange (with and without ADF)
\item Simple derivatives
\item sports betting
\end{itemize}







\section{Version 0}

Here we define version 0 of the Town Crier protocol.
In order to simplify the implementation, we support only direct client requests for data which include payment to the ADF contract.

For notational simplicity, we use four functions to access storage on the blockchain.
They functions create a map from integers to arbitrary data values in the domain $V$.
\begin{itemize}
  \item {${\sf store} : \mathbb{N} \times V \to \emptyset$.}
    This stores a key with an associated value in the map and returns nothing.

  \item {${\sf load} : \mathbb{N} \to V \cup \{\bot\}$.}
    This returns the value associated with the given key or $\bot$ if the key is not in the map.

  \item {${\sf storeContains} : \mathbb{N} \to \{0, 1\}$.}
    This returns whether or not the key exists in the map.

  \item {${\sf remove} : \mathbb{N} \to \emptyset$.}
    This removes the key and its associated value if it is in the map and otherwise does nothing.
\end{itemize}
The following values are considered constants and can be hard-coded into the contract.
For this we assume a fixed exchange rate between gas and ether, as that is the case in practice at this time.
\begin{itemize}
  \item $\mathcal{P}_{\rm SGX}$: An identity whose private key is controlled by the SGX enclave with a public attestation to that ownership.

  \item $F_{\rm min}$: The minimum fee. The amount of ether necessary to cover the gas costs to execute Deliver, not including the execution of ${\sf callback}$ (as defined below).

  \item $F_{\rm max}$: The maximum fee. The maximum amount of ether Town Crier is capable of sending as gas to a single execution of Deliver.
\end{itemize}
Using the above defined functions and values, we define the version 0 contract's behavior in Table~\ref{0:defn}.

\begin{table}
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{Contract $\large {\sf TownCrier}(\mathcal{P}_{\rm SGX})$} \\ [1ex]
  {\bf Init:} & Set ${\sf reqs} := \emptyset$ and ${\sf reqCnt := 0}$ \\
  {\bf Request:} & Upon receiving $({\sf type}, {\sf callback}, \${\sf fee})$ from a user $\mathcal{P}$: \\
                 & If $(\${\sf fee} < F_{\rm min}$ or $\${\sf fee} > F_{\rm max})$ \\
                 & \hspace*{1em} Return with no effect. \\
                 & Set ${\sf reqID} := {\sf reqCnt}$. \\
                 & Set ${\sf reqCnt} := {\sf reqCnt} + 1$. \\
                 & ${\sf store}({\sf reqID} \mapsto ({\sf callback}, \${\sf fee}))$. \\
                 & Return ${\sf reqID}$. \\
  {\bf Deliver:} & Upon receiving $({\sf reqID}, {\sf data})$ from a user $\mathcal{P}$: \\
                 & If $(\mathcal{P} \neq \mathcal{P}_{\rm SGX}$ or $!{\sf storeContains}({\sf reqID}))$ \\
                 & \hspace*{1em} Return with no effect. \\
                 & $({\sf callback}, \${\sf fee}) \leftarrow {\sf load}({\sf reqID})$. \\
                 & Call ${\sf callback}({\sf data})$ providing $\${\sf fee} - F_{\rm min}$ ether as the maximum gas. \\
                 & Send $\${\sf fee}$ ether to $\mathcal{P}_{\rm SGX}$. \\
                 & ${\sf remove}({\sf reqID})$. \\

  \hline
\end{tabularx}
\caption{Definition of the {\sf TownCrier} contract.}
\label{0:defn}
\end{table}

\subsection{Security Guarantees}

To prove meaningful security guarantees of version 0, we make three trust assumptions.
\begin{enumerate}
  \item \label{0:sec:sgx}
    {\it SGX is Trusted.}
    We must assume that computation which occurs inside the SGX enclave is trusted.
    Assuming the code is bug-free, this is largely the reason to use an SGX enclave and is thus reasonable.

  \item \label{0:sec:untrusted-tc}
    {\it Town Crier server is correct.}
    We must also assume that computation done on the Town Crier server but outside the SGX enclave is correct.
    This is a much stronger assumption as this system is much easier to compromise than an SGX enclave.
    We will later discuss how to maintain lesser guarantees without this assumption.
    In practice, this assumption is reasonable as this server will be running on hardware controlled by the Town Crier operators.

  \item \label{0:sec:network}
    {\it Network requests can be delayed arbitrarily but not dropped or modified.}
    The network must not be completely adversarial and must be reliable, even if slow.
    We will later discuss how to maintain lesser guarantees if the network can drop or modify traffic.
\end{enumerate}
Under these assumptions, we will prove that, for every request that provides a sufficient fee,
a valid authenticated datagram will be delivered to the requested callback location.
If the requests includes an insufficient fee, the datagram will not be delivered but the (too-small) fee will still be collected.
Moreover, if Property~\ref{0:sec:untrusted-tc} is removed, then clients can detect any attack more damaging that denial of service.

\ethan{I'm really not sure where we're going to lay out the behavior of the code running on the Town Crier server (both inside and outside the enclave).
  For right now, I'm going to put the high-level assumptions I need for the proof sketch here.}

Part of assuming correct operation of the Town Crier server involves specifying what that operation entails.
In particular, we will assume the following behavior of the insecure server code:
\begin{itemize}
  \item It properly forwards all network requests to/from the SGX enclave.
  \item It properly scrapes the ${\sf TownCrier}$ contract on the blockchain for new requests and forwards those requests with the appropriate data type to the SGX enclave.
  \item It does not create bogus requests for the SGX enclave to fulfill.
\end{itemize}
Next, we make the following assumptions about the SGX enclave behavior:
\begin{itemize}
  \item It never initiates any blockchain operations other than calling the ${\sf TownCrier}$ contract's Deliver method from $\mathcal{P}_{\rm SGX}$.
  \item It never attempts to fulfill the same request ID multiple times.
  \item It attempts to fulfill every request it receives.
  \item All delivered responses are of the correct data type.
\end{itemize}

\begin{lemma} \label{0:non-bankrupt-adf}
If seeded with at least $F_{\rm max}$ ether, the $\mathcal{P}_{\rm SGX}$ wallet will have
at least as much money after each transaction as it had before that transaction.
\end{lemma}

\begin{proof}
\ethan{This is actually a proof sketch, I just put it in a proof tag.}

Because all blockchain transactions from $\mathcal{P}_{\rm SGX}$ must be initiated by the SGX and the SGX only calls ${\sf TownCrier}.{\rm Deliver}$,
we need only reason about what happens inside that function.
Since the SGX is never given bogus requests and never fulfills the same request twice,
the delivered ${\sf reqID}$ will always be present in the persistent map.
In this case, if the execution succeeds, the SGX wallet always receives the $\${\sf fee}$ value that was saved as being submitted with the request.
Therefore it suffices to show that:
\begin{enumerate}
  \item The contract always has at least $\${\sf fee}$ available at the time Deliver is called.
  \item $\${\sf fee}$ is never lower than the amount $\mathcal{P}_{\rm SGX}$ must spend in gas.
  \item The execution of Deliver will never run out of gas (and thus always succeed).
\end{enumerate}

To prove 1 we note that whenever a new request ID is added to the map, a fee is payed with it and that is precisely the value saved.
Because the ID is removed after Deliver is called and Deliver is the only method that transfers money out of the ${\sf TownCrier}$ contract,
that money must still be in the contract for Deliver to transfer.

To prove 2 we examine two specified bounds.
First, $F_{\rm min}$ is defined so that it is high enough to cover gas costs for all of Deliver except the execution of the provided ${\sf callback}$.
However, ${\sf callback}$ is only given $\${\sf fee} - F_{\rm min}$ gas to execute.
Therefore it is impossible for the entire call of Deliver to spend more than $F_{\rm min} + (\${\sf fee} - F_{\rm min}) = \${\sf fee}$ ether on gas.

To prove 3 we note that $\${\sf fee} \leq F_{\rm max}$ and, by construction, $\mathcal{P}_{\rm SGX}$ will always provide at least
$F_{\rm max}$ in gas for the execution of Deliver.
Therefore we have that $\mathcal{P}_{\rm SGX}$ will always provide at least $\${\sf fee}$ in gas to execute Deliver.
By the argument above, Deliver can never use more than $\${\sf fee}$ in gas, so therefore an SGX-initialized call to Deliver will never run out of gas.
\end{proof}

Due to Lemma~\ref{0:non-bankrupt-adf}, the SGX will always have the funds to deliver a valid request.
A datagram will always be delivered in finite time because the network can only delay traffic, not drop or change it,
so a valid request will always eventually get to the SGX enclave and its response will always eventually get back to the blockchain.
The delivered datagram will be authenticated because the SGX enclave is the sole owner of the private key associated with $\mathcal{P}_{\rm SGX}$ (and there is an off-chain attestation to that).
Therefore, any message received from that address must have come from the SGX enclave, which means it is considered authentic.
Because Deliver only accepts deliveries from $\mathcal{P}_{\rm SGX}$, all deliveries are authenticated.




\section{Version 1}

\ethan{I feel like version 1 might include other payment methods. Maybe this is version 0.5?}

While this paper does not implement and test version 1, we do discuss improvements and the guarantees those might provide.
The guarantees provided for version 0 still hold under the assumptions made by version 0, but we are able to make stronger statements when we loosen the assumptions.


\subsection{Request Cancellation}

In order to provide recourse if the system is compromised and disabled or datagrams are delayed beyond a reasonable time,
there can be a way to cancel requests for a refund.
The refund must withhold a fixed fee of $F_{\rm min}$ in order to ensure that malicious aborts cannot bankrupt the ADF, but the rest of the fee can be refunded at any time.
If the ADF attempts to deliver a datagram for a cancelled request, it will simply receive the $F_{\rm min}$ needed to cover its gas costs for the attempted delivery and not deliver any data.

This mechanism coupled with the fact that the blockchain is self-validating allows us to handle arbitrary network adversaries in a reasonable fashion.
However, we are still relying on the honesty of the non-enclave computation executed by the Town Crier server.
If that code become corrupted, then it can send bogus request IDs to the enclave which will then attempt to respond and steal $F_{\rm min}$ gas from the contract.
This could not only run $\mathcal{P}_{\rm SGX}$ out of money, but also drain the contract of funds, thereby preventing legitimate users from acquiring refunds.

By adding a set of cancelled requests that have not been delivered, we can reduce the scope of the attack to only the $\mathcal{P}_{\rm SGX}$ wallet.
In this case, the SGX wallet could still be exhausted by adversarial untrusted Town Crier code, however it would be unable to drain funds from the contract itself.
This means that, while the SGX would be unable to deliver datagrams, users would still be able to receive cancellation refunds.


\subsection{Service-level Agreements}

We start by noting that a service-level agreement (SLA) is generally implemented by paying recompense if it is violated.
This seems extreme if the service is not run for a profit, so thus we will assume that the costs of any SLA payments are funded by profits gained when the SLA is not violated.
For Town Crier, these profits can be implemented by simply increasing $F_{\rm min}$ above the gas cost necessary to run Deliver.
In this case, the extra money will be profit.
Note that if this happens, the cancellation fee could remain simply enough to recoup gas costs and not include the profit.

In this system, and SLA could consist of a maximum amount of time before a datagram is delivered.
If the user wishes to cancel a request before that time, it would be considered a voluntary cancellation and incur a cancellation fee high enough to cover gas costs of an attempted delivery.
If, however, the SLA has expired before the request is cancelled, then not only would a cancellation not incur a fee, the user would be returned their entire initial fee and an SLA-violation recompense.
This could be a small value that would be need to later be paid back by Town Crier system out of the profits from successfully-deliver requests in order to prevent the contract from going bankrupt.

This mechanism presents some danger if a large number of SLAs are violated at the same time and the Town Crier system is unable to provide enough funds to the contract to make all of the recompense payments.
In this case, there could be a lightweight function on the contract to inform a user whether or not there is sufficient funding to make an SLA payment.
This function could either before cancellation requests or it could be before a request is made.
The former case would attempt to guarantee that a cancellation request right now would include an SLA payment.
The latter would attempt to ensure that a new request would always have money set aside to pay for an SLA violation.
Both of these utility functions may be subject to a race condition of another user making a cancellation or new request between the utility call on the actual call, thus costing an honest user money.







\section{Kyle's tasks for week of 7 Dec.}
\begin{enumerate}
\item specifications for end-to-end private requests (microtransactions, travel insurance)\\
-hiding in a crowd, same class of decoy queries\\
-encrypt queries and offchain computation \\
-consider information leaked from which party gets paid
\item webcrawler
\item Explain choice of subscription model, design considerations; discuss possible entry-point templates
\item Think about IoT applications of ADFs
\end{enumerate}

\section{Fan's tasks for week of 7 Dec.}
\begin{itemize}
\item Look into trusted time source 1) based on PCH clock or 2) TLS timeout+connection to trustworthy time source
\item TCB for ADF
\item Test OpenSGX
\begin{itemize}
\item Check cert for TLS connection
\item Extract data from target
\item Handle encrypted queries and encrypted replies
\item Think about IoT applications of ADFs
\end{itemize}
\end{itemize}

\end{document}
