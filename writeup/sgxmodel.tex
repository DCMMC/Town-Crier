
\newcommand{\ucstring}[1]{{\color{black} #1}}

\section{More Details on Formal Modeling} 
\subsection{SGX Formal Modeling}
\label{sec:sgxmodel}


As mentioned earlier, we adopt the 
UC model of SGX proposed by Shi et al.~\cite{sgxsok}
In particular, their 
abstraction captures a subset of the features 
of Intel SGX. 
%The model follows the UC and GUC paradigm~\cite{uc,guc,juc}.
%In this paper, we use the same formal abstraction
%to model SGX (see Figure~\ref{fig:fsgx}).
%\elaine{explain more here, we can think of fsgx as a trusted third party.}
The main idea behind the UC modeling by Shi et al.~\cite{sgxsok}
is to think of SGX 
as a trusted third party defined by 
a global functionality $\fsgx$ (see Figure~\ref{fig:fsgx} of 
Section~\ref{sec:useofsgx}).
%In this paper, the SGX features we need include the following:

\paragraph{Modeling choices.}
For simplicity, the $\fsgx$ model currently does not 
capture the issue of revocation.
In this case, as Shi et al.~point out, 
we can model SGX's group signature
simply as a regular signature scheme $\sigsgx$, whose
public and secret keys 
are called ``manufacturer keys'' and denoted $\pkM$ and $\skM$ 
(i.e., think of always signing 
with the 0-th key of the group signature scheme).
We adopt this notational choice from~\cite{sgxsok} %\elaine{cite} 
for simplicity. Later when 
we need to take revocation into account,
it is always possible to replace this signature 
scheme with a group signature scheme in the modeling.

The $\fsgx(\sigsgx)$ functionality described by Shi et al.~\cite{sgxsok} %\elaine{cite}
is a global functionality shared by all protocols, parametrized
by a signature scheme $\sigsgx$.
This global \fsgx 
is meant to capture all SGX machines available in the world,
and keeps track of 
multiple execution contexts
for multiple enclave programs, happening on different SGX machines in the world.
For convenience, 
this paper adopts a new notation
%In Figure~\ref{fig:fsgx}
$\fsgx(\sigsgx)[\enclaveprog, \relay]$
to denote 
one specific execution context of the global \fsgx
functionality where the enclave program in question is $\enclaveprog$,
and the specific SGX instance is attached to a physical machine $\relay$.
(As the $\medname$ in \tc describes all functionality outside the enclave, we use $\relay$ for convenience also to denote the physical host.)
This specific context 
$\fsgx(\sigsgx)[\enclaveprog, \relay]$
ignores all parties' inputs except those coming from $\relay$.
We often omit writing $(\sigsgx)$ without risk of ambiguity.


\paragraph{Operations.}
$\fsgx$ captures the following features:
\begin{itemize}[leftmargin=5mm]
\item
{\it Initialize.}
Initialization is run only once.
Upon receiving \texttt{init}, $\fsgx$
runs the initialization part of the enclave program
denoted ${\sf outp} := \enclaveprog.{\bf Initialize}()$.
Then, $\fsgx$ 
attests to the code of the enclave program $\enclaveprog$ 
%in Figure~\ref{fig:fsgx}
as well as ${\sf outp}$.
The resulting attestation is denoted 
$\sigatt$.
\item
{\it Resume.}
When \texttt{resume} is received,
\fsgx 
calls $\enclaveprog.{\bf Resume}$
on the input parameters denoted ${\sf params}$.
$\fsgx$ 
outputs whatever $\enclaveprog.{\bf Resume}$ outputs.
\fsgx is stateful, i.e., allowed to carry state
between \texttt{init} and multiple \texttt{resume}
invocations.
\end{itemize}

Finally, we remark that this formal model by Shi et al.
is speculative,   
%Although Shi et al. propose
%a likely \fsgx abstraction, 
since we know of no formal
proof that Intel's SGX does securely realize this abstraction (or 
realize any useful formal
abstraction at all for that matter)---in fact, available public documentation of SGX
does not provide sufficient information for making such formal proofs. 
As such, the formal model in~\cite{sgxsok}  
appears to be the best available tool for us to 
formally reason about 
security 
for SGX-based protocols. 
Shi et al. leave it as an open question to design secure processors
with clear formal specifications, such that 
they can be used in the design of larger protocols/systems 
supporting formal reasoning of security.
We refer the readers to~\cite{sgxsok} 
for a more detailed description of the UC modeling of Intel SGX.


\subsection{Blockchain Formal Modeling}
\label{sec:blockchainmodel}

Our protocol notation adopts the formal blockchain
framework recently proposed by Kosba et al.~\cite{hawk}.
In addition to UC modeling of blockchain-based protocols, 
Kosba et al.~\cite{hawk} also 
design a modular notational system  
that is intuitive and factors out tedious but common   
features inside functionality and protocol wrappers (e.g.,
modeling of time, pseudonyms, adversarial reordering of messages, 
a global ledger).
The advantages of 
adopting Kosba et al.'s notational system are these:
the 
blockchain contracts and user-side protocols
are intuitive on their own and
they are endowed with precise, formal meaning
when  we apply the blockchain wrappers.

\newcommand{\Ttimeout}{\ensuremath{{\sf T}_{\text{timeout}}}\xspace}

\paragraph{Technical subtleties.}
While Kosba et al.'s formal blockchain model is applicable for the most part,
we point out a subtle mismatch
between their formal blockchain model in~\cite{hawk} and
the real-world instantiation of blockchains such as 
Ethereum (and Bitcoin for that matter).
The design of Town Crier is secure in a slightly modified
version of the blockchain model that more accurately reflects
the real-world Ethereum instantiation of a blockchain.
%captures 
%this technical subtlety.

%One technical subtlety we 
%address in this paper arises from a slight mismatch
%between the formal model by Kosba et al. 
%and the real Ethereum instantiation.
%An interesting technical subtlety
%arises due to the 
%subtle mismatch
%between the formal blockchain model of 
%Kosba et al.~\cite{hawk} and 
%the real-world instantiation of blockchains such as Ethereum (and Bitcoin). 

Recall that one tricky detail for the gas-aware version of the Town Crier 
contract arises from the need to deal with  
with {\bf Deliver}
arriving after {\bf Cancel}.
In the formal blockchain model
proposed by Kosba et al.~\cite{hawk}, we can easily get away with this issue 
by introducing 
a timeout parameter
$\Ttimeout$ that the requester attaches to each datagram request. 
If the datagram fails to arrive before $\Ttimeout$, 
the requester can call {\bf Cancel}
any time after 
$\Ttimeout + \Delta T$.  
On the surface, this 
seems to ensure that no {\bf Deliver} will be invoked
after {\bf Cancel} assuming Town Crier is honest. 

However, we did not adopt this approach due to a technical subtlety
that arises in this context---again, the fact that  
the Ethereum blockchain does not  
perfectly match the formal blockchain 
model specified by Kosba et al~\cite{hawk}.
Specifically, the blockchain model by Kosba et al.
assumes that every message (i.e., transaction) will be delivered 
to the blockchain 
by the end of each epoch and that the adversary cannot drop
any message.
In practice, however, 
Ethereum adopts a dictatorship 
strategy in the mining protocol, and the winning miner 
for an epoch can censor transactions for this specific epoch, and thus
effectively this transaction will be deferred to later epochs.
Further, in case there are more incoming transactions than the block size
capacity of Ethereum, a backlog of transactions will build up, 
and similarly in this case there is also guaranteed
ordering of backlogged transactions.
Due to these considerations, we defensively design our Town Crier contract
such that gas neutrality is attained for Town Crier
even if the {\bf Deliver} transaction arrives after {\bf Cancel}.

%\elaine{in extension, we can support an abstraction
%where the datagram must be delivered by some timeout}






