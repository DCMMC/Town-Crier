%**** COLORS *********
\definecolor{maroon}{RGB}{178, 34, 34}
%\definecolor{brown}{RGB}{139, 137, 137}
\definecolor{gold}{rgb}{0.85, 0.65, 0.13}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0, 0, 0.5}

%\newcommand{\smaroon}[1]{{\ensuremath{\tt {\color{maroon} #1}\xspace}}}
%\newcommand{\sgold}[1]{\ensuremath{\tt {\color{gold} #1 \xspace}}}
%\newcommand{\sbrown}[1]{\ensuremath{\tt {\color{brown} #1 \xspace}}}

%\newcommand{\sgray}[1]{{\color{gray} #1}}

\newcommand{\ucstring}[1]{{\color{black} #1}}

\section{More Details on Formal Modeling} 
\subsection{SGX Formal Modeling}
\label{sec:sgxmodel}


As mentioned earlier, we adopt the 
UC model of SGX proposed by Shi et al.\elaine{cite}
In particular, their 
abstraction captures a subset of the features 
of Intel SGX. 
%The model follows the UC and GUC paradigm~\cite{uc,guc,juc}.
%In this paper, we use the same formal abstraction
%to model SGX (see Figure~\ref{fig:fsgx}).
%\elaine{explain more here, we can think of fsgx as a trusted third party.}
The main idea behind the UC modeling by Shi et al.
\elaine{cite}
is to think of SGX 
as a trusted third party defined by 
a global functionality $\fsgx$ (see Figure~\ref{fig:fsgx} of 
Section~\ref{sec:useofsgx}).
%In this paper, the SGX features we need include the following:

\paragraph{Modeling choices.}
For simplicity, the $\fsgx$ model currently does not 
capture the issue of revocation.
In this case, as Shi et al. point out, 
we can model SGX's group signature
simply as a regular signature scheme $\sigsgx$, whose
public and secret keys 
are called ``manufacturer keys'' and denoted $\pkM$ and $\skM$ 
(i.e., think of always signing 
with the 0-th key of the group signature scheme).
We adopt this notational choice from Shi et al. \elaine{cite} 
for simplicity. Later when 
we need to take revocation into account,
it is always possible to replace this signature 
scheme with a group signature scheme in the modeling.

The $\fsgx(\sigsgx)$ functionality described by Shi et al. \elaine{cite}
is a global functionality shared by all protocols, parametrized
by a signature scheme $\sigsgx$.
This global \fsgx 
is meant to capture all SGX machines available in the world,
and keeps track of 
multiple execution contexts
for multiple enclave programs, happening on different SGX machines in the world.
For convenience, 
this paper adopts a new notation
%In Figure~\ref{fig:fsgx}
$\fsgx(\sigsgx)[\enclaveprog, \relay]$
to denote 
one specific execution context of the global \fsgx
functionality where the enclave program in question is $\enclaveprog$,
and the specific SGX instance is attached to a physical machine $\relay$.
This specific context 
$\fsgx(\sigsgx)[\enclaveprog, \relay]$
ignores all parties' inputs except those coming from $\relay$.
We often omit writing $(\sigsgx)$ without risk of ambiguity.


\paragraph{Operations.}
$\fsgx$ captures the following features:
\begin{itemize}[leftmargin=5mm]
\item
{\it Initialize.}
Initialization is run only once.
Upon initialization, $\fsgx$
runs the initialization part of the enclave program
denoted ${\sf outp} := \enclaveprog.{\bf Initialize}()$.
Then, $\fsgx$ 
attests to the code of the enclave program $\enclaveprog$ 
%in Figure~\ref{fig:fsgx}
as well as ${\sf outp}$.
The resulting attestation is denoted 
$\sigatt$.
\item
{\it Resume.}
When \ucstring{``resume''} is invoked,
\fsgx 
calls $\enclaveprog.{\bf Resume}$
on the input parameters denoted ${\sf params}$.
$\fsgx$ 
outputs whatever $\enclaveprog.{\bf Resume}$ outputs.
\fsgx is stateful, i.e., allowed to carry state
between \ucstring{``initialize''} and multiple \ucstring{``resume''}
invocations.
\end{itemize}

Finally, we remark that this formal model by Shi et al.
is speculative,   
%Although Shi et al. propose
%a likely \fsgx abstraction, 
since we know of no formal
proof that Intel's SGX does securely realize this abstraction (or 
realize any formal
abstraction at all for that matter) --- 
in fact, available public documentations of SGX
does not provide sufficient information for making such formal proofs. 
As such, the formal model by Shi et al. 
appears to be the best available tool for us to 
formally reason about 
security 
for SGX-based protocols. 
Shi et al. leave it as an open question to design secure processors
with clear formal specifications, such that 
they can be used in the design of larger protocols/systems 
supporting formal reasoning of security.
We refer the readers to Shi et al.  \elaine{cite} for a
more detailed description of the UC modeling of Intel SGX.


\subsection{Blockchain Formal Modeling}
\label{sec:blockchainmodel}
