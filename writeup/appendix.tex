\pagebreak
\appendix 

\elaine{I took care of cancellation in the gas-aware version.
So I commented out the cancellation part from the appendix.
The cancellation is necessary to prove the theorem you want to prove
about bounded loss for honest user.}

%\section{Version 1}
%
%Here we define and discuss proposed extensions to the Town Crier protocol.
%
%\subsection{Request Cancellation}
%
%In order to provide recourse if the system is compromised and disabled or datagrams are delayed beyond a reasonable time,
%there can be a way to cancel requests for a refund.
%The refund must withhold a fixed fee of $F_{\rm min}$ in order to ensure that malicious aborts cannot bankrupt the ADF, but the rest of the fee can be refunded at any time.
%If the ADF attempts to deliver a datagram for a canceled request, it will simply receive the $F_{\rm min}$ needed to cover its gas costs for the attempted delivery and not deliver any data.
%
%In order to safely handle request cancellations, we now have to store verification data on the blockchain itself.
%This will be considerably more expensive, but the Ethereum protocol supports it cleanly.
%For notational simplicity, we use four blockchain storage functions.
%They functions create a map from integers to arbitrary data values in the domain $V$.
%\begin{itemize}
%  \item {${\sf store} : \mathbb{N} \times V \to \emptyset$.}
%    This stores a key with an associated value in the map and returns nothing.
%
%  \item {${\sf load} : \mathbb{N} \to V \cup \{\bot\}$.}
%    This returns the value associated with the given key or $\bot$ if the key is not in the map.
%
%  \item {${\sf storeContains} : \mathbb{N} \to \{0, 1\}$.}
%    This returns whether or not the key exists in the map.
%
%  \item {${\sf remove} : \mathbb{N} \to \emptyset$.}
%    This removes the key and its associated value if it is in the map and otherwise does nothing.
%\end{itemize}
%Table~\ref{tbl:Ctc-with-cancellation} describes the new \tcont blockchain.
%The rest of the protocol need to change (save for calls to Deliver requiring slightly different arguments).
%
%\begin{table}[htb]
%\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
%  \hline
%
%  \multicolumn{2}{|c|}{\tcont with Cancellation} \\ [1ex]
%  {\bf Init:} & Set ${\sf reqs} := \emptyset$ and ${\sf reqCnt := 0}$ \\
%  {\bf Request:} & Upon receiving $({\sf type}, {\sf callback}, \${\sf fee})$ from a user $\mathcal{P}$: \\
%                 & If $(\${\sf fee} < F_{\rm min}$ or $\${\sf fee} > F_{\rm max})$ \\
%                 & \hspace*{1em} Return with no effect. \\
%                 & Set ${\sf reqID} := {\sf reqCnt}$. \\
%                 & Set ${\sf reqCnt} := {\sf reqCnt} + 1$. \\
%                 & ${\sf store}({\sf reqID} \mapsto (\mathcal{P}, \${\sf fee}))$. \\
%                 & Return ${\sf reqID}$. \\
%  {\bf Deliver:} & Upon receiving $({\sf reqID}, {\sf data}, {\sf callback})$ from a user $\mathcal{P}$: \\
%                 & If $\mathcal{P} \neq \textrm{\sgxadd}$ \\
%                 & \hspace*{1em} Return with no effect. \\
%                 & If $!{\sf storeContains}({\sf reqID})$ \\
%                 & \hspace*{1em} Send $F_{\rm min}$ to \sgxadd. \\
%                 & \hspace*{1em} Return with no further effect. \\
%                 & $(*, \${\sf fee}) \leftarrow {\sf load}({\sf reqID})$. \\
%                 & Call ${\sf callback}({\sf data})$ providing $\${\sf fee} - F_{\rm min}$ ether as the maximum gas. \\
%                 & Send $\${\sf fee}$ ether to \sgxadd. \\
%                 & ${\sf remove}({\sf reqID})$. \\
%  {\bf Cancel:}  & Upon receiving $({\sf reqID})$ from a user $\mathcal{P}$: \\
%                 & If $!{\sf storeContains}({\sf reqID})$ \\
%                 & \hspace*{1em} Return with no effect. \\
%                 & $(\mathcal{R}, \${\sf fee}) \leftarrow {\sf load}({\sf reqID})$. \\
%                 & If $\mathcal{P} \neq \mathcal{R}$ \\
%                 & \hspace*{1em} Return with no effect. \\
%                 & Send $\${\sf fee} - F_{\rm min}$ to $\mathcal{P}$. \\
%                 & ${\sf remove}({\sf reqID})$. \\
%
%  \hline
%\end{tabularx}
%\caption{Definition of the \tcont contract with cancellation.}
%\label{tbl:Ctc-with-cancellation}
%\end{table}
%
%Using the same adversarial model, we can make the same guarantees of this new system as we did for the original Town Crier system.
%Even if a malicious user cancels their request just as Deliver is being called, the cancellation fee is enough to reimburse \sgxadd for any gas costs.
%
%If we expand the adversarial model to allow for arbitrary denial of service attacks against the Town Crier system (but not the blockchain),
%the new Cancel functionality allows affected users to recover most of their fee with no action from the Town Crier system.
%

\subsection{Service-level Agreements}

We start by noting that a service-level agreement (SLA) is generally implemented by paying recompense if it is violated.
This seems extreme if the service is not run for a profit, so thus we will assume that the costs of any SLA payments are funded by profits gained when the SLA is not violated.
For Town Crier, these profits can be implemented by simply increasing $F_{\rm min}$ above the gas cost necessary to run Deliver.
In this case, the extra money will be profit.
Note that if this happens, the cancellation fee could remain simply enough to recoup gas costs and not include the profit.

In this system, and SLA could consist of a maximum amount of time before a datagram is delivered.
If the user wishes to cancel a request before that time, it would be considered a voluntary cancellation and incur a cancellation fee high enough to cover gas costs of an attempted delivery.
If, however, the SLA has expired before the request is canceled, then not only would a cancellation not incur a fee, the user would be returned their entire initial fee and an SLA-violation recompense.
This could be a small value that would be need to later be paid back by Town Crier system out of the profits from successfully-deliver requests in order to prevent the contract from going bankrupt.

This mechanism presents some danger if a large number of SLAs are violated at the same time and the Town Crier system is unable to provide enough funds to the contract to make all of the recompense payments.
In this case, there could be a lightweight function on the contract to inform a user whether or not there is sufficient funding to make an SLA payment.
This function could either before cancellation requests or it could be before a request is made.
The former case would attempt to guarantee that a cancellation request right now would include an SLA payment.
The latter would attempt to ensure that a new request would always have money set aside to pay for an SLA violation.
Both of these utility functions may be subject to a race condition of another user making a cancellation or new request between the utility call on the actual call, thus costing an honest user money.






