\newcommand{\fsgx}{\ensuremath{\mathcal{F}_{\textrm{sgx}}}}
\newcommand{\pkM}{\ensuremath{{\sf pk}_{\mathcal{M}}}}
\newcommand{\skM}{\ensuremath{{\sf sk}_{\mathcal{M}}}}
\newcommand{\pkU}{\ensuremath{{\sf pk}_{\mathcal{U}}}}
\newcommand{\pksgx}{\ensuremath{{\sf pk}_{\textrm{sgx}}}}
\newcommand{\sksgx}{\ensuremath{{\sf sk}_{\textrm{sgx}}}}
\newcommand{\pkurl}{\ensuremath{{\sf pk}_{\textrm{url}}}}
\newcommand{\rl}{\ensuremath{{\sf RL}}}
\newcommand{\relay}{\ensuremath{\mathcal{R}}}
%\newcommand{\digest}{\ensuremath{{\sf digest}}}
\newcommand{\enclaveprog}{\ensuremath{{\sf prog}_{\textrm{encl}}}}
\newcommand{\sigatt}{\ensuremath{{\sigma_{\textrm{att}}}}}
\newcommand{\sigsgx}{\ensuremath{{\Sigma_{\textrm{sgx}}}}}
\newcommand{\weburl}{\ensuremath{{{\sf url}}}}
\newcommand{\clock}{\ensuremath{{{\sf clock}}}}

\section{Protocol}
\elaine{to be merged into main body}


\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf User: offline attestation of SGX enclave}
\end{center}
\begin{tabular}{l}
{\bf Inputs}: $\pkM$, $\rl$, $\pksgx$, $\enclaveprog$, $\sigatt$ \\[5pt]
{\bf Checks:} \\
Assert $\enclaveprog$ is the expected enclave code\\
Assert $\sigsgx.{\sf Verify}(\pkM, \rl, \sigatt, (\enclaveprog, \pksgx))$ \\
Assert $\Ctc$ is correct and parametrized w/ \pksgx\\
{\it //~now okay to rely on $\Ctc$}
\end{tabular}
\end{boxedminipage}
\caption{A user checks the Town Crier blockchain contract $\Ctc$, 
and verifies an SGX attestation of the enclave's code and its public key $\pksgx$ before 
entering a contract that calls $\Ctc$.
} 
\end{figure}


\begin{figure}
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf Town Crier blockchain contract $\Ctc$}} \\ [1ex]
  {\bf Request:} & On recv $({\sf id}, {\sf callback}, {\sf params})$ from some user $\pkU$: \\
%                 & If $(\${\sf fee} < F_{\rm min}$ or $\${\sf fee} > F_{\rm max})$ \\
%                 & \hspace*{1em} Return $\${\sf fee}$ to $\pkU$ \\
                 & Record $({\sf id}, {\sf callback}, {\sf params})$ \\
  {\bf Deliver:} & On recv $({\sf id}, {\sf data})$ from $\pksgx$: \\
		 & Let $({\sf id}, {\sf callback}, \_)$ be the most recently recorded tuple for ${\sf id}$\\
                 & Call ${\sf callback}({\sf data})$ \\
%                 & Send $\${\sf fee}$ ether to $\Psgx$. \\

  \hline
\end{tabularx}
\caption{
A simple, fee-free version of the Town Crier contract $\Ctc$.
Note that communication 
with $\Ctc$ is through an authenticated channel implemented through digital signatures (which
are not explicitly expressed in our notation).
}
\label{tbl:tc-contract}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's enclave program}
\end{center}
\begin{tabular}{l}
%{\bf Inputs}:  ${\sf params}$, \\[5pt]
{\bf Initialize}:  On receive ``initialize'': \\ %{\it //~called only once upfront}\\
\quad $(\pksgx, \sksgx) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
\quad Record $(\pksgx, \sksgx)$\\
\quad Output $\pksgx$   {\it //~incl. in measurement \& attestation } 
\\[5pt]

{\bf Resume:} On receive ${\sf params} := (\weburl, \pkurl, T) $:\\
%\quad Parse ${\sf params} := (\weburl, \pkurl, T)$ \\
\quad $T_{\textrm{start}} := \clock()$\\
\quad Establish secure channel w/ $\weburl$ w/ public key $\pkurl$ \\
\quad Download the webpage at $\weburl$\\
\quad $T_{\textrm{end}}: = \clock()$\\
\quad Assert ${\sf round}(T_{\textrm{start}}) = {\sf round}(T_{\textrm{end}}) = T$\\
\quad Parse webpage and extract ${\sf data}$\\
\quad $\sigma := \Sigma.{\sf Sign}({\sksgx}, ({\sf params}, {\sf data}))$\\
\quad Output $({\sf data}, \sigma)$
\end{tabular}
\end{boxedminipage}
\caption{
SGX enclave's code.
} 
\end{figure}


\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's untrusted relay $\relay$}
\end{center}
\begin{tabular}{l}
{\bf Initialize}:\\
Send ``initialize'' to $\fsgx[\enclaveprog, \relay]$\\
On receive $(\pksgx, \sigatt)$ from $\fsgx[\enclaveprog, \relay]$:\\
\quad Publish $(\pksgx, \sigatt)$\\[5pt]

{\bf  Loop forever}: \\
When $\Ctc$ receives new request $({\sf id}, \_, {\sf params})$:\\
\quad Parse ${\sf params} := (\weburl, \pkurl, T)$\\
\quad Fork: \\
\quad \quad Wait till time $T$\\
\quad \quad Send $(\text{``resume''}, {\sf params})$ to the $\fsgx[\enclaveprog, \relay]$ \\
\quad \quad On receive $({\sf data}, \sigma)$ from $\fsgx[\enclaveprog, \relay]$:\\ 
\quad \quad \quad  {\sf AuthSend} $({\sf id}, {\sf data})$ to $\Ctc$
\end{tabular}
\end{boxedminipage}
\caption{Town Crier untrusted relay. For simplicity, here we assume that there is only 
a single enclave program. When multiple data feed sources 
are supported, 
we need multiple enclaves that instantiate different parsers for different sites.
In this case, the Town Crier relay also initialize all enclave instances
and route the request to the correct enclave instance.}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf $\fsgx[\enclaveprog, \relay]$: abstraction for SGX}
\end{center}
\begin{tabular}{l}
{\bf Assume:} \\ 
$\enclaveprog$ has entry points {\bf Initialize} and {\bf Resume}\\[5pt]

{\bf Initialize:}\\
On receive ``initialize'' from $\relay$: \\
\quad Let ${\sf outp} := \enclaveprog.{\bf Initalize}()$  \\
\quad $\sigatt := \sigsgx.{\sf Sign}(\skM, (\enclaveprog, {\sf outp}))$ \\[-1pt]
\qquad \qquad {\it //~models group sig.}\\
\quad Output  $({\sf outp}, \sigatt)$\\[5pt]

On receive (``resume'', ${\sf params}$) from $\relay$: \\
\quad Let ${\sf outp} := \enclaveprog.{\bf Resume}({\sf params})$  \\
\quad Output ${\sf outp}$ 
\end{tabular}
\end{boxedminipage}
\caption{Formal abstraction for SGX attested execution. 
We adopt a similar modeling approach by Shi et al.
\elaine{cite our sok paper}
The above functionality only models a subset of SGX features
that is sufficient for our formalism.
}
\end{figure}




