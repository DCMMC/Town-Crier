

\section{Basic Protocol}

\subsection{A Gas-Free Basic Protocol}
For simplicity, we first describe a gas-free version of our basic protocol.
This basic protocol improves the strawman solution 
by resolving the aforementioned two issues.

\paragraph{Enclave-specific keys.}
To avoid having to verify a group signature on the blockchain,  
during enclave initialization, 
we have each enclave generate its enclave-specific 
key pair denoted $(\pksgx, \sksgx)$.
The $\sksgx$ is retained within the enclave and used
to sign the datagrams extracted from data sources during the request phase.
Since Ethereum itself 
already verifies signatures on messages sent from users (i.e.,
users interact with the 
Ethereum blockchain through an authenticated channel), 
we devise a trick to {\it piggyback the signature 
verification on top of Ethereum's already existing signature verfication mechanism}.
This means that the SGX enclave must sign datagrams using the \elaine{fill in name}
signature scheme that is compatible with Ethereum's signature verification.
This way, we need not implement a separate signature verification
in the user-defined $\tcont$ contract.
This saves 
not only software engineering effort, but more importantly, gas.

To make this idea fully work, in an offline phase, 
a user must verify an SGX attestation vouching for its own enclave-specific 
public key  $\pksgx$.
This $\pksgx$ is hardcoded inside the blockchain contract $\tcont$. 
The user is responsible for making sure that this hardcoded $\pksgx$ has an 
appropriate SGX attestation before interacting with the $\tcont$ 
blockchain contract.

\paragraph{Instantiating trusted absolute clock.}
Since SGX's trusted clock provides only relative time with 
respect to a reference point, 
we will rely on 
the following mechanism to realize a trusted {\it absolute} clock. 
\begin{itemize}[leftmargin=5mm]
\item
{\bf Offline calibration.}
In an offline phase, a user $U$ performs the following calibration protocol
with the SGX enclave:

\elaine{this formal notation needs to be changed, it is not compatible
with other formal notation.}

\begin{tabular}{rl}
$\mathcal{U}$: & get absolute $T_0$ from a trusted source \\
$\mathcal{U}$: & pick random ${\sf nonce}$\\
$\mathcal{U} \rightarrow \fsgx$: & ${\sf nonce}$\\
$\fsgx \rightarrow \mathcal{U}$: & (${\sf clock\_ref}$, $\Delta T_0$, ${\sf nonce}$)\\
$\mathcal{U}$: & record ${\sf clock\_ref}$, $\Delta T_0$
\end{tabular}

\elaine{the above assumes that 
an authenticated channel has been established.}

\item
{\bf Online trusted absolute clock.}
Whenever $\fsgx$ gives the relative time $\Delta T$ with respect
to ${\sf clock\_ref}$, the user 
{\it i)} checks that ${\sf clock\_ref}$ agrees with the saved
reference point, and 
{\it ii)}
computes $T_0 + \Delta T - \Delta T_0$
as the absolute time.
\end{itemize}


\paragraph{Formal protocol description.}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf User: offline attestation of SGX enclave}
\end{center}
\begin{tabular}{l}
{\bf Inputs}: $\pkM$, $\pksgx$, $\enclaveprog$, $\sigatt$ \\[5pt]
{\bf Checks:} \\
Assert $\enclaveprog$ is the expected enclave code\\
Assert $\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pksgx))$ \\
Assert \tcont is correct and parametrized w/ \pksgx\\
{\it //~now okay to rely on \tcont}
\end{tabular}
\end{boxedminipage}
\caption{A user checks the Town Crier blockchain contract \tcont, 
and verifies an SGX attestation of the enclave's code and its public key $\pksgx$ before 
entering a contract that calls \tcont.
\elaine{here we use a simplified abstraction, but the actual implementation
also involves verifying the revocation list.}
%\elaine{there is a notational mismatch here. here we write RL explicitly, but
%not in the Fsgx abstraction}
} 
\end{figure}


\begin{figure}
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf Town Crier blockchain contract \tcont}} \\ [1ex]
  {\bf Request:} & On recv $({\sf id}, {\sf callback}, {\sf params})$ from some user $\pkU$: \\
%                 & If $(\${\sf fee} < F_{\rm min}$ or $\${\sf fee} > F_{\rm max})$ \\
%                 & \hspace*{1em} Return $\${\sf fee}$ to $\pkU$ \\
                 & Record $({\sf id}, {\sf callback}, {\sf params})$ \\
  {\bf Deliver:} & On recv $({\sf id}, {\sf params}, {\sf data})$ from $\pksgx$: \\
		 & Let $({\sf id}, {\sf callback}, {\sf params'})$ be the most recently recorded tuple for ${\sf id}$\\
		 & Assert ${\sf params} = {\sf params}'$\\
                 & Call ${\sf callback}({\sf data})$ \\
%                 & Send $\${\sf fee}$ ether to $\Psgx$. \\

  \hline
\end{tabularx}
\caption{
A simple, fee-free version of the Town Crier contract \tcont.
Note that communication 
with \tcont is through an authenticated channel implemented through digital signatures (which
are not explicitly expressed in our notation).
}
\label{tbl:tc-contract}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's enclave program}
\end{center}
\begin{tabular}{l}
%{\bf Inputs}:  ${\sf params}$, \\[5pt]
{\bf Initialize}:  On receive ``initialize'': \\ %{\it //~called only once upfront}\\
\quad $(\pksgx, \sksgx) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
\quad Record $(\pksgx, \sksgx)$\\
\quad Output $\pksgx$   {\it //~incl. in measurement \& attestation } 
\\[5pt]

{\bf Resume:} On receive $({\sf id}, {\sf params})$\\
\quad Parse ${\sf params} := (\weburl, \pkurl, T) $:\\
%\quad Parse ${\sf params} := (\weburl, \pkurl, T)$ \\
\quad $T_{\textrm{start}} := \clock()$\\
\quad Establish secure channel w/ $\weburl$ w/ public key $\pkurl$ \\
\quad Download the webpage at $\weburl$\\
\quad $T_{\textrm{end}}: = \clock()$\\
\quad Assert ${\sf round}(T_{\textrm{start}}) = {\sf round}(T_{\textrm{end}}) = T$\\
\quad Parse webpage and extract ${\sf data}$\\
\quad $\sigma := \Sigma.{\sf Sign}({\sksgx}, ({\sf id}, {\sf params}, {\sf data}))$\\
\quad Output $(({\sf id}, {\sf params}, {\sf data}), \sigma)$
\end{tabular}
\end{boxedminipage}
\caption{
SGX enclave's code.
} 
\end{figure}


\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's untrusted relay $\relay$}
\end{center}
\begin{tabular}{l}
{\bf Initialize}:\\
Send ``initialize'' to $\fsgx[\enclaveprog, \relay]$\\
On receive $(\pksgx, \sigatt)$ from $\fsgx[\enclaveprog, \relay]$:\\
\quad Publish $(\pksgx, \sigatt)$\\[5pt]

{\bf  Loop forever}: \\
When \tcont receives new request $({\sf id}, \_, {\sf params})$:\\
\quad Parse ${\sf params} := (\weburl, \pkurl, T)$\\
\quad Fork: \\
\ \quad Wait till time $T$\\
\ \quad Send $(\text{``resume''}, {\sf params})$ to $\fsgx[\enclaveprog, \relay]$ \\
\ \quad On recv $(({\sf id}, {\sf params}, {\sf data}), \sigma)$ from $\fsgx[\enclaveprog, \relay]$:\\ 
\ \quad \quad  {\sf AuthSend} $({\sf id}, {\sf params}, {\sf data})$ to \tcont
\end{tabular}
\end{boxedminipage}
\caption{Town Crier untrusted relay. For simplicity, here we assume that there is only 
a single enclave program. When multiple data feed sources 
are supported, 
we need multiple enclaves that instantiate different parsers for different sites.
In this case, the Town Crier relay also initialize all enclave instances
and route the request to the correct enclave instance.}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf $\fsgx[\enclaveprog, \relay]$: abstraction for SGX}
\end{center}
\begin{tabular}{l}
{\bf Hardcoded:} $\skM$ \\[5pt]

{\bf Assume:} \\ 
$\enclaveprog$ has entry points {\bf Initialize} and {\bf Resume}\\[5pt]

{\bf Initialize:}\\
On receive ``initialize'' from $\relay$: \\
\quad Let ${\sf outp} := \enclaveprog.{\bf Initalize}()$  \\
\quad $\sigatt := \sigsgx.{\sf Sign}(\skM, (\enclaveprog, {\sf outp}))$ \\[-1pt]
\qquad \qquad {\it //~models group sig.}\\
\quad Output  $({\sf outp}, \sigatt)$\\[5pt]

On receive (``resume'', ${\sf params}$) from $\relay$: \\
\quad Let ${\sf outp} := \enclaveprog.{\bf Resume}({\sf params})$  \\
\quad Output ${\sf outp}$ 
\end{tabular}
\end{boxedminipage}
\caption{Formal abstraction for SGX attested execution. 
We adopt a similar modeling approach by Shi et al., where
the SGX group signature is abstracted with a normal signature
by a manufacturer key $\pkM$. 
\elaine{cite our sok paper}
The above functionality only models a subset of SGX features
that is sufficient for our formalism.
}
\end{figure}


\subsection{Formal Guarantees}

\paragraph{Authenticity.}
Roughly speaking, authenticity means that 
an adversary cannot convince   
the Town Crier blockchain contract 
$\tcont$ to accept 
a wrong data feed. 
Here a wrong data feed means any content
that differs from the expected content
obtained by crawling the specified \weburl at 
the specified time $T$.

In formally defining 
authenticity, 
we assume that the user and the blockchain
contract $\tcont$ behave honestly.
Recall that the user must verify 
upfront the attestation $\sigatt$ 
that vouches 
for the enclave's public key $\pksgx$.

\begin{definition}[Authenticity]
We say that the Town Crier protocol 
satisifies {\it authenticity} of data feed,
if for any polynomial-time adversary
that can interact arbitrarily with $\fsgx$,
it cannot 
persuade an honest verifier to accept
a tuple $(\pksgx, \sigatt, {\sf params}:=(\weburl, \pkurl, T), {\sf data}, \sigma)$
%${\sf params} := (\weburl, \pkurl, T)$).
where ${\sf data}$ is not 
the contents of 
\weburl with the public key $\pkurl$ at time $T$.
More formally, 
for any probablistic polynomial-time adversary $\algA$
\[
\begin{array}{l}
\Pr\left[
\begin{array}{l}
(\pksgx, \sigatt, {\sf id}, {\sf params}, {\sf data}, \sigma) \leftarrow 
\algA^{\fsgx}(1^\lambda) :\\
\quad \left(\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pksgx)) = 1\right) \wedge \\
\quad \left(\Sigma.{\sf Verify}(\pksgx, {\sf id}, {\sf params}, {\sf data})  = 1\right) \wedge\\
\quad {\sf data} \neq \enclaveprog({\sf params}) 
\end{array}
\right] \\[3pt] 
\leq {\sf negl}(\lambda)
\end{array}
\]
\label{defn:auth}
\end{definition}


\begin{theorem}[Authenticity]
Assume that $\sigsgx$
and $\Sigma$ are secure signature schemes (recall
that we follow Shi et al. \elaine{cite} who show
how to abstractly  
model SGX's group signature as a regular signature
scheme under a manufacturer public key $\pkM$),
%and assume that the cryptographic protocol used to realize the secure channel
%with $\pkurl$ is secure;
then, the above 
protocol achieves authenticity of data feed by Definition~\ref{defn:auth}.
\end{theorem}
\begin{proof} (sketch.)
We show that if the 
adversary $\algA$ succeeds in a forgery with non-negligible probability,
we can construct an adversary $\algB$ that can either
break $\sigsgx$ or $\Sigma$ with non-neligible probability.
We consider two cases. 
The reduction $\algB$ will flip a random coin to guess which
case it is, and if the guess is wrong, simply abort.
\begin{itemize}[leftmargin=5mm]
\item
Case 1: $\algA$ outputs a signature $\sigma$ that uses the same  
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will try to break $\Sigma$. 
$\algB$ interacts with a signature challenger ${\sf Ch}$ who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates 
$\fsgx$ by implicitly letting $\pksgx := \pk^*$.
Whenever $\fsgx$ needs to sign a query, $\algB$ passes the signing query
onto the signature challenger ${\sf Ch}$.

Since ${\sf data} \neq \enclaveprog({\sf params})$,
$\algB$ cannot have queried ${\sf Ch}$  
on a tuple of the form $(\_, {\sf params}, {\sf data})$. 
Therefore, $\algB$ simply outputs 
what $\algA$ 
outputs (suppressing unnecessary terms) as the signature forgery. 

\item
Case 2:
 $\algA$ outputs a signature $\sigma$ that uses a different 
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will seek to break $\sigsgx$.
$\algB$ interacts with a signature challenger ${\sf Ch}$, who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates $\fsgx$ by implicitly setting
$\pkM := \pk^*$.
Whenever $\fsgx$ needs to make a signature
with $\skM$, 
$\algB$ simply passes the signature query onto ${\sf Ch}$.
In this case, in order for $\algA$ to succeed,
it must produce a valid signature $\sigatt$ 
for a different public key $\pk'$.
Therefore, $\algB$ simply outputs this as a signature forgery.
\end{itemize}
\end{proof}


\section{Extensions}

\subsection{Handling Transaction Fees}
To mitigate potential Denial-of-Service (DoS) attacks, 
Ethereum employs a fee mechanism, referred to as ``gas'', 
where the submitter of a transaction (that invokes
an entry point in the contract) pays a  
transaction fee
roughly proportional to the execution time of the 
corresponding entry point.

Our basic Town Crier implements a policy where the requester pays for all gas 
needed and Town Crier in effect pays nothing.
The concrete instantition  
is described in Figure \elaine{refer}. 
Since $\pksgx$ has to invoke the {\bf Deliver} entry point, it has
to advance 
a gas payment 
$\sbrown{\Delta F_{\text{deliver}}}$.
This amount will be entirely refunded through money deposited in the contract 
by the requester.


\begin{figure}
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf Town Crier blockchain contract \tcont with fees}} \\ [1ex]
  {\bf Request:} & On recv $({\sf id}, {\sf callback}, {\sf params}, 
\sbrown{\Delta F_{\text{request}}} + 
\smaroon{\$F_{\text{deliver}}}  )$ from some user $\pkU$: \\
%                 & If $(\${\sf fee} < F_{\rm min}$ or $\${\sf fee} > F_{\rm max})$ \\
%                 & \hspace*{1em} Return $\${\sf fee}$ to $\pkU$ \\
		 %& If $(\smaroon{\$ F_{\text{callback}}} < {\rm min}$ or $\smaroon{\$ F_{\text{callback}}} > {\rm max})$ \\
		 & Assert $\smaroon{\$ F_{\text{deliver}}} \in [{\rm min}, {\rm max}]$ \\
%and $\smaroon{\$ F_{\text{callback}}} > {\rm max})$ \\
%                 & \hspace*{1em} Return $\smaroon{\$fee}$ to $\pkU$ \\
                 & Else record $({\sf id}, {\sf callback}, {\sf params}, {\tt F_{\text{deliver}}})$\\[-10pt]
    & {\it {\color{gray} {//~at most ${{\$ F_{\textrm{request}}}}$ {gas consumed}}} }\\[-10pt]
    & {\it {\color{gray} {//~all remaining {gas returned to $\pkU$}}} }\\
  {\bf Deliver:} & On recv $({\sf id}, {\sf params}, {\sf data}, 
$\sbrown{\Delta {\tt F_{\text{deliver}}}}$ )$ from $\pksgx$: \\
                 & Let $({\sf id}, {\sf callback}, {\sf params'}, {\tt F'_{\text{deliver}}})$ be the most recently recorded tuple for ${\sf id}$\\
                 & Assert ${\sf params} = {\sf params}'$\\
                &   Assert ${\tt F'_{\text{deliver}}} \leq \sbrown{\Delta F_{\text{deliver}}}$\\
                 & Send $\smaroon{\$F_{\text{deliver}}}$ to $\pksgx$ \\
                 & Call ${\sf callback}({\sf data})$ \\[-10pt]
    & {\it {\color{gray} {//~at most ${{\$ F_{\textrm{deliver}}}}$ {gas consumed}}} }\\[-10pt]
    & {\it {\color{gray} {//~all remaining {gas returned to $\pksgx$}}} }\\

  \hline
\end{tabularx}
\caption{
Town Crier contract \tcont reflecting fees.
$\sbrown{\Delta F_{\text{request}}}$ denotes the gas for executing the {\bf Request} 
entry point. 
$\sbrown{\Delta F_{\text{deliver}}}$ denotes the gas for executing the {\bf Deliver} entry point
that includes the user-defined ${\sf callback}$.
\smaroon{\$F_{\text{deliver}}} denotes 
${\tt F_{\text{deliver}}}$ amount of 
explicit, non-gas currency units.
Essentially, the requester first pays 
$\smaroon{\$ F_{\text{deliver}}}$ currency units which will be used to refund
the $\sbrown{\Delta F_{\text{deliver}}}$ amount of gas
that $\pksgx$ will need to put in to call the {\bf Deliver} entry point.
}
\label{tbl:tc-contract}
\end{figure}





\subsection{Support for Cancellation}




