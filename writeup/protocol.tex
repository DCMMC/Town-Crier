\newcommand{\fsgx}{\ensuremath{\mathcal{F}_{\textrm{sgx}}}\xspace}
\newcommand{\pk}{\ensuremath{{\sf pk}}}
\newcommand{\sk}{\ensuremath{{\sf sk}}}
\newcommand{\pkM}{\ensuremath{{\sf pk}_{\mathcal{M}}}}
\newcommand{\skM}{\ensuremath{{\sf sk}_{\mathcal{M}}}}
\newcommand{\pkU}{\ensuremath{{\sf pk}_{\mathcal{U}}}}
\newcommand{\pksgx}{\ensuremath{{\sf pk}_{\textrm{sgx}}}}
\newcommand{\sksgx}{\ensuremath{{\sf sk}_{\textrm{sgx}}}}
\newcommand{\pkurl}{\ensuremath{{\sf pk}_{\textrm{url}}}\xspace}
\newcommand{\rl}{\ensuremath{{\sf RL}}}
\newcommand{\relay}{\ensuremath{\mathcal{R}}}
%\newcommand{\digest}{\ensuremath{{\sf digest}}}
\newcommand{\enclaveprog}{\ensuremath{{\sf prog}_{\textrm{encl}}}}
\newcommand{\sigatt}{\ensuremath{{\sigma_{\textrm{att}}}}}
\newcommand{\sigsgx}{\ensuremath{{\Sigma_{\textrm{sgx}}}}}
\newcommand{\weburl}{\ensuremath{{{\sf url}}}\xspace}
\newcommand{\clock}{\ensuremath{{{\sf clock}}}}
\newcommand{\algA}{\ensuremath{\mathcal{A}}}
\newcommand{\algB}{\ensuremath{\mathcal{B}}}

\section{Protocol}
\elaine{to be merged into main body}


\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf User: offline attestation of SGX enclave}
\end{center}
\begin{tabular}{l}
{\bf Inputs}: $\pkM$, $\pksgx$, $\enclaveprog$, $\sigatt$ \\[5pt]
{\bf Checks:} \\
Assert $\enclaveprog$ is the expected enclave code\\
Assert $\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pksgx))$ \\
Assert \tcont is correct and parametrized w/ \pksgx\\
{\it //~now okay to rely on \tcont}
\end{tabular}
\end{boxedminipage}
\caption{A user checks the Town Crier blockchain contract \tcont, 
and verifies an SGX attestation of the enclave's code and its public key $\pksgx$ before 
entering a contract that calls \tcont.
\elaine{here we use a simplified abstraction, but the actual implementation
also involves verifying the revocation list.}
%\elaine{there is a notational mismatch here. here we write RL explicitly, but
%not in the Fsgx abstraction}
} 
\end{figure}


\begin{figure}
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf Town Crier blockchain contract \tcont}} \\ [1ex]
  {\bf Request:} & On recv $({\sf id}, {\sf callback}, {\sf params})$ from some user $\pkU$: \\
%                 & If $(\${\sf fee} < F_{\rm min}$ or $\${\sf fee} > F_{\rm max})$ \\
%                 & \hspace*{1em} Return $\${\sf fee}$ to $\pkU$ \\
                 & Record $({\sf id}, {\sf callback}, {\sf params})$ \\
  {\bf Deliver:} & On recv $({\sf id}, {\sf params}, {\sf data})$ from $\pksgx$: \\
		 & Let $({\sf id}, {\sf callback}, {\sf params'})$ be the most recently recorded tuple for ${\sf id}$\\
		 & Assert ${\sf params} = {\sf params}'$\\
                 & Call ${\sf callback}({\sf data})$ \\
%                 & Send $\${\sf fee}$ ether to $\Psgx$. \\

  \hline
\end{tabularx}
\caption{
A simple, fee-free version of the Town Crier contract \tcont.
Note that communication 
with \tcont is through an authenticated channel implemented through digital signatures (which
are not explicitly expressed in our notation).
}
\label{tbl:tc-contract}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's enclave program}
\end{center}
\begin{tabular}{l}
%{\bf Inputs}:  ${\sf params}$, \\[5pt]
{\bf Initialize}:  On receive ``initialize'': \\ %{\it //~called only once upfront}\\
\quad $(\pksgx, \sksgx) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
\quad Record $(\pksgx, \sksgx)$\\
\quad Output $\pksgx$   {\it //~incl. in measurement \& attestation } 
\\[5pt]

{\bf Resume:} On receive $({\sf id}, {\sf params})$\\
\quad Parse ${\sf params} := (\weburl, \pkurl, T) $:\\
%\quad Parse ${\sf params} := (\weburl, \pkurl, T)$ \\
\quad $T_{\textrm{start}} := \clock()$\\
\quad Establish secure channel w/ $\weburl$ w/ public key $\pkurl$ \\
\quad Download the webpage at $\weburl$\\
\quad $T_{\textrm{end}}: = \clock()$\\
\quad Assert ${\sf round}(T_{\textrm{start}}) = {\sf round}(T_{\textrm{end}}) = T$\\
\quad Parse webpage and extract ${\sf data}$\\
\quad $\sigma := \Sigma.{\sf Sign}({\sksgx}, ({\sf id}, {\sf params}, {\sf data}))$\\
\quad Output $(({\sf id}, {\sf params}, {\sf data}), \sigma)$
\end{tabular}
\end{boxedminipage}
\caption{
SGX enclave's code.
} 
\end{figure}


\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's untrusted relay $\relay$}
\end{center}
\begin{tabular}{l}
{\bf Initialize}:\\
Send ``initialize'' to $\fsgx[\enclaveprog, \relay]$\\
On receive $(\pksgx, \sigatt)$ from $\fsgx[\enclaveprog, \relay]$:\\
\quad Publish $(\pksgx, \sigatt)$\\[5pt]

{\bf  Loop forever}: \\
When \tcont receives new request $({\sf id}, \_, {\sf params})$:\\
\quad Parse ${\sf params} := (\weburl, \pkurl, T)$\\
\quad Fork: \\
\ \quad Wait till time $T$\\
\ \quad Send $(\text{``resume''}, {\sf params})$ to $\fsgx[\enclaveprog, \relay]$ \\
\ \quad On recv $(({\sf id}, {\sf params}, {\sf data}), \sigma)$ from $\fsgx[\enclaveprog, \relay]$:\\ 
\ \quad \quad  {\sf AuthSend} $({\sf id}, {\sf params}, {\sf data})$ to \tcont
\end{tabular}
\end{boxedminipage}
\caption{Town Crier untrusted relay. For simplicity, here we assume that there is only 
a single enclave program. When multiple data feed sources 
are supported, 
we need multiple enclaves that instantiate different parsers for different sites.
In this case, the Town Crier relay also initialize all enclave instances
and route the request to the correct enclave instance.}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf $\fsgx[\enclaveprog, \relay]$: abstraction for SGX}
\end{center}
\begin{tabular}{l}
{\bf Hardcoded:} $\skM$ \\[5pt]

{\bf Assume:} \\ 
$\enclaveprog$ has entry points {\bf Initialize} and {\bf Resume}\\[5pt]

{\bf Initialize:}\\
On receive ``initialize'' from $\relay$: \\
\quad Let ${\sf outp} := \enclaveprog.{\bf Initalize}()$  \\
\quad $\sigatt := \sigsgx.{\sf Sign}(\skM, (\enclaveprog, {\sf outp}))$ \\[-1pt]
\qquad \qquad {\it //~models group sig.}\\
\quad Output  $({\sf outp}, \sigatt)$\\[5pt]

On receive (``resume'', ${\sf params}$) from $\relay$: \\
\quad Let ${\sf outp} := \enclaveprog.{\bf Resume}({\sf params})$  \\
\quad Output ${\sf outp}$ 
\end{tabular}
\end{boxedminipage}
\caption{Formal abstraction for SGX attested execution. 
We adopt a similar modeling approach by Shi et al., where
the SGX group signature is abstracted with a normal signature
by a manufacturer key $\pkM$. 
\elaine{cite our sok paper}
The above functionality only models a subset of SGX features
that is sufficient for our formalism.
}
\end{figure}


\subsection{Formal Guarantees}

\paragraph{Authenticity.}
Roughly speaking, authenticity means that 
an adversary cannot convince   
the Town Crier blockchain contract 
$\tcont$ to accept 
a wrong data feed. 
Here a wrong data feed means any content
that differs from the expected content
obtained by crawling the specified \weburl at 
the specified time $T$.

In formally defining 
authenticity, 
we assume that the user and the blockchain
contract $\tcont$ behave honestly.
Recall that the user must verify 
upfront the attestation $\sigatt$ 
that vouches 
for the enclave's public key $\pksgx$.

\begin{definition}[Authenticity]
We say that the Town Crier protocol 
satisifies {\it authenticity} of data feed,
if for any polynomial-time adversary
that can interact arbitrarily with $\fsgx$,
it cannot 
persuade an honest verifier to accept
a tuple $(\pksgx, \sigatt, {\sf params}:=(\weburl, \pkurl, T), {\sf data}, \sigma)$
%${\sf params} := (\weburl, \pkurl, T)$).
where ${\sf data}$ is not 
the contents of 
\weburl with the public key $\pkurl$ at time $T$.
More formally, 
for any probablistic polynomial-time adversary $\algA$
\[
\begin{array}{l}
\Pr\left[
\begin{array}{l}
(\pksgx, \sigatt, {\sf id}, {\sf params}, {\sf data}, \sigma) \leftarrow 
\algA^{\fsgx}(1^\lambda) :\\
\quad \left(\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pksgx)) = 1\right) \wedge \\
\quad \left(\Sigma.{\sf Verify}(\pksgx, {\sf id}, {\sf params}, {\sf data})  = 1\right) \wedge\\
\quad {\sf data} \neq \enclaveprog({\sf params}) 
\end{array}
\right] \\[3pt] 
\leq {\sf negl}(\lambda)
\end{array}
\]
\label{defn:auth}
\end{definition}


\begin{theorem}[Authenticity]
Assume that $\sigsgx$
and $\Sigma$ are secure signature schemes (recall
that we follow Shi et al. \elaine{cite} who show
how to abstractly  
model SGX's group signature as a regular signature
scheme under a manufacturer public key $\pkM$),
%and assume that the cryptographic protocol used to realize the secure channel
%with $\pkurl$ is secure;
then, the above 
protocol achieves authenticity of data feed by Definition~\ref{defn:auth}.
\end{theorem}
\begin{proof} (sketch.)
We show that if the 
adversary $\algA$ succeeds in a forgery with non-negligible probability,
we can construct an adversary $\algB$ that can either
break $\sigsgx$ or $\Sigma$ with non-neligible probability.
We consider two cases. 
The reduction $\algB$ will flip a random coin to guess which
case it is, and if the guess is wrong, simply abort.
\begin{itemize}[leftmargin=5mm]
\item
Case 1: $\algA$ outputs a signature $\sigma$ that uses the same  
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will try to break $\Sigma$. 
$\algB$ interacts with a signature challenger ${\sf Ch}$ who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates 
$\fsgx$ by implicitly letting $\pksgx := \pk^*$.
Whenever $\fsgx$ needs to sign a query, $\algB$ passes the signing query
onto the signature challenger ${\sf Ch}$.

Since ${\sf data} \neq \enclaveprog({\sf params})$,
$\algB$ cannot have queried ${\sf Ch}$  
on a tuple of the form $(\_, {\sf params}, {\sf data})$. 
Therefore, $\algB$ simply outputs 
what $\algA$ 
outputs (suppressing unnecessary terms) as the signature forgery. 

\item
Case 2:
 $\algA$ outputs a signature $\sigma$ that uses a different 
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will seek to break $\sigsgx$.
$\algB$ interacts with a signature challenger ${\sf Ch}$, who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates $\fsgx$ by implicitly setting
$\pkM := \pk^*$.
Whenever $\fsgx$ needs to make a signature
with $\skM$, 
$\algB$ simply passes the signature query onto ${\sf Ch}$.
In this case, in order for $\algA$ to succeed,
it must produce a valid signature $\sigatt$ 
for a different public key $\pk'$.
Therefore, $\algB$ simply outputs this as a signature forgery.
\end{itemize}
\end{proof}



