

\section{Basic Protocol}

\subsection{A Gas-Free Basic Protocol}
For simplicity, we first describe a gas-free version of our basic protocol.
This basic protocol improves the strawman solution 
by resolving the aforementioned two issues.

\paragraph{Enclave-specific keys.}
To avoid having to verify a group signature on the blockchain,  
during enclave initialization, 
we have each enclave generate its enclave-specific 
key pair denoted $(\pksgx, \sksgx)$.
The $\sksgx$ is retained within the enclave and used
to sign the datagrams extracted from data sources during the request phase.
Since Ethereum itself 
already verifies signatures on messages sent from users (i.e.,
users interact with the 
Ethereum blockchain through an authenticated channel), 
we devise a trick to {\it piggyback the signature 
verification on top of Ethereum's already existing signature verfication mechanism}.
This means that the SGX enclave must sign datagrams using the \elaine{fill in name}
signature scheme that is compatible with Ethereum's signature verification.
This way, we need not implement a separate signature verification
in the user-defined $\tcont$ contract.
This saves 
not only software engineering effort, but more importantly, gas.

To make this idea fully work, in an offline phase, 
a user must verify an SGX attestation vouching for its own enclave-specific 
public key  $\pksgx$.
This $\pksgx$ is hardcoded inside the blockchain contract $\tcont$. 
The user is responsible for making sure that this hardcoded $\pksgx$ has an 
appropriate SGX attestation before interacting with the $\tcont$ 
blockchain contract.

\paragraph{Instantiating trusted absolute clock.}
Since SGX's trusted clock provides only relative time with 
respect to a reference point, 
we will rely on 
the following mechanism to realize a trusted {\it absolute} clock. 
\begin{itemize}[leftmargin=5mm]
\item
{\bf Offline calibration.}
In an offline phase, a user $U$ performs the following calibration protocol
with the SGX enclave:

\elaine{this formal notation needs to be changed, it is not compatible
with other formal notation.}

\begin{tabular}{rl}
$\mathcal{U}$: & get absolute $T_0$ from a trusted source \\
$\mathcal{U}$: & pick random ${\sf nonce}$\\
$\mathcal{U} \rightarrow \fsgx$: & ${\sf nonce}$\\
$\fsgx \rightarrow \mathcal{U}$: & (${\sf clock\_ref}$, $\Delta T_0$, ${\sf nonce}$)\\
$\mathcal{U}$: & record ${\sf clock\_ref}$, $\Delta T_0$
\end{tabular}

\elaine{the above assumes that 
an authenticated channel has been established.}

\item
{\bf Online trusted absolute clock.}
Whenever $\fsgx$ gives the relative time $\Delta T$ with respect
to ${\sf clock\_ref}$, the user 
{\it i)} checks that ${\sf clock\_ref}$ agrees with the saved
reference point, and 
{\it ii)}
computes $T_0 + \Delta T - \Delta T_0$
as the absolute time.
\end{itemize}


\paragraph{Formal protocol description.}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf User: offline attestation of SGX enclave}
\end{center}
\begin{tabular}{l}
{\bf Inputs}: $\pkM$, $\pksgx$, $\enclaveprog$, $\sigatt$ \\[5pt]
{\bf Checks:} \\
Assert $\enclaveprog$ is the expected enclave code\\
Assert $\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pksgx))$ \\
Assert \tcont is correct and parametrized w/ \pksgx\\
{\it //~now okay to rely on \tcont}
\end{tabular}
\end{boxedminipage}
\caption{A user checks the Town Crier blockchain contract \tcont, 
and verifies an SGX attestation of the enclave's code and its public key $\pksgx$ before 
entering a contract that calls \tcont.
\elaine{here we use a simplified abstraction, but the actual implementation
also involves verifying the revocation list.}
%\elaine{there is a notational mismatch here. here we write RL explicitly, but
%not in the Fsgx abstraction}
} 
\end{figure}


\begin{figure}
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf Town Crier blockchain contract \tcont}} \\ [1ex]
  {\bf Request:} & On recv $({\sf id}, {\sf params}, {\sf callback})$ from some $\reqcont$: \\
%                 & If $(\${\sf fee} < F_{\rm min}$ or $\${\sf fee} > F_{\rm max})$ \\
%                 & \hspace*{1em} Return $\${\sf fee}$ to $\pkU$ \\
                 & Record $({\sf id}, {\sf params}, {\sf callback})$ \\
  {\bf Deliver:} & On recv $({\sf id}, {\sf params}, {\sf data})$ from $\pksgx$: \\
		 & Let $({\sf id}, {\sf params'}, {\sf callback} )$ be the most recently recorded tuple for ${\sf id}$\\
		 & Assert ${\sf params} = {\sf params}'$\\
                 & Call ${\sf callback}({\sf data})$ \\
%                 & Send $\${\sf fee}$ ether to $\Psgx$. \\

  \hline
\end{tabularx}
\caption{
A simple, fee-free version of the Town Crier contract \tcont.
Note that communication 
with \tcont is through an authenticated channel implemented through digital signatures (which
are not explicitly expressed in our notation).
}
\label{tbl:tc-contract}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's enclave program}
\end{center}
\begin{tabular}{l}
%{\bf Inputs}:  ${\sf params}$, \\[5pt]
{\bf Initialize}:  On receive ``initialize'': \\ %{\it //~called only once upfront}\\
\quad $(\pksgx, \sksgx) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
\quad Record $(\pksgx, \sksgx)$\\
\quad Output $\pksgx$   {\it //~incl. in measurement \& attestation } 
\\[5pt]

{\bf Resume:} On receive $({\sf id}, {\sf params})$\\
\quad Parse ${\sf params} := (\weburl, \pkurl, T) $:\\
%\quad Parse ${\sf params} := (\weburl, \pkurl, T)$ \\
\quad $T_{\textrm{start}} := \clock()$\\
\quad Establish secure channel w/ $\weburl$ w/ public key $\pkurl$ \\
\quad Download the webpage at $\weburl$\\
\quad $T_{\textrm{end}}: = \clock()$\\
\quad Assert ${\sf round}(T_{\textrm{start}}) = {\sf round}(T_{\textrm{end}}) = T$\\
\quad Parse webpage and extract ${\sf data}$\\
\quad $\sigma := \Sigma.{\sf Sign}({\sksgx}, ({\sf id}, {\sf params}, {\sf data}))$\\
\quad Output $(({\sf id}, {\sf params}, {\sf data}), \sigma)$
\end{tabular}
\end{boxedminipage}
\caption{
SGX enclave's code.
} 
\end{figure}


\begin{figure}
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Town Crier's untrusted relay $\relay$}
\end{center}
\begin{tabular}{l}
{\bf Initialize}:\\
Send ``initialize'' to $\fsgx[\enclaveprog, \relay]$\\
On receive $(\pksgx, \sigatt)$ from $\fsgx[\enclaveprog, \relay]$:\\
\quad Publish $(\pksgx, \sigatt)$\\[5pt]

{\bf  Loop forever}: \\
When \tcont receives new request $({\sf id}, \_, {\sf params})$:\\
\quad Parse ${\sf params} := (\weburl, \pkurl, T)$\\
\quad Fork: \\
\ \quad Wait till time $T$\\
\ \quad Send $(\text{``resume''}, {\sf params})$ to $\fsgx[\enclaveprog, \relay]$ \\
\ \quad On recv $(({\sf id}, {\sf params}, {\sf data}), \sigma)$ from $\fsgx[\enclaveprog, \relay]$:\\ 
\ \quad \quad  {\sf AuthSend} $({\sf id}, {\sf params}, {\sf data})$ to \tcont
\end{tabular}
\end{boxedminipage}
\caption{Town Crier untrusted relay. For simplicity, here we assume that there is only 
a single enclave program. When multiple data feed sources 
are supported, 
we need multiple enclaves that instantiate different parsers for different sites.
In this case, the Town Crier relay also initialize all enclave instances
and route the request to the correct enclave instance.}
\end{figure}













