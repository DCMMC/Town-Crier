\section{Experiments}
\label{sec:experiments}

\begin{table*}[ht]
\centering
\begin{tabular}{lrr|rr|rr}
\toprule
& \multicolumn{2}{c|}{\sf CashSettledPut} &
  \multicolumn{2}{c|}{\sf FlightIns} &
  \multicolumn{2}{c}{\sf SteamTrade} \\
  & time(ms) & proportion & time(ms) & proportion  & time(ms) & proportion\\
\midrule
Context switch      & $0.68\pm 0.12$    & 0.37\%   
                    & $0.77\pm 0.07$    & 0.15\%    
                    & $0.89\pm 0.47$    & 0.10\%\\
%
Web scraper         & $172.07\pm 12.41$  & 94.20\%  
                    & $512.32\pm 44.66$  & 97.96\%   
                    & $913.73\pm 92.51$  & 98.83\%\\
%
Sign                & $9.71\pm 0.55$   & 5.32\%   
                    & $9.64\pm 0.59$   & 1.84\%    
                    & $9.65\pm 0.63$   & 1.04\%\\
%
Serialization       & $0.20\pm 0.04$    & 0.11\%   
                    & $0.25\pm 0.09$    & 0.05\%    
                    & $0.32\pm 0.10$    & 0.03\%\\
\midrule
Total               & $182.66\pm 12.7$  & 100.00\%    
                    & $522.98\pm 44.92$ & 100.00\% 
                    & $924.59\pm 92.63$ & 100.00\%\\
\bottomrule
\end{tabular}
\caption{Running time of handling a request. We repeated the experiments for 5 times and
report the mean and standard deviation. Proportions are for means.}
\label{tab:eval_profiling}
\end{table*}



%\begin{table*}[ht]
%\centering
%\begin{tabular}{lrr|rr|rr}
%\toprule
%& \multicolumn{2}{c|}{\sf CashSettledPut} & 
%  \multicolumn{2}{c|}{\sf FlightIns} &
%  \multicolumn{2}{c}{\sf SteamTrade} \\ 
%\midrule
%& \multicolumn{2}{c|}{\bf Enclave response time}
%& \multicolumn{2}{c|}{\bf Enclave response time}
%& \multicolumn{2}{c}{\bf Enclave response time} \\
%  & time(ms) & \multicolumn{1}{c|}{proportion} & time(ms) & \multicolumn{1}{c|}{proportion} & time(ms) & \multicolumn{1}{c}{proportion}\\
%%\midrule
%Context switch & 0.41    & 0.21\%   & 0.44      & 0.08\%    & 0.89    & 0.07\%\\
%Web scraper         & 181.03  & 94.12\%  & 512.32    & 98.02\%   & 1297.73 & 99.11\%\\
%Sign                & 10.63   & 5.53\%   & 9.64      & 1.85\%    & 10.45   & 0.80\%\\
%Serialization       & 0.28    & 0.14\%   & 0.25      & 0.05\%    & 0.32    & 0.02\%\\
%%\midrule
%{\bf Total}     & {\bf 192.35}  & {100.00}\%    & {\bf 522.65}  & 100.00\% & 
%{\bf 1309.39} & 100.00\%\\
%\bottomrule
%\end{tabular}
%\caption{Running time of handling a request \elaine{Fan to 1) add std dev;
%2)update context switch time to include
%time switching out too}}
%\label{tab:eval_profiling}
%\end{table*}
%

We evaluated the performance of \tc on a Dell Inspiron 13-7359 laptop equipped
with an Intel i7-6500U CPU and 8.00GB memory.  This model is chosen 
because it is one of the few SGX-enabled systems available on the market at the
writing of this paper. Although the hosting platform is just moderately preferment, we
show that on a single host, the current implementation is able to handle 
transactions generated by Ethereum blockchain in real time. 
\elaine{todo: modify
the previous sentence 
after Fan's new experiments are done.}


\subsection{Enclave Response Time}
We measured the enclave response time for handling a request. Here ``enclave response time''
is defined as the difference between 1) the time 
the relay decides to send a request to an SGX enclave;
and 2) the time the relay gets a response back from the SGX enclave. 
For each application, we repeat the  
experiment 5 times, and report the mean and the standard deviation.  

Table \ref{tab:eval_profiling} summarizes the total enclave response time as
well as its breakdown.  The table suggests that for the three applications we
implemented the enclave response time ranges from {\bf 183 ms} to {\bf 925 ms}.
The response time is clearly dominated by the web scraper time, i.e., the time
it takes to fetch the requested information from a website.  Among the three
applications evaluated, {\sf SteamTrade} has the longest web scraper time, since
in the case of {\sf SteamTrade}, the web scraper must interact with the website
over multiple roundtrips to fetch the desired datagram.

\subsection{Transaction Throughput}
We performed a sequence of experiments running 1 to 20 enclaves 
on a single SGX-enable laptop
machine, and investigated the transaction throughput 
enabled by a single SGX machine. 
Note that SGX allows at most 20 enclaves on the specific machine model we used.
Figure \elaine{refer to Fan's new figure} 
shows that for the three applications evaluated,
a single SGX machine can handle
\elaine{blah to blah} 
tx/sec.

We give several meaningful data points of comparison to show
why a single SGX machine suffices to handle the load of
today's blockchains: 
Ethereum as of today handles 
\elaine{fill in} tx/sec on average. 
Bitcoin today handles
\elaine{fill in} tx/sec, and 
its maximum throughput (when the full block size is utilized)
would be roughly 7 tx/sec.
We know of no measurement study that 
investigates the fundamental 
throughput bound of the Ethereum  peer-to-peer network.
However, for Bitcoin, it has been shown that without
redesigning the protocol, 
Bitcoin cannot scale beyond  
42 tx/sec \elaine{double check this number} by simple reparametrization of its block size.
\elaine{cite}
Therefore, Town Crier will not be a throughput 
bottleneck when used 
with decentralized blockchains --- it appears 
more imminent to scale up 
the blockchain protocols themselves.

Last but not the least, our experiments indicate
that {\it there is no noticeable slowdown in terms of enclave
response time when multiple enclaves are run} on a single machine.
\elaine{Fan: double check}

\begin{figure}[h]
  \resizebox {\columnwidth} {!}{
\begin{tikzpicture}
\begin{axis}[
    every axis/.append style={font=\small},
	legend pos=north west,
	xlabel=Number of enclaves on a single machine,
	ylabel=Throughput (tx/sec),
    ylabel near ticks,
]
\addplot+[error bars/.cd,y dir=both,y explicit] table[x=n,y=steam,y error=e-steam]{data.csv};
\addplot+[error bars/.cd,y dir=both,y explicit] table[x=n,y=flight,y error=e-flight]{data.csv};
\addplot+[error bars/.cd,y dir=both,y explicit] table[x=n,y=putop,y error=e-putop]{data.csv};

\legend{{\sf SteamTrade},{\sf FlightIns},{\sf CashSettledPut}}
\end{axis}
\end{tikzpicture}
}
\caption{Throughput is measured on a single SGX-enabled machine. The x-axis is
the number of enclaves and the y-axis is the number of transactions processed per
second.  We ran five rounds of experiments and error bars show the standard
deviation.}
\end{figure}


\begin{table*}[ht]
\centering
\begin{tabular}{lr|r|r}
\toprule
& \multicolumn{1}{c|}{\sf CashSettledPut} &
  \multicolumn{1}{c|}{\sf FlightIns} &
  \multicolumn{1}{c}{\sf SteamTrade} \\
%  & gas (cents) & gas (cents) & gas (cents) \\
\midrule
Delivery before issuing cancel & ?? & ?? & ?? \\ 
Cancel arrived after delivery & & & \\ 
Cancel, no delivery & & & \\ 
\bottomrule
\end{tabular}
\caption{{\bf Callback-independent} portion of the gas expenditure, translated
to USD.  Here the difference between the gas expenditure across applications
is mainly caused 
by the difference in length of input parameters and output datagrams.
\elaine{ethan: check}
}
\label{tab:eval_gas}
\end{table*}



\subsection{Gas Costs}
Currently 1 gas costs $5 / 10^8$ ether, so at the exchange rate of \$5 for 1 ether, \$1 buys 4 million gas.
Here we provide costs for the components of our implementation.

The callback-independent portion of {\bf Deliver} costs about \num[group-separator={,}]{35000} gas (0.875\textcent), so this is the value of $\constgasmin$.
We set $\constgasmax = \num[group-separator={,}]{3100000}$ gas (77.5\textcent) as this is approximately Ethereum's maximum {\tt GASLIMIT}.
The cost for executing {\bf Request} is approximately \num[group-separator={,}]{120000} gas (3\textcent) of fixed cost, 
plus \num[group-separator={,}]{2500} gas (0.06\textcent) for every 32 bytes of request parameters.
The cost for executing {\bf Cancel} is \elaine{fill in} gas (\ethan{fill}\textcent)
including the gas cost $\constgasinvokecancel$ and the refund $\constgascancel$ paid to \tcs should {\bf Deliver} be called after {\bf Cancel}.




\subsection{Resilience against Component Compromise}
For the {\sf FlightIns} application, 
we implemented and evaluated two modes of majority voting:
\begin{itemize}[leftmargin=3mm]
\item
2-out-of-3 majority voting within the enclave which provides robustness
against data source compromise.
Specifically, the enclave scraped three different data sources in three parallel threads, 
namely, \elaine{fill in}.
Our experiments suggest that  
the enclave response time is 
\elaine{fill} ms in this case ({\it c.f.} \elaine{fill} ms, 
\elaine{fill} ms, and \elaine{fill} ms for 
each single data source).
There is no change in the gas cost in this case.
\item
2-out-of-3 majority voting within the requester contract,
which provides robustness against 
SGX compromise.
To support this, we ran three instances of SGX enclaves all scraping
the same data source.  
The main change in this scenario is that 
the gas cost would increase from
\elaine{fill} cents 
to \elaine{fill} cents.
In particular, the increase is just slightly more than 3x 
because \elaine{Ethan to fill in a very short explanation}.
\end{itemize}


%\elaine{add some eval results here.}

\subsection{Offline Measurements}
%We characterize several measurements 
%performed during the offline phase, 
%include the cost for generating and verifying SGX attestations,
%as well as clock calibration   
%measurements.


%Recall that a user must verify  
%an SGX enclave's attestation offline to securely establish 
%the identity $\pkTC$. 
%Our experiments show that the 

Recall that a one-time setup operation is required 
for the enclave to be established, and an attestation generated. 
Our measurement suggests that the enclave establishment takes
\elaine{fill} ms, 
and the attestation generation takes 
83.4 ms (among which 
18.5 ms is spent 
on report generation, 
and 64.9 ms on quote generation).

Recall also that since SGX only reports a relative clock
with respect to some reference point,  
a user must perform offline clock calibration 
to translate the  relative clock values into absolute ones.
The clock precision is decided
by the end-to-end latency for performing 
this clock calibration. 
Our experiments show that the latency is \elaine{fill} ms 
between when a relay sends a clock calibration request
to the enclave, and when it obtains a response.
The majority of this \elaine{fill} ms is spent on
\elaine{blah operation}
which took \elaine{blah} ms.
In practice, the clock precision is also affected
by the wide-area network latency
which is typically in the \elaine{blah} range.

%Recall that the absolute time of the \encname is verified
%by including a signed time stamp in the attestation and letting 
%clients check it it in real time. Therefore the latency
%of attestation generation plus a round-trip time
%define the precision of the absolute clock. 
%We evaluated the cycles consumed in generating an attestation and
%signing a Unix time stamp.
%
%\begin{table}[ht]
%\centering
%\begin{tabular}{lr}
%\toprule
%  & time(ms) \\
%\midrule
%Report Generation & $18.46$ \\
%Quote Generation & $64.94$ \\
%Signing the time stamp & $11.50$ \\
%\bottomrule
%\end{tabular}
%\caption{Running time of generating \att}
%\label{tab:eval_att}
%\end{table}
%
%Table \ref{tab:eval_att} summarizes the running time break down of generating an
%attestation along with a signed time stamp.  Note that two steps are involved in
%generating \att: first a report is produced within the \encname; then, an
%attestation, as known as a quote, is produced by QE based on the report passed
%to it. Note that \att only need to be generated once throughout the lifetime of the
%enclave.
%
%
%
