\section{Introduction}

Smart contracts are computer programs that autonomously facilitate or execute a contract. For decades, they have been envisioned as a means to extend the reach of existing contract law and render it more precise and efficiently executable through logical specification of legal agreements. Szabo, who coined the term ``smart contact'' in a seminal 1993 paper~\cite{}, gave as an example a smart contract that enforces car loan payments. If the owner of the car fails to make a timely payment, a smart contract could revoke physical access and return control of the ignition key to the bank. The contract could additionally be programmed to do so only at a time that is safe for the the owner, e.g., while the car is parked.

The emergence of decentralized cryptocurrencies such as Bitcoin has created new opportunities to realize smart contracts, thanks to two properties. First, cryptocurrencies equate control of their assets with knowledge of a private cryptographic key, in principle making control of money possible by an arbitrary computer program such as a smart contract. Second, cryptocurrencies are built atop blockchains, whose state evolves through a consensus protocol that treats transactions as computations over a global data structure. As these computations are decentralized, a blockchain may be viewed as an idealized abstraction equivalent to a trusted third party. It ensures fair, automated execution of computations over global state and eliminates the need for trusted intermediaries. 

While the scripting language embodied in Bitcoin is intentionally limited (e.g., lacks support for loops), the recently launched decentralized cryptocurrency Ethereum supports Turing-complete code. Ethereum can thus in principle realize fully expressive, self-enforcing, and self-executing smart contracts, going a long way toward fulfilling the vision of researchers and proponents.  

As Szabo's example shows, though, the most compelling applications of smart contracts cannot be realized in isolation on a blockchain, but require access to data about real-world state and phenomena. Financial contracts and derivatives, perhaps the most commonly cited applications of Ethereum~\cite{}, must be able to consume data about financial markets, including equity and commodity prices and exchange rates. Applications such as insurance policies are only realizable with data about weather, flights, delivery of goods, and so forth. 

To meet this need, the architects of Ethereum have proposed the use of \emph{data feeds} (sometimes called ``oracles''), contracts on the blockchain that serve data requests by other contracts~\cite{whitepaper,yellowpaper}. A few such data feeds, such as PriceFeed and Oraclize.it, support Ethereum smart contracts today, but have a notable drawback: They provide no assurance of trustworthy data beyond the reputation of their operators (who are typically individuals or small entities), even if their is data ultimately obtained from trustworthy sources.\footnote{Oraclize.it itself makes use of TLSnotary to notarize data, thereby distributing trust across two (small) operators.\ari{I think TLSnotary just signs webpages. So it's not clear how the mapping from pages to data is authenticated.}} To address this problem, systems such as SchellingCoin and Augur~\cite{} have been proposed that rely on mechanisms such as prediction markets to decentralize trust. While decentralization of trust is attractive, and underpins cryptocurrencies to begin with, prediction markets can support only a limited number of data feeds and have not yet seen widespread use in cryptocurrencies. The lack of a substantive ecosystem of trustworthy data feeds in Ethereum indeed remains a critical obstacle to its evolution~\cite{???}.

At the same time, however, existing e-commerce already relies on a wealth of broadly trusted data available from existing sources, namely websites operated by generally reputable organizations. The sources of such data, moreover, can be authenticated by a client if served over HTTPS. Smart contracts, however, cannot directly access internet data, as they do not have network access.

We present a system called \emph{Town Crier} (\tc) that fills the gap between smart contracts and today's data sources by serving as what we call an \emph{authenticated data feed} (ADF). \tc functions as a bridge between existing HTTPS-enabled data sources and the Ethereum blockchain, retrieving data from these sources and serving it to relying contracts on the blockchain in the form of specific data items that we call \emph{datagrams}. \tc avoids the problem of bootstrapping trust by executing its core functionality in an environment protected by \emph{trusted hardware}. Specifically, \tc makes use of Intel's recently released Software Guard Instructions (SGX). SGX enables a server to run a piece of code $\prog$ in an isolated environment called an \emph{enclave} (protected against even a malicious OS) and \emph{attest} (prove) to a remote party that the party is interacting with a legitimate, SGX-backed instance of $\prog$. 

By operating through a smart-contract front end, \tc can thus furnish a requested datagram $X$ from a particular trusted source, e.g., \texttt{https://www.Y.com}, such that a relying contract $\cont$ can authenticate that $X$ came from $Y$ assuming only that: (1) $\prog$ correctly retrieves and serves data and (2) The \tc server's hardware has not been tampered with. (Of course, there is also a need to trust Intel, which serves as a root of trust for SGX-enabled hosts in general.) Note that trust in $Y$ itself is orthogonal, and \tc can combine data sources according to any desired policy (e.g., majority voting across sources).

While conceptually simple, \tc presents a number of technical challenges. First, there are implementation challenges in securely interfacing enclave code with the blockchain and with data sources. Ethereum lacks native support for and therefore does not permit efficient on-chain verification of the proprietary digital signatures SGX uses to generate attestations on enclave code. Enclave code cannot directly scrape blockchain data and must instead rely on an untrusted process to retrieve correct blockchain data.\footnote{This problem cannot be solved by the obvious mechanism of digitally signing blockchain data: The blockchain is globally readable, and thus cannot store private keys, and running a blockchain client in the enclave would bloat the TCB in the enclave unacceptably.} Additionally, for enclave code to communicate securely with data sources, it must do so over HTTPS, yet enclave code in SGX does not control the host's network stack, which is instead controlled by the (potentially untrusted) OS. A second challenge is in the proofs of security for \tc. These proofs require harmonized formalism for SGX and smart contracts that existing work does not yet provide. Moreover, Ethereum requires expenditure of a currency-derived resource known as \emph{gas} to power contracts; thus proving the availability of \tc---a critical property for relying contracts---requires conventional analysis of data integrity coupled with a proof of sustainable gas expenditure. Finally, the use of \tc raises confidentiality challenges. Since blockchain state is globally readable, na\"{i}ve use of \tc would expose potentially sensitive datagram requests, e.g., an flight-insurance policy would publicly reveal the flight information of policyholders, and would render \tc vulnerable to traffic analysis on served data. Much of our contribution in the design of \tc involves addressing these challenges. 

Beyond merely serving publicly visible requests for generic data, \tc supports private datagram requests in which the request is encrypted and custom datagram requests in which the requested data comes from an access-controlled system, such as an individual user's account. Thus \tc can support a rich variety of smart contracts, as shown by our implementation of three example contracts: (1) A financial derivative (cash-settled put option) that requires stock ticker data; (2) A flight insurance contract that relies on private data requests about flight cancellations; and (3) A contract for exchanging currency in an online role playing game for ether, the Ethereum currency, using custom data requests.

In summary, our contributions are as follows:

\vspace{-1mm}
\begin{itemize}
  \setlength{\itemsep}{2pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}

\item \emph{\tcs system:} We present and describe our implementation of \tc, an authenticated data feed system that enables smart contracts to obtain datagrams safely from a target data source, specifically an existing HTTPS-enabled server. In contrast to currently available systems, \tc's assurances do not require trust in (typically fledgling) service operators, only in the underlying commodity trusted hardware, namely Intel SGX. 

\item \emph{Interfacing SGX with smart contracts:} We present solutions to the technical challenges that arise in combining two new technologies with incompatible APIs, e.g., the lack of Ethereum support for SGX attestations and the impracticality of authenticating blockchain data, and thus datagram requests, to \tc's trusted enclave program. 

\item \emph{\tc security analysis:} We present unifying formalism for the trusted hardware and smart contracts embodied in \tc and provide proofs of security, including the integrity and source authenticity of datagrams and service availability, which requires a new form of analysis of sustainable gas consumption. 

\item \emph{\tc applications:} We implement three practical smart contract applications that benefit from \tc: a financial derivative, a flight insurance contract, and a contract for exchanging online game currency and cryptocurrency. These applications showcase the rich possibilities and capabilities of \tc, including support for private and custom datagrams. 

\end{itemize}

As \tc has minimal trust assumptions and requires no modification to existing data source servers or Ethereum, we believe it offers a compelling, practical approach to bootstrapping a data feed ecosystem for smart contracts.


