% programming model
% ecall and ocall


Using the recently released Intel SGX SDK~\cite{sgxsdk}, we implmented TC Server
as an SGX-enabled application. The programming model employed by the SDK is 
that the major body of an SGX-enabled
application remains to be an ordinary C/C++ application that execuates in the
ordinary memory, while an relatively small (in terms of code complexity and
memory size) piece of security-sensitive code is loaded to an enclave. 
The enclave part can be
viewed as a shared library exposing APIs (referred to as \emph{ecalls} by the
SGX documentation) to be invoked by the untrusted application. However SGX
guarantees that once the API is invoked, the control is transferred to the 
enclave code until it finishes or some special event happens~\cite{sgxmanual}.
As we assume SGX provides a perfect isolation, the untrusted application can not
observe or alter the execution of ecalls.

As noted in Section \ref{}, an implementation challenge is that enclave program
can not access services provided by the operating system.  However the TLS layer
in the \encname relies on the TCP service to talk with web serveres. In order to
circumvent this, the SGX SDK provides a mechanism called \emph{ocall}. In
essence, calling an ocall causes the enclave program first to exit the enclave.
Once the ocall is the fulfilled, execution is transferred back to the calling
enclave.  \tc server makes extensive use of ocalls to communicate with the
\medname. 

In the context of TC Server, the enclave part implements Figure. \fan{ref to
prog}, which encompasses the implementation of a TLS layer, a partial HTTP
layer, a set of algorithms that extract information from web pages, and a
request handler that can parse and generate Ethereum transactions and sign it
properly with \skTC.  The untrusted part of TC Server implements Figure \fan{ref
to prog}, which roughly encompasses of two parts: (1) an access point to various
OS services, (2) an interface with Ethereum blockchain and (3) an interface with
clients. Figure \ref{fig:tcserver_impl} summarizes these components and their
interaction.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/impl}
    \caption{Detailed Architecture of TC Server}
    \label{fig:tcserver_impl}
\end{figure}

\subsubsection{The \medname}

\paragraph{Attestation Server.} As described in Section \ref{sec:architecture},
a client starts using \tc by requesting and verifying an attestation.  The
Attestation Server (AttServer) is the interface for doing this.  The AttServer
listens for requests and calls into the Attestation Generation logic in the
enclave (by making an ecall) to get an attestation, along with an Unix timestamp
signed by \pkTC, and forward both to the requesting client.  The EPID group
signature can verified by accessing Intel Attestation Service (IAS)~\cite{}. 

\paragraph{OS Services.} The \encname relies on \medname for networking and
time provided by the OS. We implemented wrapper functions for these OS services 
that can be invoked by the \encname as ocalls.

\paragraph{Blockchain Interface.} The \medname is responsible to watch the
blockchain for incoming requests and insert transactions to the blockchain to
deliver datagrams. To interact with the Ethereum blockchain, we incorporated an
official Ethereum client (geth~\cite{geth} in particular) into the \medname.
Geth client can be configured to setup a JSON RPC server through which the
Monitor can communicate with the blockchain indirectly by sending RPC calls to
geth. For example, to insert a signed transaction, the Monitor can simply call
\texttt{eth\_sendRawTransaction} with the bytes array of the serialized
transaction, and geth do the rest of the work. Looping an Ethereum
client into \medname saves us the cost of reinventing the wheel. 
Note that the signing of transactions is done within the enclave, as the key
\pkTC only accessible to the enclave program.

\subsubsection{The \encname}

\paragraph{HTTPS in the \encname.} 
The \encname needs the TLS layer to talk with remote HTTPS web servers.  We
ported a TLS library (mbedTLS) into the SGX environment so it can be used within
the enclave.  To verify the certificates presented by remote servers, a
collection of trusted root CAs are manually selected \xxx[Fan]{what's the best
practice? Maybe we can choose the same root CAs as Chrome or Firefox?} and their
certificates are hardcoded in the enclave program. A certificate is verified
only if it is finally issued by one of the trusted root CA.

\paragraph{Web Scrapers.} Extracting useful information from a given website is
implemented in a ad-hoc manner. For the purpose of demonstration, we implemented
three web scrapers as examples. \xxx[Fan]{Elaborate}.

\paragraph{Request Handler} Request handler has two jobs: 1) to parse the
request is serialized in the form of Ethereum ABI, decrypt it if encrypted under
\pkTC, and dispatch it to the right scraper; 2) to generate a Ethereum
transaction, sign it with \pkTC and serialize it properly so that it can be
inserted to the blockchain. In essence, we implemented Ethereum ABI and RLP which
is use to serialize arguments and transactions respectively.
In addition, the signature algorithm used in signing Ethereum transactions is
ECDSA on the curve Secp256k1. SHA3 is used.

\paragraph{Attestation Generation} The same with Attestation Server.\xxx[Fan]{Elaborate.}
\paragraph{Key Management} \xxx[Fan]{TBD.}
