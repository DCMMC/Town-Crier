% programming model
% ecall and ocall


Using the recently released Intel SGX SDK~\cite{sgxsdk}, we implmented the \tc
Server as an SGX-enabled application in C++. In the programming model supported
by the SGX SDK, the body of an SGX-enabled application runs as an ordinary
user-space application, while a relatively small piece of security-sensitive
code runs in the isolated environment of the SGX enclave.

The enclave portion of an SGX-enabled application may be viewed as a shared
library exposing an API in the form of \emph{ecalls} to be invoked by the
untrusted application. Invocation of an ecall transfers control to the enclave;
the enclave code runs until it either terminates and explicitly releases
control, or some special event (e.g., exception) happens~\cite{sgxmanual}.
Again, as we assume SGX provides ideal isolation, the untrusted application
cannot observe or alter the execution of ecalls.

Enclave programs can make \emph{ocalls} to invoke functions defined outside of
the enclave. An ocall triggers an exit from the enclave; control is returned
once the ocall completes. As ocalls execute outside the enclave, they must be
treated by enclave code as untrusted. 


\usetikzlibrary{matrix,positioning, shapes, calc, backgrounds, fit}
\tikzset{
 box/.style = {
    shape = rectangle,
    align = center,
    draw  = black,
    text width=1.5cm,
    inner sep=5pt,
},
double/.style = {
	rectangle split,
	rectangle split parts=2},
every path/.style = {
	>=latex,},
}
\begin{figure}[h]
    \centering
%    \includegraphics[width=0.45\textwidth]{figures/impl}

\begin{tikzpicture}
\matrix (m) [row sep=5mm, column sep=3mm]{
	\node[inner sep=0pt] (user) {\includegraphics[width=1cm]{figures/user}}; &
    \node[inner sep=0pt,draw,cloud,aspect=2.0,align=center](cloud) {\footnotesize HTTPS \\ websites}; &
    \node[box, cylinder, shape border rotate=90, aspect=.2](bc){blockchain};  \\
    
    \node[box,fill=white] (client) {Client \\ Interface}; & 
    \node[box,fill=white] (net) {TCP}; & 
    \node[box,fill=white,double,text width=2cm] (monitor) {\texttt{geth} \nodepart{second}{Blockchain \\ Interface}}; \\

    \node[box,trusted] (att) {Attestation \\ Generation}; &
    \node[box,double,trusted] (https) {HTTPS \nodepart{second}{Web \\ Scrapers}}; &
    \node[box,double,trusted,text width=2cm,] (req h){\small Etheruem TX \\ Reader/Writer
      \nodepart{second}{\small Request Handler}}; \\
    
    \node[xshift=-5mm] (sk) {\sksgx}; &  \node[box,text width=2cm] (keys) {\pkTC, \skTC}; & \\
};

\draw[<->,thick] (user) -- (client);
\draw[<->,thick] (net) -- (cloud);
\draw[<->,thick] (monitor) -- (bc);

\draw[->,blue,thick,transform canvas={xshift=-2mm}] (https) to (net);
\draw[->,blue,thick,dashed,transform canvas={xshift=+2mm}] (net) to (https);

\draw[->,red,thick,transform canvas={xshift=-2mm}] (client) -- (att);
\draw[<-,red,thick,dashed,transform canvas={xshift=+2mm}] (client) -- (att);

\draw[->,red,thick,transform canvas={xshift=-2mm}] (monitor) -- (req h);
\draw[<-,red,thick,dashed,transform canvas={xshift=+2mm}] (monitor) -- (req h);

\draw[<->,thick] (https.two east) -- (https.two east -| req h.two west);

\draw[->,thick] (req h.south) |- (keys.east);
\draw[->,thick] ($ (att.south) + (5mm,0) $)  |- (keys.west);
\draw[->,thick] ($ (att.south) - (5mm,0) $)  -- (sk);

\begin{scope}[on background layer]
\node [inner xsep=2mm, fill=red!30,fit=(client) (net) (monitor) ] {};
\node [inner xsep=2mm, trusted,fit=(att) (https) (req h) (keys) ] {};
\end{scope}

\matrix [below=2mm of m, matrix of nodes, column sep=2mm] 
{
  {\bf keys:} & |[fill=red!30]| \medname & |[trusted]| \encname & 
  |(t1) []| {} &&& 
  |(u1) []| {} &
  |(u2) []| {} &&&
  |(t2) []| {} \\
};

\draw[->,red,transform canvas={yshift=+0.5mm}] (t1) to node[above] {ocall} (u1);
\draw[<-,red,dashed,transform canvas={yshift=-0.5mm}] (t1) to (u1);

\draw[->,blue,transform canvas={yshift=+0.5mm}] (u2) to node[above] {ecall} (t2);
\draw[<-,blue,dashed,transform canvas={yshift=-0.5mm}] (u2) to (t2);
%    	\node (keys) {\bf keys:};
%    	\node[fill=red!30,right=2mm of keys] (key-relay) {\medname};
%    	\node[fill=green!30, right=2mm of key-relay] (key-enc) {\encname};
%        \node[trusted,minimum width=2mm] (source);
%		
%		\draw[->,blue] ($ (key-enc.east) + (14mm, 0) $) to node[above]{ecall} ($ (key-enc.east) + (20mm, 0) $);
%		\draw[<-,blue,dashed,transform canvas={yshift=-1.5mm}] ($ (key-enc.east) + (14mm, 0) $) to ($ (key-enc.east) + (20mm, 0) $);
\end{tikzpicture}
\caption{Components of \tc Server}
\label{fig:tcserver_impl}
\end{figure}

For \tc, we recall that Fig.~\ref{fig:engineprotocol} shows the \encname code
$\engine$. Fig.~\ref{fig:relayprotocol} specifies the operation of the \medname,
the untrusted code in \tc, which we emphasize again provides essentially only
network functionality. We now give details on the services in the \encname and
the \medname and describe their interaction, as summarized in
Fig.~\ref{fig:tcserver_impl}.

\paragraph{\bf The \encname.} There are three components to the enclave code
\engine: An HTTPS service, Web Scrapers, which interact with data sources, and a
Request Handler, which services datagram requests. 

\vspace{2mm}

\noindent\emph{HTTPS Service.} We recall that the enclave does not have direct
access to host network functionality. \tc thus partitions HTTPS into a trusted
layer, consisting of HTTP and TLS code, and an untrusted layer that provides
low-layer network service, specifically TCP.  This arrangement allows the
enclave to establish a secure channel with a web server: The enclave itself
performs the TLS handshake with a target server and performs all cryptographic
operations internally, while the untrusted process acts as a network interface
only. We ported a TLS library (mbedTLS) into the SGX environment, as well as
HTTP code, which we minimized to meet the web-scraping requirements of \tc while
keeping the TCB small. To verify certificates presented by remote servers, we
hardcoded a collection of root CA certificates into the enclave code; in the
first version of \tc, the root CAs are identical to those in Chrome~\cite{}. By using its internal, trusted wall-clock time, it is possible to verify that a certificate has not expired. (We briefly discuss revocation in Appendix~\ref{sec:future}.)

\vspace{2mm}

\noindent\emph{Web Scrapers.} Extracting useful information from a given website
is implemented in a ad-hoc manner. For the purpose of demonstration, we
implemented three web scrapers as examples. \xxx[Fan]{Elaborate}.

\vspace{2mm}

\noindent\emph{Request Handler.} The Request Handler has two jobs: (1) Ingesting
a datagram request by parsing it in the serialization format specified by
Ethereum, decrypting it (if it's a private-datagram request), and dispatching
its parameters to the right scraper; and (2) Returning the response to the
request by generating an Ethereum transaction containing the requested datagram
(and parameters), serializing it as a blockchain transaction, and signing it
using \skTC. We implemented the Ethereum ABI and RLP, which respectively specify
the serialization of arguments and transactions in Ethereum. 

\vspace{2mm}

\noindent\emph{Attestation Generation.} Recall in Section \ref{sec:background}
we mentioned that an \emph{attestation} is an \emph{report} digitally signed by
the Intel-provided Quoting Enclave (QE).  Therefore two phases are involved in
generating \att. First, the \encname calls \texttt{sgx\_create\_report} to
generate a report with QE as the target enclave. Then the \medname forwards the
report to QE and calls \texttt{sgx\_get\_quote} to get a signed version of the
report, namely an attestation.

\paragraph{The \medname.} The \medname encompasses three components: A Client Interface, which serves attestations and timestamps, OS services, including networking and time services, and a Blockchain Interface. 

\vspace{2mm}

\noindent\emph{Client Interface.} As described in Section \ref{sec:architecture},
a client starts using \tc by requesting and verifying an attestation \att and checking the correctness of the clock in the \tc enclave using a fresh timestamp.
The Client Interface caches \att upon initialization of \engine. When it receives a web request from a client for an attestation,
it issues an ecall to the enclave to obtain a
Unix timestamp signed using \skTC, which it returns to the client along with \att. The client verify \att 
using the Intel Attestation Service (IAS)~\cite{} and then verify the timestamp using $\pkTC$ and check it using any trustworthy time service. 

\vspace{2mm}

\noindent\emph{OS services.} The \encname relies on the \medname to access networking and 
wall-clock time provided by the OS and implemented as ocalls.

\vspace{2mm}

\noindent\emph{Blockchain Interface.} The \medname's Blockchain Interface monitors the
blockchain for incoming requests and places transactions on the blockchain in order to
deliver datagrams. The Blockchain Interface incorporates an 
official Ethereum client, Geth~\cite{geth}. This Geth client can be configured with a JSON RPC server.  
The \medname  communicates with the blockchain indirectly via RPC calls to this server. For example, to insert a signed transaction, the \medname simply calls
\texttt{eth\_sendRawTransaction} with the byte array of the serialized
transaction. We emphasize that as the enclave holds \skTC, transactions are signed within the enclave.


