\section{Applications: Requesting Contracts}

\paragraph{Financial Derivatives.}  In order to implement a financial derivative as a smart contract, we require information about the corresponding financial instrument upon which the derivative depends (typically a stock).  As an example, we implemented a cash-settled put option.  The issuer of the option creates a contract for a particular stock, strike price, time period, unit price, and the maximum number of units he is willing to sell.  Customers may purchase the option by sending requests to the contract along with the associated fee indicating the number of units of the option they would like to buy.  Until the expiration date, customers may choose to exercise the put option by making another request to the option contract.  The contract then requests that TC retrieve the closing price of the underlying instrument on the day the option was exercised, and pays out to the customer the difference between the strike price and the closing price for each unit of the option purchased.  To ensure the contract always has sufficient funds to pay out, it must control value of at least the strike price times the maximum number of units sold.

\paragraph{Flight insurance.} Flight insurance, which provides a payout to the purchaser in the event that their flight is delayed or canceled, is a particularly interesting application of smart contracts as it requires  the transmission of data that the customer may wish to keep private, such as the flight number, via the blockchain.  In order to maintain data privacy, TC supports encrypted datagram requests in which customers encrypt sensitive query information under a public key held by the \encname prior to publicly posting it to the blockchain.  \encname code is then responsible for decrypting and carrying out the query and passing a result back to the requesting contract stripped of private information.  

In the case of the flight insurance contract we implemented, an insurance provider creates an insurance contract with a specified fee and payout in ether that serves up to $2^{64}$ requests.  A customer who wishes to buy insurance for his flight first encrypts the ICAO flight number and scheduled time of departure for his flight, and attaches the ciphertext to a transaction he submits to the insurance contract.  If the transaction has value in ether equivalent to the fee, the contract logs the request and submits the provided ciphertext as a request to TC.  \encname code then decrypts and processes the request, determines if the specified flight was delayed or canceled, and returns a response to the insurance contract indicating whether or not the contract should pay out for a particular request.  Note that there is no flight information contained in this response.

However, the publicly visible outcome of the contract may leak information about which flight a particular customer was on, especially if the customer received a payout for flight cancellation.  An adversary attempting to compromise privacy may then narrow his search to a list of recently canceled flights.  This can be partially solved by including two encrypted addresses in the request, one owned by the customer and one owned by the insurance provider.  The \encname passes back to the requesting contract the customer-owned address if the flight is canceled, and the provider-owned address otherwise.  The contract then makes the payout to the returned address, and the adversary gains no new information from the payment so long as he cannot distinguish between the two addresses.

\paragraph{Steam Marketplace.} Steam \kyle{reference?} is an online gaming platform that supports thousands of games and maintains its own marketplace, where users can trade, buy, and sell games and other virtual items.  Through the Steam trading API, for which a key is issued to each user, we can construct a contract that implements the sale of games and items for ether using custom datagrams.  A user wishing to sell items creates a contract specifying the items to be sold along with a price in ether for each.  A user wishing to buy the items creates a Steam trade offer requesting the items (which the seller must accept out of band through either a Steam client or the Steam API), and then submits an Ethereum transaction with value in ether equal to the specified price along with an attached ciphertext containing a reference to the trade offer and his Steam API key.  The API key of either the buyer or the seller is required in order to view the contents of the trade.  The contract submits a request to TC using the provided ciphertext, and relies on TC to verify the contents and status of the trade and return the result.  If the trade was successfully accepted by the seller and the items transferred to the buyer, then the contract transfers the buyer's ether to the seller's account.  Otherwise if the trade is unsuccessful, the buyer's ether is refunded by the contract.

There is a clear parallel between the exchange of virtual goods for ether and the exchange of fiat currency for ether.  The contract remains mostly the same; virtual goods are simply replaced with dollars and the Steam API is substituted out for a (preferably read-only) API for a user's bank statements.  In both cases, the \encname must be trusted not to compromise the user's privacy (or worse if the provided API keys have additional privileges) when given access to their account statements.

%Discuss flight insurance as an example: We'd like to conceal the flight number and date. We might also want to conceal payment, so TC might ingest encrypted addresses and mix them internally.

%Micro-loans too? Linkage to Facebook / Keybase.io

