
\section{Proofs of Security Analysis}
\label{sec:analysis-proofs}

This section contains the proofs of the theorems we stated in Section~\ref{sec:analysis}


\begin{proof}[Authenticity (sketch)]
We show that if the 
adversary $\algA$ succeeds in a forgery with non-negligible probability,
we can construct an adversary $\algB$ that can either
break $\sigsgx$ or $\Sigma$ with non-neligible probability.
We consider two cases. 
The reduction $\algB$ will flip a random coin to guess which
case it is, and if the guess is wrong, simply abort.
\begin{itemize}[leftmargin=5mm]
\item
Case 1: $\algA$ outputs a signature $\sigma$ that uses the same  
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will try to break $\Sigma$. 
$\algB$ interacts with a signature challenger ${\sf Ch}$ who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates 
$\fsgx$ by implicitly letting $\pksgx := \pk^*$.
Whenever $\fsgx$ needs to sign a query, $\algB$ passes the signing query
onto the signature challenger ${\sf Ch}$.

Since ${\sf data} \neq \enclaveprog({\sf params})$,
$\algB$ cannot have queried ${\sf Ch}$  
on a tuple of the form $(\_, {\sf params}, {\sf data})$. 
Therefore, $\algB$ simply outputs 
what $\algA$ 
outputs (suppressing unnecessary terms) as the signature forgery. 

\item
Case 2:
 $\algA$ outputs a signature $\sigma$ that uses a different 
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will seek to break $\sigsgx$.
$\algB$ interacts with a signature challenger ${\sf Ch}$, who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates $\fsgx$ by implicitly setting
$\pkM := \pk^*$.
Whenever $\fsgx$ needs to make a signature
with $\skM$, 
$\algB$ simply passes the signature query onto ${\sf Ch}$.
In this case, in order for $\algA$ to succeed,
it must produce a valid signature $\sigatt$ 
for a different public key $\pk'$.
Therefore, $\algB$ simply outputs this as a signature forgery.
\end{itemize}
\end{proof}


\begin{proof}[Proof of Gas neutrality for Town Crier (sketch)]
By assumption, $\tcadd$ is seeded with at least $\constgasmax$ money.
Thus it suffices to prove that, given an honest \medname, $\tcadd$ will have at least as much money after invoking {\bf Deliver} as it did before.

The enclave will never submit a response for the same $\dgid$ more than once.
{\bf Deliver} only responds to messages from $\tcadd$, and ${\sf isDelivered}[\dgid]$ is only set inside {\bf Deliver},
so therefore we know that ${\sf isDelivered}[\dgid]$ is not set for this $\dgid$.
We now consider the case where ${\sf isCanceled}[\dgid]$ is set upon invocation of {\bf Deliver} and the case where it is not.
\begin{itemize}

\item {\it ${\sf isCanceled}[\dgid]$ not set:}
In this case the predicate on line $(1)$ of the protocol returns {\tt false}.
Because the \medname is honest, $\dgid$ exists and $\dgform = \dgform'$.
The enclave always provides $\gasdeliver = \constgasmax$ (which it has by assumption) and {\bf Request} ensures that $\fee \leq \constgasmax$.
Thus, coupled with the knowledge that ${\sf isDeliver}[\dgid]$ is not set, all assertions pass and we progress through lines $(3)$ and $(4)$.
Now we must show that at line $(3)$ $\tcont$ had $\fee$ to send and that the total gas spend to execute {\bf Deliver} does not exceed $\fee$.

To see that $\tcont$ had sufficient funds, we note that upon entry to {\bf Deliver}, both ${\sf isDelivered}[\dgid]$ and ${\sf isCanceled}[\dgid]$ must have been unset.
The first because the enclave will not attempt to deliver the same $\dgid$ more than once and ${\sf isDeliver}$ is only set in {\bf Deliver} for the $\dgid$ being delivered.
The second because, given the first, if ${\sf isCanceled}[\dgid]$ were set, the predicate on line $(1)$ would have returned true, thus sending execution on a path that would not encounter $(4)$.
This means that line $(5)$ was never reached because the preceding line sets ${\sf isCanceled}[\dgid]$.
Because $(2)$, $(3)$, and $(5)$ are the only lines that remove money from $\tcont$ and $\fee$ was deposited as part of {\bf Request},
it must be the case that $\fee$ is still in the contract.

To see how much gas is spent, we first note that $\constgasmin$ is defined to be the amount of gas needed to execute {\bf Deliver} along this execution path not including line $(4)$.
Since $\gascallback$ is set to $\fee - \constgasmin$ and line $(4)$ is limited to using $\gascallback$ gas,
the total gas spent on this execution of {\bf Deliver} is at most $\constgasmin + (\fee - \constgasmin) = \fee$.


\item {\it ${\sf isCanceled}[\dgid]$ is set:}
Here the predicate on line $(1)$ returns {\tt true}.
Along this execution path $\tcont$ sends $\tcadd$ $\constgascancel$ and quickly returns.
$\constgascancel$ is defined as the amount of gas necessary to execute this execution path,
so we need only show that $\tcont$ has $\constgascancel$ available to send.

Because ${\sf isCanceled}[\dgid]$ is set, it must be the case that {\sf Cancel} was invoked with $\dgid$ and reached line $(5)$.
Gas exhaustion in {\sf Cancel} is not a concern because it would abort and revert the entire invocation.
This is only possible if the data retrieval and all assertions in {\sf Cancel} succeed.
In particular, this means that $\dgid$ corresponds to a valid request which deposited $\fee$.
Line $(5)$ returns $\fee - \constgascancel$ to $\reqcont$, but it leaves $\constgasmin$ from the original $\fee$.
Moreover, if {\bf Cancel} is invoked multiple times with the same $\dgid$, all but the first will fail due to the assert that ${\sf isCanceled}[\dgid]$ is not set
and the fact that any invocation that reaches $(5)$ will set ${\sf isCanceled}$ for that $\dgid$.
Since only lines $(2)$, $(3)$, and $(5)$ can remove money from $\tcont$ and line $(3)$ will never be called in this case,
there will still be exactly $\constgasmin$ available when this invocation of {\bf Deliver} reaches line $(2)$.

\end{itemize}
\end{proof}





\begin{proof}[Proof of Fair Expenditure for Honest Requester (sketch)]
$\reqcont$ is honest, so she will spend $\constgasrequest$ to invoke {\bf Request}$(\dgform, \dgcallback, \consthonestfee)$.
Ethereum does not allow money to change hands without the payer explicitly sending money.
Therefore we must only examine the explicit function invocations and monetary transfers initiated by $\reqcont$ in connection with the request.
It is impossible for $\reqcont$ to lose more money than she gives up in these transactions even if \tc is malicious.

\begin{itemize}
\item {\it Request Delivered:}
If protocol line $(4)$ is reached, then we are guaranteed that $\dgform = \dgform'$ and $\gasdeliver \geq \consthonestfee$.
By Theorem~\ref{thm:authenticity}, the datagram must therefore be authentic for $\dgform$.
Because $\consthonestfee$ is chosen honestly for $\dgcallback$, $\consthonestfee - \constgasmin$ is enough gas to execute $\dgcallback$,
so $\dgcallback$ will be invoked with a datagram that is a valid and matches the request parameters.

In this case, the honest requester will have spent $\constgasrequest$ to invoke {\bf Request} and $\consthonestfee$ in paying \tc's cost for {\bf Deliver}.
The requester may have also invoked {\bf Cancel} at most once at the cost of $\constgasinvokecancel$.
While $\reqcont$ may not receive any refund due to {\bf Cancel} aborting, $\reqcont$ will still have spent at most $\constgasrequest + \constgasinvokecancel + \consthonestfee$.


\item {\it Request not Delivered:}
The request not being delivered means that line $(4)$ is never reached.
This can only happen if {\bf Deliver} is never called with a valid response or if ${\sf isCanceled}[\dgid]$ is set before deliver is called.
The only way to set ${\sf isCanceled}[\dgid]$ is for $\reqcont$ to invoke {\bf Cancel} with ${\sf isDelivered}[\dgid]$ not set.
If deliver is not executed, we assume that an honest requester will eventually invoke {\bf Cancel}, so this case will always reach line $(5)$.
When line $(5)$ is reached, then $\reqcont$ will have spent $\constgasrequest + \consthonestfee$ while executing {\bf Request},
and spent $\constgasinvokecancel$ in {\bf Cancel} and will attempt to retrieve $\consthonestfee - \constgascancel$.

The retrieval will succeed because $\tcont$ will always have the funds to send $\reqcont$ $\consthonestfee - \constgascancel$.
Since line $(5)$ is reached, it must be the case the ${\sf isDelivered}[\dgid]$ is not set.
This means that neither lines $(2)$ nor $(3)$ were reached since the line before each sets ${\sf isDelivered}[\dgid]$.
The lines preceding those two and $(5)$ are the only lines that remove money from the contract.
Line $(5)$ cannot have been reached before because $\reqcont$ is assumed to be honest, so she will not invoke {\bf Cancel} twice for the same request
and if any other user invokes {\bf Cancel} for this request, the $\reqcont = \reqcont'$ assertion will fail and the invocation will abort before line $(5)$.
Because none of $(2)$, $(3)$, or $(5)$ has been reached before and $\reqcont$ deposited $\consthonestfee > \constgasmin > \constgascancel$ on {\bf Request},
it must be the case that $\tcont$ has $\consthonestfee - \constgascancel$ left.

This means the total expenditure in this case will be
\begin{align*}
  \constgasrequest + \constgasinvokecancel & + \consthonestfee - (\consthonestfee - \constgascancel) \\
                                           & = \constgasrequest + \constgasinvokecancel + \constgascancel.
\end{align*}
\end{itemize}
\end{proof}

