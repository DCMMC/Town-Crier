
\section{Proofs of Security Analysis}
\label{sec:analysis-proofs}

This section contains the proofs of the theorems we stated in Section~\ref{sec:analysis}


\begin{proof}[Authenticity (sketch)]
We show that if the 
adversary $\algA$ succeeds in a forgery with non-negligible probability,
we can construct an adversary $\algB$ that can either
break $\sigsgx$ or $\Sigma$ with non-neligible probability.
We consider two cases. 
The reduction $\algB$ will flip a random coin to guess which
case it is, and if the guess is wrong, simply abort.
\begin{itemize}[leftmargin=5mm]
\item
Case 1: $\algA$ outputs a signature $\sigma$ that uses the same  
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will try to break $\Sigma$. 
$\algB$ interacts with a signature challenger ${\sf Ch}$ who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates 
$\fsgx$ by implicitly letting $\pksgx := \pk^*$.
Whenever $\fsgx$ needs to sign a query, $\algB$ passes the signing query
onto the signature challenger ${\sf Ch}$.

Since ${\sf data} \neq \enclaveprog({\sf params})$,
$\algB$ cannot have queried ${\sf Ch}$  
on a tuple of the form $(\_, {\sf params}, {\sf data})$. 
Therefore, $\algB$ simply outputs 
what $\algA$ 
outputs (suppressing unnecessary terms) as the signature forgery. 

\item
Case 2:
 $\algA$ outputs a signature $\sigma$ that uses a different 
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will seek to break $\sigsgx$.
$\algB$ interacts with a signature challenger ${\sf Ch}$, who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates $\fsgx$ by implicitly setting
$\pkM := \pk^*$.
Whenever $\fsgx$ needs to make a signature
with $\skM$, 
$\algB$ simply passes the signature query onto ${\sf Ch}$.
In this case, in order for $\algA$ to succeed,
it must produce a valid signature $\sigatt$ 
for a different public key $\pk'$.
Therefore, $\algB$ simply outputs this as a signature forgery.
\end{itemize}
\end{proof}


\begin{proof}[Proof of Gas neutrality for Town Crier (sketch)]
\ethan{This needs to be redone more formally to include references to specific lines in the protocol and what they mean.
I'm going to work on that soon (probably after I eat some food...I'm hungry.}
%Honest relay means $\resumecall(\dgid, \dgform)$ will always be legitimate and $\dgform = \dgform'$ in {\bf Deliver}.
%While $\fee$ is specified by a potentially malicious user, \tcont rejects the request unless $\constgasmin \leq \fee \leq \constgasmax$.
%This means $\gasdeliver = \constgasmax \geq \fee$.
%We also will never respond to the same request twice (these are specified in the enclave protocol).
%This means that ${\sf isDelievered}[\dgid]$ will always be unset and we will always successfully retrieve a stored tuple and not abort.
%From here we consider two cases.
%
%\paragraph{Deliver called before Cancel.}
%In this case {\bf Deliver} calls $\dgcallback$ with a gas limit $\gascallback$ of $\fee - \constgasmin$ (which must be positive because of the check in {\bf Request}).
%$\constgasmin$ is set so that it is no less than the gas cost of {\bf Deliver} not including $\dgcallback$.
%That means that the total gas spent for {\bf Deliver} will be no greater than $\constgasmin + (\fee - \constgasmin) = \fee$, which is exactly what $\tcadd$ is sent for reimbursement.
%Moreover, the gas limit provided to {\bf Deliver} must be high enough because $\fee \leq \constgasmax = \gasdeliver$, so we cannot run out of gas.
%Finally, because $\fee$ was deposited with {\bf Request} and neither {\bf Deliver} nor {\bf Cancel} have been called before for this request, there must be at least $\fee$ stored $\tcont$.
%
%\paragraph{Deliver called after Cancel.}
%In this case $\tcadd$ is sent $\constgascancel$ and performs only operations of known cost.
%Because $\constgascancel$ is explicitly set to be the cost of those operations, this reimburses $\tcadd$ properly.
%Since $\fee$ was deposited with {\bf Request}, the first call to {\bf Cancel} leaves $\constgasmax$ associated with that request and subsequent calls do nothing,
%and {\bf Deliver} has not been called before for this request, there must be at least $\constgasmax$ left in $\tcont$ to send.
\end{proof}





\begin{proof}[Proof of Fair Expenditure for Honest Requester (sketch)]
An honest requester $\reqcont$ will spend $\gasrequest$ to call {\bf Request}
and set $\fee$ to be $\constgasmin$ plus the gas cost of executing $\dgcallback$.

\paragraph{Request Delivered.}
If the line marked $(\dagger)$ in Fig.~\ref{tbl:gas-tc-contract} is reached,
then we are guaranteed that $\dgform = \dgform'$ and $\gasdeliver \geq \fee$.
Because the requester is honest, $\fee - \constgasmin$ is enough gas to execut $\dgcallback$,
so $\dgcallback$ will be invoked with a datagram that is a valid and matches the request parameters.

In this case, the honest requester will have spent $\gasrequest$ to invoke {\bf Request} and $\fee$ in paying \tc's cost for {\bf Deliver}.
The requester may have also invoked {\bf Cancel} at most once at the cost of $\gascancel$,
though if $(\dagger)$ has already been reached, then an assertion will fail and $\reqcont$ will receive nothing from the call.
This means that, in this case, $\reqcont$ will spend at most $\gasrequest + \gascancel + \fee$.


\paragraph{Request not Delivered.}
If the line marked $(\ddagger)$ is reached, then $\reqcont$ will have spent
$\gasrequest + \fee$ while executing {\bf Request},
and spent $\gascancel$ and retrieved $\fee - \constgascancel$ while executing {\bf Cancel}.
This means the total expenditure in this case will be
\begin{align*}
  \gasrequest + \gascancel & + \fee - (\fee - \constgascancel) \\
                           & = \gasrequest + \gascancel + \constgascancel.
\end{align*}
\end{proof}

