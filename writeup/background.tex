\section{Background}
\subsection{SGX}
Intel's Software Guard Extensions (SGX) is a set of new instructions that confer hardware protections on user-level code. Its goal is to provide \emph{isolated execution}. SGX enables a process to execute in a protected address space known as an {\em enclave}. It protects the confidentiality and integrity of a process in an enclave from other software on the same host, including the operating system, as well as from certain forms of hardware attack, such as memory probes. 

A enclave process cannot make system calls, nor can it execute code outside the enclave region. As a means of communicating with processes outside the enclave, however, it can read and write memory outside the enclave region, consistent with OS setting of page permissions. Thus  isolated execution in SGX may be viewed in terms of an ideal model in which a process is guaranteed to execute correctly and with perfect confidentiality, but relies on a (potentially malicious) operating system for network and file-system access. This model is a simplification, as SGX is known to expose some of the internal state of an enclave to the operating system (e.g., making page faults visible to the exception handler~\cite{}), creating potential side-channel vulnerabilities. Nonetheless, in this paper, we assume the ideal model described above for isolated execution in SGX.

Another feature of SGX is its support for \emph{attestation}, which allows a remote system to verify the software in an enclave and communicate securely with it. When an enclave is created, the CPU produces a hash of its initial state known as a {\em measurement}. The software in the enclave may at a later time request a report, which includes a measurement and any supplementary data provided by the process, such as a public key. This report may be digitally signed (by a trusted process called a ``quoting enclave'') using a hardware-protected key to produce a proof that the measured software is running in an SGX-protected enclave. This proof, known as a {\em quote}, may be verified by a remote system. The associated public key can then be used to establish a secure channel with the enclave or verify signed data it emits. We use the generic term {\em attestation} to refer to a quote, and denote it by \att. We assume that a trustworthy measurement of the code for the enclave component of \tc is available to any client that wishes to verify an attestation.

SGX additionally provides a trusted time source via the function \texttt{sgx\_get\_trusted\_time}.~On invoking \texttt{sgx\_get\_trusted\_time}, an enclave obtains a measure of time relative to a reference point labeled with a nonce. This reference point remains stable for a given nonce, but SGX does not provide a source of absolute or wall-clock time, a limitation that we must engineer around in \tc.

\subsection{HTTPS}
\subsection{Smart contracts}

Smart contracts are the expression of contractual agreements, including financial instruments, as executable code. In the context of cryptocurrencies, the term refers specifically to autonomously executing scripts that reside on a blockchain and can manipulate control currency. Bitcoin has a scripting language that can serve to implement a limited form of smart contract, but it is not Turing-complete and lacks support for loops. 

Ethereum is the first decentralized blockchain with a Turing-complete scripting language and thus full support for smart contracts. Other Turing-complete smart contract systems exist, such as Counterparty~\cite{}, which runs as a Bitcoin overlay, but is not fully decentralized. Ethereum has its own associated cryptocurrency called \emph{ether}. (At the time of writing, 1 ether has a market value of a little more than \$2 U.S.) While \tc can be adapted in principle to any smart contract system, we report on an implementation directed at Ethereum.

A smart contract in Ethereum is represented as what is called a \emph{contract account}, endowed with code, a currency balance, and persistent memory in the form of a key/value store. Contract code executes in response to receipt of a \emph{message} from another contract or a \emph{transaction} from a non-contract (\emph{externally owned}) account. Thus, contract execution is always ultimately initiated by a transaction. Informally, a contract only executes when ``poked,'' and poking progresses through a sequence of entry points until no further message passing occurs (or until there is a shortfall in gas, as explained below).

A smart contract accepts messages as inputs to any of a number of designated functions. These entry points are determined by the contract creator and represent the API of the contract. Once created, a contract executes autonomously; it persists indefinitely, with even its creator unable to modify its code. (There's one exception: a special opcode \texttt{suicide} will wipe code from a contract account.) As a simple abstraction, then, a smart contract may be viewed as an {\em autonomous agent} on the blockchain. 

To prevent denial-of-service attacks or inadvertent infinite looping within contracts and in general to control resource expenditure by the network, Ethereum implements uses a resource called \emph{gas} to power contracts. Opcodes in smart contracts have globally specified, fixed gas costs, as do the use of a contract's persistent storage and the data in transactions and messages. Transactions and messages include a parameter (\texttt{STARTGAS}) specifying a bound on amount of gas expended by the computations they initiate. Gas is carried along the execution path induced when a transaction or message is passed to a contract, and depleted as instructions are executed or reads or writes are made to persistent storage. Should a function fail to complete due to a shortfall in gas, it is aborted and any state changes induced by the partial computation are rolled back to their pre-call state; previous computations along the call path, however, are retained. 

Along with the \texttt{STARTGAS} parameter, a \texttt{GASPRICE} parameter is included that specifies the maximum amount in ether that the transaction is willing to pay per unit of gas. The transaction thus succeeds only if the initiating account has a balance of \texttt{STARTGAS} $\times$ \texttt{GASPRICE} ether and \texttt{GASPRICE} is high enough to be accepted by the system (miner). 

The management of gas, as we show in our design of \tcs can be delicate. Without careful construction, for example, the smart contracts representing \tc's interface on the Ethereum blockchain can be caused by an attacker to exhaust the ether used to power the delivery of datagrams. 

\subsection{Applications of ADFs for smart contracts}
\subsection{Basic terminology}
We refer to a {\em smart contract} making use of the \tcs service as a \emph{relying contract}. In contexts where a relying contract has issued to \tc a service request for a datagram, we call it a \emph{requester}. We denote a requester by \reqcont. A party (or would-be party) to a relying contract, a person, organization, or server, is a \emph{client}. Relying contracts---and requesters, by extension---are blockchain entities, while a client is an off-chain entity. A \emph{data source}, or \emph{source} for short, is an online server (running HTTPS) that provides data which \tc uses to compose datagrams.


