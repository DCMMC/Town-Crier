\section{Background}
\subsection{SGX}
Intel's Software Guard Extensions (SGX) is a set of new instructions that confer hardware protections on user-level code. Its goal is to provide \emph{isolated execution}. SGX enables a process to execute in a protected address space known as an {\em enclave}. It protects the confidentiality and integrity of a process in an enclave from other software on the same host, including the operating system, as well as from certain forms of hardware attack, such as memory probes. 

A enclave process cannot make system calls, nor can it execute code outside the enclave region. As a means of communicating with processes outside the enclave, however, it can read and write memory outside the enclave region, consistent with OS setting of page permissions. Thus  isolated execution in SGX may be viewed in terms of an ideal model in which a process is guaranteed to execute correctly and with perfect confidentiality, but relies on a (potentially malicious) operating system for network and file-system access. This model is a simplification, as SGX is known to expose some of the internal state of an enclave to the operating system (e.g., making page faults visible to the exception handler~\cite{}), creating potential side-channel vulnerabilities. Nonetheless, in this paper, we assume the ideal model described above for isolated execution in SGX.

Another feature of SGX is its support for \emph{attestation}, which allows a remote system to verify the software in an enclave and communicate securely with it. When an enclave is created, the CPU produces a hash of its initial state known as a {\em measurement}. The software in the enclave may at a later time request a report, which includes a measurement and any supplementary data provided by the process, such as a public key. This report may be digitally signed (by a trusted process called a ``quoting enclave'') using a hardware-protected key to produce a proof that the measured software is running in an SGX-protected enclave. This proof, known as a {\em quote}, may be verified by a remote system. The associated public key can then be used to establish a secure channel with the enclave or verify signed data it emits. We use the generic term {\em attestation} to refer to a quote, and denote it by \att. We assume that a trustworthy measurement of the code for the enclave component of \tc is available to any client that wishes to verify an attestation.

SGX additionally provides a trusted time source via the function \texttt{sgx\_get\_trusted\_time}.~On invoking \texttt{sgx\_get\_trusted\_time}, an enclave obtains a measure of time relative to a reference point labeled with a nonce. This reference point remains stable for a given nonce, but SGX does not provide a source of absolute or wall-clock time, a limitation that we must engineer around in \tc.

\subsection{HTTPS}
\subsection{Smart contracts}

\elaine{things like on-chain cost and gas should be mentioned}
\subsection{Applications of ADFs for smart contracts}
\subsection{Basic terminology}
We refer to a {\em smart contract} making use of the \tcs service as a \emph{relying contract}. In contexts where a relying contract has issued to \tc a service request for a datagram, we call it a \emph{requester}. We denote a requester by \reqcont. A party (or would-be party) to a relying contract, a person, organization, or server, is a \emph{client}. Relying contracts---and requesters, by extension---are blockchain entities, while a client is an off-chain entity. A \emph{data source}, or \emph{source} for short, is an online server (running HTTPS) that provides data which \tc uses to compose datagrams.


