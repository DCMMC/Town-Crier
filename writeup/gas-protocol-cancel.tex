
To sustainably operate \tc on Ethereum, and address the concern of attacks on fee management, we employ a novel two-currency resource management system in \tc. This system causes
requesters to make gas payments up front as ether. It converts ether to gas so as to prevent a malicious requester from exhausting \tc's resources
or a malicious \tc from stealing an honest user's money.


\paragraph{Execution model and notation.}
We take Ethereum's gas model as described in Section~\ref{sec:contracts-and-gas}.
We use the notation $\gas$ to denote gas and $\fee$ to denote non-gas currency.
In both cases \$ is a type annotation and the letter denotes the numerical amount.
For simplicity, our notation assumes that gas and normal currency adopt the same units (allowing us to perform arithmetic without conversion).
We use the following identifiers to denote currency and gas amounts.
%
\begin{center}
\begin{tabular}{m{0.08\columnwidth}m{0.85\columnwidth}}
  \hline
  $\fee$
  & Currency a requester deposits to refund \tcs's gas expenditure to deliver a datagram \\
  \hline
  $\gasrequest$ $\gasdeliver$ $\gascancel$
  & {\tt GASLIMIT} when invoking {\bf Request}, {\bf Deliver}, or {\bf Cancel}, respectively \\
  \hline
  $\gascallback$
  & {\tt GASLIMIT} for $\dgcallback$ while executing {\bf Deliver}, set to the max value that can be reimbursed \\
  \hline
  $\constgasmin$
  & Gas required for {\bf Deliver} excluding $\dgcallback$ \\
  \hline
  $\constgasmax$
  & Maximum gas \tc can spent to invoke {\bf Deliver} \\
  \hline
  $\constgascancel$
  & Gas needed for {\bf Deliver} on a cancelled request \\
  \hline
\end{tabular}
\end{center}
%
Note that $\constgasmin$, $\constgasmax$, and $\constgascancel$ are system constants,
$\fee$ is chosen by the requester (and may be malicious if the requester is dishonest),
and $\gasdeliver$ is chosen by the \tc~\encname when calling {\bf Deliver}.
Though $\gasrequest$ and $\gascancel$ are set by the requester, we need not worry about the values.
If they are too small, Ethereum will abort the transaction and there will not be a request or cancellation.

\paragraph{Adversarial cases.}

During the creation and fulfillment of any request, there are two untrusted parties: the requesting contract / user $\reqcont$ and the \tc~\medname. In the \tc implementation, we thus consider three cases:

\begin{itemize}
  \setlength{\itemsep}{2pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \item {\it Honest requester and \medname.}
    The requester must receive a valid authenticated response from TC.

  \item {\it Malicious requester and honest \medname.}
    \tc must still be able to respond to requests from other (honest) users.
    Thus we must prevent a malicious user from interfering directly with other requests (which the payment-free protocol already does)
    or exhausting the financial resources of TC.

  \item {\it Honest requester and malicious \medname.}
    The requester cannot receive invalid data (which is also assured by the payment-free protocol)
    and the requester not have to pay computation that is not executed.
\end{itemize}
We formalize these properties in Section~\ref{sec:analysis} and prove that our protocol provides these guarantees.
We intentionally ignore the case where both the requester and the \medname are dishonest.
If the requester is dishonest we need to not protect their request, and if the \medname is dishonest we cannot protect the TC system.




\begin{figure}[h!]
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf \tcs blockchain contract \tcont with fees}} \\[1ex]
  {\bf Request:} & On recv $({\sf params}, {\sf callback}, \fee, \gasrequest)$ from some $\reqcont$: \\
                 & Assert $\constgasmin \leq \fee \leq \constgasmax$ \\
                 & $\dgid := \text{Counter}$; \ \ $\text{Counter} := \text{Counter} + 1$ \\
                 & Store $(\dgid, \dgform, \dgcallback, \fee, \reqcont)$ \\[-0.8em]
                 & {\it \sgray{//~$\fee$ held by contract}} \\[0.3em]

  {\bf Deliver:} & On recv $(\dgid, \dgform, \dgm, \gasdeliver)$ from $\tcadd$: \\
  \sgray{$(\star)$} & If ${\sf isCanceled}[\dgid]$ and not ${\sf isDelivered}[\dgid]$ \\
                 & \quad Send $\constgascancel$ to $\tcadd$ \\
                 & \quad Set ${\sf isDelivered}[\dgid]$ \\
                 & \quad Return \\
                 & Retrieve stored $(\dgid, \dgform', \dgcallback, \fee, \_)$ \\
                 & \quad \sgray{\it //~abort if not found} \\
                 & Assert $\dgform = \dgform'$ and $\fee \leq \gasdeliver$ \\
                 & Set ${\sf isDelievered}[\dgid]$ \\
                 & Send $\fee$ to \tcadd \\
                 & Set $\gascallback := \fee - \constgasmin$ \\
  \sgray{$(\dagger)$} & Call $\dgcallback(\dgm)$ with $\gascallback$ max gas \\[0.3em]

  {\bf Cancel:}  & On recv $(\dgid, \gascancel)$ from $\reqcont$: \\
                 & Retrieve stored $(\dgid, \_, \_, \fee, \reqcont')$ \\
                 & \quad \sgray{\it //~abort if not found} \\
                 & Assert $\reqcont = \reqcont'$ \\
                 & \quad and $\fee \geq \constgascancel$ \\
                 & \quad and ${\sf isDelivered}[\dgid]$ not set \\
                 & \quad and ${\sf isCanceled}[\dgid]$ not set \\
                 & Set ${\sf isCanceled}[\dgid]$ \\
  \sgray{$(\ddagger)$} & Send $(\fee - \constgascancel)$ to $\reqcont$ \sgray{\it //~hold $\constgascancel$} \\
  \hline
\end{tabularx}
\caption{
Town Crier contract \tcont reflecting fees.
The last argument of each entry point is the {\tt GASLIMIT} provided.
An honest requester sets $\fee$ to be the gas required to execute {\bf Deliver} including $\dgcallback$.
Town Crier sets $\gasdeliver := \constgasmax$, but lowers the gas limit for $\dgcallback$ ensure that no more than $\fee$ is spent.
}
\label{tbl:gas-tc-contract}
\end{figure}

\begin{figure}[h!]
\begin{boxedminipage}{\columnwidth}
\centering
{\bf Program for \tcs~\encname $(\enclaveprog)$} \\[1ex]
\begin{tabular}{l}
  {\bf Initialize}: [Same as Figure~\ref{fig:engineprotocol}] \\[3pt]

  {\bf Resume:} On recv $(\resumecall, (\dgid, \dgform))$ \\
  \quad [Same as Figure~\ref{fig:engineprotocol} except the last two lines:] \\
  \quad $\sigma := \Sigma.{\sf Sign}({\skTC}, (\dgid, \dgform, \dgm, \constgasmax))$ \\
  \quad Output $((\dgid, \dgform, \dgm, \constgasmax), \sigma)$ \\
\end{tabular}
\end{boxedminipage}
\caption{The \tcs~\encname \engine.}
\label{fig:engineprot}
\end{figure}

\begin{figure}
\centering
\begin{tikzpicture}
  [contract/.style={entity,minimum height=3.5em,text width=7.5em},
   wallet/.style={entity,minimum height=3.5em,text width=5em},
   blocked-out-label/.style={text=black,blockchain-color,text height=0.6em}]
  \node[wallet,fill=white] (user) {User $\userwallet$};
  \node[contract,fill=white,right=6em of user] (cu) {User Contract\\$\reqcont$};
  \node[wallet,trusted,below=5em of user] (tc-wallet) {$\tcadd$};
  \node[contract,trusted,right=6em of tc-wallet] (ctc) {TC Contract\\$\tcont$};
  \node[color=maroon,draw,anchor=south east] (fee) at ([xshift=-0.25em,yshift=0.25em]ctc.south east) {\small $\fee$};

  \draw[color=gold,rounded corners,opacity=0.25,line width=1ex] ([yshift=1.25em]user.east) -| ([xshift=3.25em]cu.south);
  \path[->,color=gold,line width=1.15ex] (user) edge [transform canvas={yshift=1.25em}] (cu);
  \path[->,color=gold,line width=1ex] (cu) edge [transform canvas={xshift=3.25em}] (ctc);
  \path[->,color=maroon,line width=0.4ex] (cu.south) edge [left,transform canvas={xshift=3.25em}] node [blocked-out-label,xshift=1em,yshift=1.2em] {\small \smash{$(\gasrequest, \fee)$}} ([yshift=-1.5em]ctc.north);
  \node[anchor=north,xshift=1em,yshift=-0.75em] () at (cu.south) {\small \bf \underline{\smash{Request}}};
%  \path[->,color=maroon,line width=0.4ex] (cu.south) edge [left,transform canvas={xshift=3.25em}] node [blocked-out-label,xshift=1em,yshift=1em] {\small \smash{$(\gasrequest, \fee)$}} ([yshift=-1.5em]ctc.north);
%  \node[anchor=north,xshift=1em,yshift=-0.5em] () at (cu.south) {\small \bf \underline{\smash{Request}}};

  \path[->,color=gold,line width=1ex] (tc-wallet.east) edge [above,transform canvas={yshift=0.4em}] node () {\small $\gasdeliver$} (ctc.west);
  \draw[color=gold,rounded corners,opacity=0.25,line width=0.3ex] ([yshift=0.4em]tc-wallet.east) -| ([xshift=-3em]ctc.north);
  \path[->,color=gold,line width=0.3ex] (ctc.north) edge [right,transform canvas={xshift=-3em}] node [yshift=-1.25em] {\small \smash{$\gascallback$}} (cu.south);
  \path[color=maroon,opacity=0.25,line width=0.4ex] (tc-wallet-|fee.west) edge [transform canvas={yshift=-1.25em}] (tc-wallet.east);
  \path[->,color=maroon,line width=0.4ex] (ctc.west) edge [transform canvas={yshift=-1.25em}] node [fill=white,xshift=0.4em] {\small $\fee$} ([xshift=-0.8em]tc-wallet.east);
%  \path[->,color=gold,ultra thick,dashed] (ctc.west) edge [below,transform canvas={yshift=-1em}] node [text=black,xshift=0.4em] {\small $\gasdeliver - \fee$} ([xshift=-0.8em]tc-wallet.east);

  \path[] (tc-wallet.north east) edge [draw=none,above] node [yshift=0.75em] {\small \bf \underline{Deliver}} (ctc.north west);

  \begin{pgfonlayer}{background}
%    \node[bg-box,
%          blockchain-color,
%          inner sep=1.2em,
%          fit={(ctc)($(user.north west)+(0,0.9em)$)},
%          label=above:{\bf Blockchain}] () {};
    \node[bg-box,
          blockchain-color,
          fit=(ctc)(cu),
          label=above:{\bf Contracts}] () {};
    \node[bg-box,
          blockchain-color,
          fit=(tc-wallet)(user),
          label=above:{\bf Wallets}] () {};

%    \node[inner xsep=0.5em,blockchain-color,rounded corners] (bc-label) at (blockchain.north) {\bf Blockchain};
%
%    \node[inner xsep=0.5em,type-box-color,rounded corners,yshift=0.25em] (conts-label) at (conts.north) {\bf Contracts};
%    \draw[draw=black,dashed,rounded corners] (conts-label.east) -- (conts-label.north east) -- (conts-label.north east-|conts-label.north west) -- (conts-label.west);
%
%    \node[inner xsep=0.5em,type-box-color,rounded corners,yshift=0.25em] (wallets-label) at (wallets.north) {\bf Wallets};
%    \draw[draw=black,dashed,rounded corners] (wallets-label.east) -- (wallets-label.north east) -- (wallets-label.north east-|wallets-label.north west) -- (wallets-label.west);
  \end{pgfonlayer}
\end{tikzpicture}
\caption{{\bf Money Flow for a Delivered Request.}
Red arrows denote flow of money and brown arrows denote gas limits for functions.
The thickness of the line indicates the quantity of the resource.
The $\gascallback$ arrow is thin because the value is limited to $\fee - \constgasmin$.
}
\label{fig:money-flow}
\end{figure}



\paragraph{Town Crier protocol with fees.}
Our basic Town Crier system implements a policy where the requester pays for all gas needed and Town Crier effectively pays nothing.
We now describe how this can be realized by modifying the payment-free protocol described in Section~\ref{sec:payment-free-protocol}.

\begin{itemize}[leftmargin=1.5em]
  \setlength{\itemsep}{2pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \item {\it Initialization.}
    We assume that Town Crier deposits at least $\constgasmax$ into the wallet $\tcadd$.

  \item {\it \tcs blockchain contract.}
    Figure \ref{tbl:gas-tc-contract} describes the \tcs blockchain contract reflecting fees.
    Since $\tcadd$ must invoke {\bf Deliver}, \tc will pays the gas cost.
    It sets the {\tt GASLIMIT} $\gasdeliver := \constgasmax$.
    To ensure that the gas spent will not exceed the reimbursement available ($\fee$),
    \tcont sets the {\tt GASLIMIT} $\gascallback$ for the sub-call to $\dgcallback$ to the reimbursement remaining: $\fee - \constgasmin$.

  \item {\it Town Crier Relay.}
    The relay behavior does not change with the presence of fees.
    It still monitors the blockchain and whenever the contract \tcont stores a new request $(\dgid, \dgform, \_, \_, \_)$,
    it invokes $\enclaveprog$ with $\resumecall(\dgid, \dgform)$.

  \item {\it Town Crier enclave.}
    We make the following small modification to the fee-free protocol.
    Instead of signing the tuple $(\dgid, \dgform, \dgm)$ at the end of its execution,
    the enclave now signs the tuple $(\dgid, \dgform, \dgm, \gasdeliver)$ where $\gasdeliver = \constgasmax$.

  \item {\it Requester.}
    An honest requester behaves the same was as in Figure \ethan{refer} except for setting a {\tt GASLIMIT} of $\gasrequest$ and sending $\fee$ money with each request.
    It sets $\gasrequest$ to be at least the cost of executing the {\bf Request} entry point
    and $\fee$ to be the cost of executing the {\bf Deliver} entry point (including executing the user-defined $\dgcallback$ function).

    If an honest requester does not receive a callback, she can invoke {\bf Cancel} with argument $\dgid$ and gas limit $\gascancel$.
    The requester will be refunded $\fee - \constgascancel$, with $\constgascancel$ withheld to reimburse \tc
    should it try to deliver a datagram after the cancellation.
\end{itemize}

