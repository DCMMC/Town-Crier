
\section{Implementation Pseudocode}


\subsection{Application Contracts}
\label{sec:app-contract-code}


\begin{figure}[h!]
\begin{tabularx}{\linewidth}{|r@{\hspace{1ex}}X|}
  \hline

  \multicolumn{2}{|c|}{\bf {\sf FlightIns} blockchain contract} \\[1ex]

  \multicolumn{2}{|l|}{\bf Constants} \\
  $D_{\rm min}$ & := minimum delay to pay out insurance \\
  $T_\text{flight}$ & := \tcs flight info request type \\
  $\smaroon{\$F_\text{prem}}$ & := premium to buy insurance \\
  $\smaroon{\$F_\text{pay}}$ & := payout if flight is canceled or delayed \\
  $\smaroon{\$F_\text{\tc}}$ & := fee payed to \tc for datagram delivery \\[1ex]

  \multicolumn{2}{|l|}{\bf Functions} \\
  {\bf Init:}   & On recv $(\tcont)$: \\
                & Save address of \tcont \\[1ex]

  {\bf Insure:} & On recv $(encFN, \fee)$ from $\userwallet$: \\
                & Assert $\fee = \smaroon{\$F_\text{prem}}$ \\
                & $\dgform := [T_\text{flight}, encFN]$ \\
                & $\dgcallback := {\tt this}.{\bf Pay}$ \\
                & $\dgid := \tcont.{\bf Request}(\dgform, \dgcallback, \smaroon{\$F_\text{\tc}})$ \\
                & Store $(\dgid, \userwallet)$ \\[1ex]

  {\bf Pay:}    & On recv $(\dgid, D)$ from $\tcont$: \\
                & Retrieve and remove stored $(\dgid, \userwallet)$ \\
                & \quad \sgray{\it //~Abort if not found} \\
                & If $D \geq D_{\rm min}$ \\
                & \quad Send $\smaroon{\$F_\text{pay}}$ to $\userwallet$ \\[0.25em]

  \hline
\end{tabularx}
\caption{The {\sf FlightIns} application contract}
\label{tbl:flight-ins}
\end{figure}


\begin{figure}[h!]
\begin{tabularx}{\linewidth}{|r@{\hspace{1ex}}X|}
  \hline

  \multicolumn{2}{|c|}{\bf {\sf CashSettledPut} blockchain contract} \\[1ex]

  \multicolumn{2}{|l|}{\bf Constants} \\
  $T_\text{stock}$ & := \tcs stock info request type \\
  $\smaroon{\$F_\text{\tc}}$ & := fee payed to \tc for datagram delivery \\[1ex]

  \multicolumn{2}{|l|}{\bf Functions} \\
      {\bf Init:} & On recv $(\tcont, {\sf ticker}, P_S, P_U, M, {\sf expr}, \fee)$ from $\wallet_\text{issuer}$ \\
                  & Assert $\fee = (P_S - P_U) \cdot M + \smaroon{\$F_\text{\tc}}$ \\
                  & Save all inputs and $\wallet_\text{issuer}$ to storage. \\[1ex]

      {\bf Buy:} & On recv $(X, \fee)$ from $\userwallet$: \\
                 & Assert {\sf isRecovered} not set \\
                 & \quad and ${\sf timestamp} < {\sf expr}$ \\
                 & \quad and $\wallet_\text{buyer}$ not set \\
                 & \quad and $X \leq M$ \\
                 & \quad and $\fee = (X \cdot P_U)$ \\
                 & Set $\wallet_\text{buyer} = \userwallet$ \\
                 & Save $X$ to storage \\
                 & Send $(P_S - P_U)(M - X)$ to $\wallet_\text{issuer}$ \\[-0.8em]
                 & \sgray{\it //~Hold $P_S \cdot X + \smaroon{\$F_\text{\tc}}$} \\[1ex]

      {\bf Put:} & On recv $()$ from $\wallet_\text{buyer}$: \\
                 & \quad and ${\sf timestamp} < {\sf expr}$ \\
                 & \quad and ${\sf isPut}$ not set \\
                 & Set {\sf isPut} \\
                 & $\dgform := [T_\text{stock}, {\sf ticker}]$ \\
                 & $\dgcallback := {\tt this}.{\bf Settle}$ \\
                 & $\tcont.{\bf Request}(\dgform, \dgcallback, \smaroon{\$F_\text{\tc}})$ \\[1ex]

   {\bf Settle:} & On recv $(\dgid, P)$ from $\tcont$: \\
                 & If $P \geq P_S$ \\
                 & \quad Send $P_S \cdot X$ to $\wallet_\text{issuer}$ \\
                 & \quad Return \\
                 & Send $(P_S - P) X$ to $\wallet_\text{buyer}$ \\
                 & Send all money in contract to $\wallet_\text{issuer}$ \\[0.25em]
                 & Send $P \cdot X$ to $\wallet_\text{issuer}$ \\[1ex]

  {\bf Recover:} & On recv $()$ from $\wallet_\text{issuer}$: \\
                 & \quad and {\sf isPut} not set \\
                 & \quad and {\sf isRecovered} not set \\
                 & \quad and $(\wallet_\text{buyer} \text{ not set}$ \\
                 & \quad \hphantom{and } or ${\sf timestamp} \geq {\sf expr})$ \\
                 & Set {\sf isRecovered} \\
                 & Send all money in contract to $\wallet_\text{issuer}$ \\[0.25em]

  \hline
\end{tabularx}
\caption{The {\sf CashSettledPut} application contract}
\label{tbl:cash-settled-put}
\end{figure}


\begin{figure}[h!]
\begin{tabularx}{\linewidth}{|r@{\hspace{1ex}}X|}
  \hline

  \multicolumn{2}{|c|}{\bf {\sf SteamTrade} blockchain contract} \\[1ex]

  \multicolumn{2}{|l|}{\bf Constants} \\
  %$ID_S$ & := Steam account number of seller \\
  %$encAPI_S$ & := seller's encrypted API key \\
  %$List_I$ & := list of items for sale \\
  %$\smaroon{\$F_\text{price}}$ & := price for listed items \\
  $T_\text{steam}$ & := \tcs flight info request type \\
  $\smaroon{\$F_\text{\tc}}$ & := fee payed to \tc for datagram delivery \\[1ex]

  \multicolumn{2}{|l|}{\bf Functions} \\
  {\bf Init:}   & On recv $(\tcont, ID_S, encAPI_S, List_I, P)$ from $\wallet_\text{seller}$: \\
                & Save all inputs and $\wallet_\text{seller}$ to storage. \\[1ex]

  {\bf Purchase:} & On recv $(ID_U, T_U, \fee)$ from $\userwallet$: \\
                & Assert $\fee = P$ \\
                & $\dgform := [encAPI_S, ID_U, T_U, LIST_I]$ \\
                & $\dgcallback := {\tt this}.{\bf Pay}$ \\
                & $\dgid := \tcont.{\bf Request}(\dgform, \dgcallback, \smaroon{\$F_\text{\tc}})$ \\
                & Store $(\dgid, \userwallet)$ \\[1ex]

  {\bf Pay:}    & On recv $(\dgid, status)$ from $\tcont$: \\
                & Retrieve and remove stored $(\dgid, \userwallet)$ \\
                & \quad \sgray{\it //~Abort if not found} \\
                & If $status > 0$ \\
                & \quad Send $\smaroon{\$F_\text{price}}$ to $\wallet_\text{seller}$ \\
                & Else \\
                & \quad send $\smaroon{\$F_\text{price}}$ to $\userwallet$ \\
                [0.25em]

  \hline
\end{tabularx}
\caption{The {\sf FlightIns} application contract}
\label{tbl:steamtrade}
\end{figure}
