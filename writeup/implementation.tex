
\section{\tc Implementation Details}
\label{sec:impl}

We now present further details on our implementation of \tc. First, we discuss the details of Ethereum resource (ether and gas) management within \tc. The simplified payment-free protocol in Section~\ref{sec:payment-free-protocol} guarantees authenticity of data for an honest user.
In Ethereum, however, computation is not free: Recall from Section~\ref{sec:contracts-and-gas} that Ethereum employs \emph{gas}, a fee mechanism to mitigate DoS attacks.. This means that \tc needs enough money to deliver datagrams, so users must pay a fee to reimburse costs. If fees are not properly handled, a malicious relay (or malicious user) could prevent delivery of a datagram and/or cost an honest requester money for no gain. We discuss in Section 5.1 how we address this issue throughout the design of \tc. Then, in Sections 5.2 and 5.3, we present system-level details on the \tc contract \tcont and the two parts of the \tc server, the \encname and \medname.


\subsection{Handling Fees in Ethereum}
\label{sec:gas-protocol}

\input{gas-protocol-cancel}

\subsection{TC Contract}

We implement \tcont with fees as described in Section~\ref{sec:gas-protocol} in Solidity,
a high-level language with JavaScript-like syntax which compiles to Ethereum Virtual Machine bytecode---the language Ethereum contracts use.

In order to handle the most general type of requests---including encrypted parameters---the \tcont implementation requires two parameter fields.
The first is a single byte specifying what type of request is being made (e.g. stock price or flight status).
The second is a byte array of user-specified size.
This byte array will be parsed and interpreted inside the enclave when it fulfills the request, but is treated as an opaque byte array by \tcont.
For convenience, we also implicitly include the timestamp of the current block in the parameters.

To ensure the request has not been modified by the \medname, \tcont must store the parameters and \tc must pass them back in {\bf Deliver}.
To reduce the verification costs for large arrays, we instead store and verify $\text{SHA3-256}({\sf typeByte} || {\sf timestamp} || {\sf paramArray})$.
The relay scrapes the actual parameters and passes them into the enclave.
When calling {\bf Deliver}, \enclaveprog computes the same hash and passes that back for validation.
This allows us to continue validating long requests at low cost.



\subsection{TC Server}
\input{tcserver}

