
\section{\tc Implementation Details}
\label{sec:impl}

In our implementation of TC, we use Ethereum smart contracts and an SGX enclave to provide trusted computing environments.
The details of resource management within Ethereum present new challenges as they open TC to new attacks.

During the creation and fulfillment of any request, there are two untrusted parties: the requesting user and the \tc \medname.
The payment-free protocol in Section~\ref{sec:payment-free-protocol} gaurantees authenticity of data for an honest user.
However, the \tc system has no vulnerable resources and requests are separated from each, so a malicious user cannot cause harm.
In Ethereum, computation is not free.
This means that \tc needs enough money to deliver datagrams, so users must pay a fee to reimburse costs.
The fee raises the concern that a malicious relay could prevent delivery of a datagram and cost an honest requester money for no gain.

While designing the implementation, we consider three cases:
\begin{itemize}
  \item {\it Honest requester and relay.}
    The requester must receive a valid authenticated response from TC.

  \item {\it Malicious requester and honest relay.}
    \tc must still be able to respond to requests from other (honest) users.
    Thus we must prevent a malicious user from interfering directly with other requests (which the payment-free protocol already does)
    or exhausting the financial resources of TC.

  \item {\it Honest requester and malicious relay.}
    The requester cannot receive invalid data (which is also assured by thepayment-free protocol)
    and the requester should avoid paying for computation that is not executed.
\end{itemize}
We formalize these properties in Section \ethan{refer} and prove that our protocol provides these guarantees.
We intentionally ignore the case where both the requester and the relay are dishonest.
If the requester is dishonest we need to not protect their request, and if the relay is dishonest we cannot protect the TC system.


\subsection{Handling Fees in Ethereum}
\label{sec:gas-protocol}

\input{gas-protocol-cancel}



\subsection{TC Contract}

We implemente \tcont with fees as described in Section~\ref{sec:gas-protocol} in Solidity,
a high-level language with JavaScript-like syntax which compiles to Ethereum Virtual Machine bytecode---the language Ethereum contracts use.

In order to handle the most general type of requests---including encrypted parameters---the \tcont implementation requires two parameter fields.
The first is a single byte specifying what type of request is being made (e.g. stock price or flight status).
The second is a byte array of user-specified size.
This byte array will be parsed and interpreted inside the enclave when it fulfills the request, but is treated as an opaque byte array by \tcont.

As we discuss in Section \ethan{ref authenticity}, \tcont must store the parameters and \tc must pass them back in {\bf Deliver} to ensure that the request has not been modified.
In order to reduce the verification costs for requests with long parameter arrays, we instead store and verify a hash of the parameters.
In particular, we store the SHA3-256 hash of the concatenation of the request type byte and the byte array.
The relay scrapes the actual parameters and passes them into the enclave.
When calling {\bf Deliver}, \enclaveprog computes the same hash and passes that back for validation.
This allows us to continue validating long requests at low cost.



\subsection{TC Server}
\input{tcserver}

