
\section{\tc Implementation Details}
\label{sec:impl}

We now present further, system-level details on the \tc contract \tcont and the two parts of the \tc server, the \encname and \medname.

\subsection{TC Contract} 

We implement \tcont with fees as described in Section~\ref{sec:gas-protocol} in Solidity,
a high-level language with JavaScript-like syntax which compiles to Ethereum Virtual Machine bytecode---the language Ethereum contracts use.

In order to handle the most general type of requests---including encrypted parameters---the \tcont implementation requires two parameter fields:
a single byte specifying the type of request (e.g.~flight status) and a byte array of user-specified size.
This byte array is parsed and interpreted inside the \encname, but is treated as an opaque byte array by \tcont.
For convenience, we include the timestamp of the current block as an implicit parameter.

To guard against the \medname tampering with request parameters, the \tcont protocol includes $\dgform$ as an argument to {\bf Deliver} which validates against stored values.
To reduce this cost for large arrays, we store and verify $\text{SHA3-256}({\sf typeByte} || {\sf timestamp} || {\sf paramArray})$.
The \medname scrapes the raw values for the \encname which computes the hash and includes it as an argument to {\bf Deliver}.

To allow for improved efficiency in client contracts, our implementation of {\bf Request} returns $\dgid$
and {\bf Deliver} includes $\dgid$ along with $\dgm$ as arguments to $\dgcallback$.
This allows client contracts to make multiple requests in parallel and differentiate the responses,
so it is no longer necessary to create a unique client contract for every request to $\tcont$.



\subsection{TC Server}
Using the recently released Intel SGX SDK~\cite{sgxsdk}, we implmented the \tc
Server as an SGX-enabled application in C++. In the programming model supported
by the SGX SDK, the body of an SGX-enabled application runs as an ordinary
user-space application, while a relatively small piece of security-sensitive
code runs in the isolated environment of the SGX enclave.

The enclave portion of an SGX-enabled application may be viewed as a shared
library exposing an API in the form of \emph{ecalls} to be invoked by the
untrusted application. Invocation of an ecall transfers control to the enclave;
the enclave code runs until it either terminates and explicitly releases
control, or some special event (e.g., exception) happens~\cite{sgxmanual}.
Again, as we assume SGX provides ideal isolation, the untrusted application
cannot observe or alter the execution of ecalls.

Enclave programs can make \emph{ocalls} to invoke functions defined outside of
the enclave. An ocall triggers an exit from the enclave; control is returned
once the ocall completes. As ocalls execute outside the enclave, they must be
treated by enclave code as untrusted. 


\begin{figure}[h]
    \centering
%    \includegraphics[width=0.45\textwidth]{figures/impl}

\begin{tikzpicture}
  [box/.style={entity, text width=1.5cm, inner sep=5pt},
   untrusted/.style={fill=red!33},
   double/.style={rectangle split, rectangle split parts=2},
   ecall/.style={color=blue,thick},
   ocall/.style={color=red!80!black,thick}]
  \matrix (m) [row sep=1.2em, column sep=0.6em]{
    \node[inner sep=0pt,anchor=south] (user) {\includegraphics[width=1cm]{figures/user.eps}}; &
    \node[inner sep=0pt,draw,cloud,aspect=2.0,align=center,anchor=south](cloud) {\footnotesize HTTPS \\ websites}; &
    \node[box, cylinder, shape border rotate=90, aspect=.2,anchor=south](bc){blockchain};  \\[0.9em]

    \node[box,fill=white] (client) {Client \\ Interface}; & 
    \node[box,fill=white] (net) {TCP}; & 
    \node[box,fill=white,double,text width=2cm] (monitor) {\texttt{geth} \nodepart{second}{Blockchain \\ Interface}}; \\[0.6em]

    \node[box] (att) {Attestation \\ Generation}; &
    \node[box,double] (https) {HTTPS \nodepart{second}{Web \\ Scrapers}}; &
    \node[box,double,text width=2cm,] (req h){Ethereum TX \\ Reader/Writer \nodepart{second}{Request Handler}}; \\

    & \node[box,text width=2cm] (keys) {\pkTC, \skTC}; & \\
  };
  \node[anchor=west] (sk) at (keys.west-|att.west) {\skM};

  \draw[<->,thick] (user) -- (client);
  \draw[<->,thick] (net) -- (cloud);
  \draw[<->,thick] (monitor) -- (bc);

  \draw[->,ocall,transform canvas={xshift=-2mm}] (https) to (net);
  \draw[->,ocall,dashed,transform canvas={xshift=+2mm}] (net) to (https);

  \draw[->,ecall,transform canvas={xshift=-2mm}] (client) -- (att);
  \draw[<-,ecall,dashed,transform canvas={xshift=+2mm}] (client) -- (att);

  \draw[->,ecall,transform canvas={xshift=-2mm}] (monitor) -- (req h);
  \draw[<-,ecall,dashed,transform canvas={xshift=+2mm}] (monitor) -- (req h);

  \draw[<->,thick] (https.two east) -- (https.two east -| req h.two west);

  \draw[->,thick] (req h.south) |- (keys.east);
  \draw[->,thick] ([xshift=1.25em]att.south)  |- (keys.west);
  \draw[->,thick] (att.south-|sk.north) -- (sk);

  \begin{pgfonlayer}{background}
    \node [bg-box, inner sep=1.2em, tc-server-color, fit=(client)(monitor)(keys)] {};
    \node [inner sep=0.6em, untrusted, fit=(client) (net) (monitor)] {};
    \node [inner sep=0.6em, trusted, fit=(att) (https) (req h) (keys)] {};
  \end{pgfonlayer}

    \matrix (legend) [below=1.2em of m, matrix of nodes, column sep=0.75em, align=center]
  {
    \node[inner xsep=0] {\small \bf Legend:}; &
    \node[untrusted] (relay-leg) {\small Relay\vphantom{Ry}}; &
    \node[trusted] (enc-leg) {\small Enclave\vphantom{Ry}}; &
    \node[tc-server-color,rounded corners,text width=2.5em] (server-leg) {\small Server\vphantom{Ry}}; &
    \node[text width=1.75em] (ecall-leg) {}; &
    \node[text width=1.75em] (ocall-leg) {}; \\
  };

  \path[->,ecall,above] (ecall-leg.west) edge node {\small ecall} (ecall-leg.east);
  \path[<-,ecall,dashed,transform canvas={yshift=-0.4em}] (ecall-leg.west) edge (ecall-leg.east);

  \path[->,ocall,above] (ocall-leg.west) edge node {\small ocall} (ocall-leg.east);
  \path[<-,ocall,dashed,transform canvas={yshift=-0.4em}] (ocall-leg.west) edge (ocall-leg.east);
\end{tikzpicture}
\caption{Components of \tc Server}
\label{fig:tcserver_impl}
\end{figure}

For \tc, we recall that Fig.~\ref{fig:engineprotocol} shows the \encname code
$\engine$. Fig.~\ref{fig:relayprotocol} specifies the operation of the \medname,
the untrusted code in \tc, which we emphasize again provides essentially only
network functionality. We now give details on the services in the \encname and
the \medname and describe their interaction, as summarized in
Fig.~\ref{fig:tcserver_impl}.

\paragraph{\bf The \encname.} There are three components to the enclave code
\engine: An HTTPS service, Web Scrapers, which interact with data sources, and a
Request Handler, which services datagram requests. 

\vspace{2mm}

\noindent\emph{HTTPS Service.} We recall that the enclave does not have direct
access to host network functionality. \tc thus partitions HTTPS into a trusted
layer, consisting of HTTP and TLS code, and an untrusted layer that provides
low-layer network service, specifically TCP.  This arrangement allows the
enclave to establish a secure channel with a web server: The enclave itself
performs the TLS handshake with a target server and performs all cryptographic
operations internally, while the untrusted process acts as a network interface
only. We ported a TLS library (mbedTLS) into the SGX environment, as well as
HTTP code, which we minimized to meet the web-scraping requirements of \tc while
keeping the TCB small. To verify certificates presented by remote servers, we
hardcoded a collection of root CA certificates into the enclave code; in the
first version of \tc, the root CAs are identical to those in Chrome~\cite{}. By using its internal, trusted wall-clock time, it is possible to verify that a certificate has not expired. (We briefly discuss revocation in Appendix~\ref{sec:future}.)

\vspace{2mm}

\noindent\emph{Web Scrapers.} We implemented scrapers for our examples in Section~\ref{sec:applications} in an ad hoc manner for our initial implementation of \tc, and defer more principled, robust approaches to future work. 

\vspace{2mm}

\noindent\emph{Request Handler.} The Request Handler has two jobs: (1) Ingesting
a datagram request by parsing it in the serialization format specified by
Ethereum, decrypting it (if it's a private-datagram request), and dispatching
its parameters to the right scraper; and (2) Returning the response to the
request by generating an Ethereum transaction containing the requested datagram
(and parameters), serializing it as a blockchain transaction, and signing it
using \skTC. We implemented the Ethereum ABI and RLP, which respectively specify
the serialization of arguments and transactions in Ethereum. 

\vspace{2mm}

\noindent\emph{Attestation Generation.} Recall in Section \ref{sec:background}
we mentioned that an \emph{attestation} is an \emph{report} digitally signed by
the Intel-provided Quoting Enclave (QE).  Therefore two phases are involved in
generating \att. First, the \encname calls \texttt{sgx\_create\_report} to
generate a report with QE as the target enclave. Then the \medname forwards the
report to QE and calls \texttt{sgx\_get\_quote} to get a signed version of the
report, namely an attestation.

\paragraph{The \medname.} The \medname encompasses three components: A Client Interface, which serves attestations and timestamps, OS services, including networking and time services, and a Blockchain Interface. 

\vspace{2mm}

\noindent\emph{Client Interface.} As described in Section \ref{sec:architecture},
a client starts using \tc by requesting and verifying an attestation \att and checking the correctness of the clock in the \tc enclave using a fresh timestamp.
The Client Interface caches \att upon initialization of \engine. When it receives a web request from a client for an attestation,
it issues an ecall to the enclave to obtain a
Unix timestamp signed using \skTC, which it returns to the client along with \att. The client verify \att 
using the Intel Attestation Service (IAS)~\cite{} and then verify the timestamp using $\pkTC$ and check it using any trustworthy time service. 

\vspace{2mm}

\noindent\emph{OS services.} The \encname relies on the \medname to access networking and 
wall-clock time provided by the OS and implemented as ocalls.

\vspace{2mm}

\noindent\emph{Blockchain Interface.} The \medname's Blockchain Interface monitors the
blockchain for incoming requests and places transactions on the blockchain in order to
deliver datagrams. The Blockchain Interface incorporates an 
official Ethereum client, Geth~\cite{geth}. This Geth client can be configured with a JSON RPC server.  
The \medname  communicates with the blockchain indirectly via RPC calls to this server. For example, to insert a signed transaction, the \medname simply calls
\texttt{eth\_sendRawTransaction} with the byte array of the serialized
transaction. We emphasize that as the enclave holds \skTC, transactions are signed within the enclave.

