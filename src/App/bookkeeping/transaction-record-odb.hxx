// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef TRANSACTION_RECORD_ODB_HXX
#define TRANSACTION_RECORD_ODB_HXX

#include <odb/version.hxx>

#if (ODB_VERSION != 20400UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "transaction-record.hxx"

#include <memory>
#include <cstddef>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#include <odb/container-traits.hxx>
#include <odb/no-op-cache-traits.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>
#include <odb/view-image.hxx>
#include <odb/view-result.hxx>

#include <odb/details/unused.hxx>
#include <odb/details/shared-ptr.hxx>

namespace odb {
// TransactionRecord
//
template<>
struct class_traits<::TransactionRecord> {
  static const class_kind kind = class_object;
};

template<>
class access::object_traits<::TransactionRecord> {
 public:
  typedef ::TransactionRecord object_type;
  typedef ::TransactionRecord *pointer_type;
  typedef odb::pointer_traits<pointer_type> pointer_traits;

  static const bool polymorphic = false;

  typedef long unsigned int id_type;

  static const bool auto_id = true;

  static const bool abstract = false;

  static id_type
  id(const object_type &);

  typedef
  no_op_pointer_cache_traits<pointer_type>
      pointer_cache_traits;

  typedef
  no_op_reference_cache_traits<object_type>
      reference_cache_traits;

  static void
  callback(database &, object_type &, callback_event);

  static void
  callback(database &, const object_type &, callback_event);
};

// TransactionStat
//
template<>
struct class_traits<::TransactionStat> {
  static const class_kind kind = class_view;
};

template<>
class access::view_traits<::TransactionStat> {
 public:
  typedef ::TransactionStat view_type;
  typedef ::TransactionStat *pointer_type;

  static void
  callback(database &, view_type &, callback_event);
};
}

#include <odb/details/buffer.hxx>

#include <odb/sqlite/version.hxx>
#include <odb/sqlite/forward.hxx>
#include <odb/sqlite/binding.hxx>
#include <odb/sqlite/sqlite-types.hxx>
#include <odb/sqlite/query.hxx>

namespace odb {
// TransactionRecord
//
template<typename A>
struct query_columns<::TransactionRecord, id_sqlite, A> {
  // id
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer>::query_type,
      sqlite::id_integer>
      id_type_;

  static const id_type_ id;

  // block_number
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          ::blocknum_t,
          sqlite::id_integer>::query_type,
      sqlite::id_integer>
      block_number_type_;

  static const block_number_type_ block_number;

  // tx_hash
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text>::query_type,
      sqlite::id_text>
      tx_hash_type_;

  static const tx_hash_type_ tx_hash;

  // request
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text>::query_type,
      sqlite::id_text>
      request_type_;

  static const request_type_ request;

  // request_time
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          ::time_t,
          sqlite::id_integer>::query_type,
      sqlite::id_integer>
      request_time_type_;

  static const request_time_type_ request_time;

  // response
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text>::query_type,
      sqlite::id_text>
      response_type_;

  static const response_type_ response;

  // response_time
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          ::time_t,
          sqlite::id_integer>::query_type,
      sqlite::id_integer>
      response_time_type_;

  static const response_time_type_ response_time;

  // n_retrial
  //
  typedef
  sqlite::query_column<
      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer>::query_type,
      sqlite::id_integer>
      n_retrial_type_;

  static const n_retrial_type_ n_retrial;
};

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::id_type_
query_columns<::TransactionRecord, id_sqlite, A>::
id(A::table_name,
"\"id\"", 0);

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::block_number_type_
query_columns<::TransactionRecord, id_sqlite, A>::
block_number(A::table_name,
"\"block_number\"", 0);

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::tx_hash_type_
query_columns<::TransactionRecord, id_sqlite, A>::
tx_hash(A::table_name,
"\"tx_hash\"", 0);

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::request_type_
query_columns<::TransactionRecord, id_sqlite, A>::
request(A::table_name,
"\"request\"", 0);

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::request_time_type_
query_columns<::TransactionRecord, id_sqlite, A>::
request_time(A::table_name,
"\"request_time\"", 0);

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::response_type_
query_columns<::TransactionRecord, id_sqlite, A>::
response(A::table_name,
"\"response\"", 0);

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::response_time_type_
query_columns<::TransactionRecord, id_sqlite, A>::
response_time(A::table_name,
"\"response_time\"", 0);

template<typename A>
const typename query_columns<::TransactionRecord, id_sqlite, A>::n_retrial_type_
query_columns<::TransactionRecord, id_sqlite, A>::
n_retrial(A::table_name,
"\"n_retrial\"", 0);

template<typename A>
struct pointer_query_columns<::TransactionRecord, id_sqlite, A> :
    query_columns<::TransactionRecord, id_sqlite, A> {
};

template<>
class access::object_traits_impl<::TransactionRecord, id_sqlite> :
    public access::object_traits<::TransactionRecord> {
 public:
  struct id_image_type {
    long long id_value;
    bool id_null;

    std::size_t version;
  };

  struct image_type {
    // __id
    //
    long long __id_value;
    bool __id_null;

    // block_number
    //
    long long block_number_value;
    bool block_number_null;

    // tx_hash
    //
    details::buffer tx_hash_value;
    std::size_t tx_hash_size;
    bool tx_hash_null;

    // request
    //
    details::buffer request_value;
    std::size_t request_size;
    bool request_null;

    // request_time
    //
    long long request_time_value;
    bool request_time_null;

    // response
    //
    details::buffer response_value;
    std::size_t response_size;
    bool response_null;

    // response_time
    //
    long long response_time_value;
    bool response_time_null;

    // n_retrial
    //
    long long n_retrial_value;
    bool n_retrial_null;

    std::size_t version;
  };

  struct extra_statement_cache_type;

  using object_traits<object_type>::id;

  static id_type
  id(const id_image_type &);

  static id_type
  id(const image_type &);

  static bool
  grow(image_type &,
       bool *);

  static void
  bind(sqlite::bind *,
       image_type &,
       sqlite::statement_kind);

  static void
  bind(sqlite::bind *, id_image_type &);

  static bool
  init(image_type &,
       const object_type &,
       sqlite::statement_kind);

  static void
  init(object_type &,
       const image_type &,
       database *);

  static void
  init(id_image_type &, const id_type &);

  typedef sqlite::object_statements<object_type> statements_type;

  typedef sqlite::query_base query_base_type;

  static const std::size_t column_count = 8UL;
  static const std::size_t id_column_count = 1UL;
  static const std::size_t inverse_column_count = 0UL;
  static const std::size_t readonly_column_count = 0UL;
  static const std::size_t managed_optimistic_column_count = 0UL;

  static const std::size_t separate_load_column_count = 0UL;
  static const std::size_t separate_update_column_count = 0UL;

  static const bool versioned = false;

  static const char persist_statement[];
  static const char find_statement[];
  static const char update_statement[];
  static const char erase_statement[];
  static const char query_statement[];
  static const char erase_query_statement[];

  static const char table_name[];

  static void
  persist(database &, object_type &);

  static pointer_type
  find(database &, const id_type &);

  static bool
  find(database &, const id_type &, object_type &);

  static bool
  reload(database &, object_type &);

  static void
  update(database &, const object_type &);

  static void
  erase(database &, const id_type &);

  static void
  erase(database &, const object_type &);

  static result<object_type>
  query(database &, const query_base_type &);

  static unsigned long long
  erase_query(database &, const query_base_type &);

 public:
  static bool
  find_(statements_type &,
        const id_type *);

  static void
  load_(statements_type &,
        object_type &,
        bool reload);
};

template<>
class access::object_traits_impl<::TransactionRecord, id_common> :
    public access::object_traits_impl<::TransactionRecord, id_sqlite> {
};

// TransactionStat
//
template<>
class access::view_traits_impl<::TransactionStat, id_sqlite> :
    public access::view_traits<::TransactionStat> {
 public:
  struct image_type {
    // count
    //
    long long count_value;
    bool count_null;

    // lastBlock
    //
    long long lastBlock_value;
    bool lastBlock_null;

    std::size_t version;
  };

  typedef sqlite::view_statements<view_type> statements_type;

  typedef sqlite::query_base query_base_type;
  struct query_columns;

  static const bool versioned = false;

  static bool
  grow(image_type &,
       bool *);

  static void
  bind(sqlite::bind *,
       image_type &);

  static void
  init(view_type &,
       const image_type &,
       database *);

  static const std::size_t column_count = 2UL;

  static query_base_type
  query_statement(const query_base_type &);

  static result<view_type>
  query(database &, const query_base_type &);
};

template<>
class access::view_traits_impl<::TransactionStat, id_common> :
    public access::view_traits_impl<::TransactionStat, id_sqlite> {
};

// TransactionRecord
//
// TransactionStat
//
struct access::view_traits_impl<::TransactionStat, id_sqlite>::query_columns :
    odb::pointer_query_columns<
        ::TransactionRecord,
        id_sqlite,
        odb::access::object_traits_impl<::TransactionRecord, id_sqlite> > {
};
}

#include "transaction-record-odb.ixx"

#include <odb/post.hxx>

#endif // TRANSACTION_RECORD_ODB_HXX
