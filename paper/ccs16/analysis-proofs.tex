
\section{Proofs of Security}
\label{sec:analysis-proofs}

This section contains the proofs of the theorems we stated in Section~\ref{sec:analysis}.


\begin{retheorem}{thm:authenticity}[Authenticity]
Assume that $\sigsgx$ and $\Sigma$ are secure signature schemes.
Then, the full \tc protocol achieves authenticity of data feed under Definition~\ref{defn:auth}.
\end{retheorem}

\begin{proof}
We show that if the 
adversary $\algA$ succeeds in a forgery with non-negligible probability,
we can construct an adversary $\algB$ that can either
break $\sigsgx$ or $\Sigma$ with non-negligible probability.
We consider two cases. 
The reduction $\algB$ will flip a random coin to guess which
case it is, and if the guess is wrong, simply abort.
\begin{itemize}[leftmargin=5mm]
\item
Case 1: $\algA$ outputs a signature $\sigma$ that uses the same  
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will try to break $\Sigma$. 
$\algB$ interacts with a signature challenger ${\sf Ch}$ who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates 
$\fsgx$ by implicitly letting $\pksgx := \pk^*$.
Whenever $\fsgx$ needs to sign a query, $\algB$ passes the signing query
onto the signature challenger ${\sf Ch}$.

Since ${\sf data} \neq \enclaveprog({\sf params})$,
$\algB$ cannot have queried ${\sf Ch}$  
on a tuple of the form $(\_, {\sf params}, {\sf data})$. 
Therefore, $\algB$ simply outputs 
what $\algA$ 
outputs (suppressing unnecessary terms) as the signature forgery. 

\item
Case 2:
 $\algA$ outputs a signature $\sigma$ that uses a different 
$\pksgx$ as the SGX functionality $\fsgx$.
In this case, $\algB$ will seek to break $\sigsgx$.
$\algB$ interacts with a signature challenger ${\sf Ch}$, who generates
some $(\pk^*, \sk^*)$ pair, and gives to $\algB$ the public key
$\pk^*$. $\algB$ simulates $\fsgx$ by implicitly setting
$\pkM := \pk^*$.
Whenever $\fsgx$ needs to make a signature
with $\skM$, 
$\algB$ simply passes the signature query onto ${\sf Ch}$.
In this case, in order for $\algA$ to succeed,
it must produce a valid signature $\sigatt$ 
for a different public key $\pk'$.
Therefore, $\algB$ simply outputs this as a signature forgery.
\end{itemize}
\end{proof}


\begin{lemma}
\label{lem:no-money-theft}
$\tcont$ will never attempt to send money in {\bf Deliver} or {\bf Cancel} that was not deposited with the given $\dgid$.
\end{lemma}

\begin{proof}
First we note that there are only three lines on which $\tcont$ sends money: $(2)$, $(3)$, and $(5)$.
Second, for a request $\dgid$, $\fee$ is deposited.
Third, because ${\sf isCanceled}[\dgid]$ is only set immediately prior to line $(5)$ and line $(2)$
is only reachable if ${\sf isCanceled}[\dgid]$ is set, it is impossible to reach line $(2)$ without reaching line $(5)$.

We now consider cases based on which of lines $(3)$ and $(5)$ are reached first (since at least one must be reached to send any money).
\begin{itemize}

\item {\it Line $(5)$ is reached first.}
In this case, line $(5)$ sends $\fee - \constgascancel$ and allows $\constgascancel$ to remain.
Future calls to {\bf Cancel} with this $\dgid$ will fail the ${\sf isCanceled}[\dgid]$ not check assertion, so line $(5)$ can never be reached again with this $\dgid$.
If $\tcadd$ invokes {\bf Deliver} after this point, the first such invocation will satisfy the predicate on line $(1)$ and proceed to set ${\sf isDelivered}[\dgid]$ and reach line $(2)$.
Any future entries to {\bf Deliver} with $\dgid$ will fail to satisfy the predicate on line $(1)$ and then fail an assertion and abort prior to line $(3)$.
Since line $(2)$ sends $\constgascancel$, the total money sent in connection with $\dgid$ is $(\fee - \constgascancel) + \constgascancel = \fee$.


\item {\it Line $(3)$ is reached first.}
In this case, line $(3)$ send the full $\fee$ immediately after setting ${\sf isDelivered}[\dgid]$.
With ${\sf isDelivered}[\dgid]$ set, any call to {\bf Cancel} with $\dgid$ will fail an assertion prior to line $(5)$
and any future call to {\bf Deliver} with $\dgid$ will fail to satisfy the predicate on line $(1)$ and also fail an assertion prior to reaching line $(3)$.
Thus no further money will be distributed in connection with $\dgid$.
\end{itemize}
\end{proof}





\begin{retheorem}{thm:tc-gas-sustainable}[Gas Sustainability]
\tcs is \emph{\constgasmax-gas sustainable}.
\end{retheorem}

\begin{proof}
By assumption, $\tcadd$ is seeded with at least $\constgasmax$ money.
Thus it suffices to prove that, given an honest \medname, $\tcadd$ will have at least as much money after invoking {\bf Deliver} as it did before.

An honest \medname will never ask for a response for the same $\dgid$ more than once.
{\bf Deliver} only responds to messages from $\tcadd$, and ${\sf isDelivered}[\dgid]$ is only set inside {\bf Deliver},
so therefore we know that ${\sf isDelivered}[\dgid]$ is not set for this $\dgid$.
We now consider the case where ${\sf isCanceled}[\dgid]$ is set upon invocation of {\bf Deliver} and the case where it is not.
\begin{itemize}

\item {\it ${\sf isCanceled}[\dgid]$ not set:}
In this case the predicate on line $(1)$ of the protocol returns {\tt false}.
Because the \medname is honest, $\dgid$ exists and $\dgform = \dgform'$.
The enclave always provides $\gasdeliver = \constgasmax$ (which it has by assumption) and {\bf Request} ensures that $\fee \leq \constgasmax$.
Thus, coupled with the knowledge that ${\sf isDeliver}[\dgid]$ is not set, all assertions pass and we progress through lines $(3)$ and $(4)$.
Now we must show that at line $(3)$ $\tcont$ had $\fee$ to send and that the total gas spend to execute {\bf Deliver} does not exceed $\fee$.

To see that $\tcont$ had sufficient funds, we note that upon entry to {\bf Deliver}, both ${\sf isDelivered}[\dgid]$ and ${\sf isCanceled}[\dgid]$ must have been unset.
The first we showed above.
The second is because, given the first, if ${\sf isCanceled}[\dgid]$ were set, the predicate on line $(1)$ would have returned true, sending execution on a path that would not encounter $(4)$.
This means that line $(5)$ was never reached because the preceding line sets ${\sf isCanceled}[\dgid]$.
Because $(2)$, $(3)$, and $(5)$ are the only lines that remove money from $\tcont$ and $\fee$ was deposited as part of {\bf Request},
it must be the case that $\fee$ is still in the contract.

To see how much gas is spent, we first note that $\constgasmin$ is defined to be the amount of gas needed to execute {\bf Deliver} along this execution path not including line $(4)$.
Since $\gascallback$ is set to $\fee - \constgasmin$ and line $(4)$ is limited to using $\gascallback$ gas,
the total gas spent on this execution of {\bf Deliver} is at most $\constgasmin + (\fee - \constgasmin) = \fee$.


\item {\it ${\sf isCanceled}[\dgid]$ is set:}
Here the predicate on line $(1)$ returns {\tt true}.
Along this execution path $\tcont$ sends $\tcadd$ $\constgascancel$ and quickly returns.
$\constgascancel$ is defined as the amount of gas necessary to execute this execution path,
so we need only show that $\tcont$ has $\constgascancel$ available to send.

Because ${\sf isCanceled}[\dgid]$ is set, it must be the case that {\sf Cancel} was invoked with $\dgid$ and reached line $(5)$.
Gas exhaustion in {\sf Cancel} is not a concern because it would abort and revert the entire invocation.
This is only possible if the data retrieval and all assertions in {\sf Cancel} succeed.
In particular, this means that $\dgid$ corresponds to a valid request which deposited $\fee$.
Line $(5)$ returns $\fee - \constgascancel$ to $\reqcont$, but it leaves $\constgasmin$ from the original $\fee$.
Moreover, if {\bf Cancel} is invoked multiple times with the same $\dgid$, all but the first will fail due to the assert that ${\sf isCanceled}[\dgid]$ is not set
and the fact that any invocation that reaches $(5)$ will set ${\sf isCanceled}$ for that $\dgid$.
Since only lines $(2)$, $(3)$, and $(5)$ can remove money from $\tcont$ and line $(3)$ will never be called in this case,
there will still be exactly $\constgasmin$ available when this invocation of {\bf Deliver} reaches line $(2)$.

\end{itemize}
\end{proof}






\begin{retheorem}{thm:fair-expenditure}[Fair Expenditure for Honest Requester]
For any $\dgform$ and $\dgcallback$,
let $\constgasrequest$ and $\consthonestfee$ be the respective values chosen by an honest requester for $\gasrequest$ and $\fee$
when submitting the request $(\dgform, \dgcallback, \fee, \gasrequest)$.
For any such request submitted by an honest user $\reqcont$, one of the following holds:
\begin{itemize}
  \setlength{\itemsep}{2pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
  \item $\dgcallback$ is invoked with a valid datagram matching the request parameters $\dgform$
    and the requester spends at most $\constgasrequest + \constgasinvokecancel + \consthonestfee$.

  \item The requester spends at most $\constgasrequest + \constgasinvokecancel + \constgascancel$.
\end{itemize}
\end{retheorem}


\begin{proof}
$\reqcont$ is honest, so she will first spend $\constgasrequest$ to invoke ${\bf Request}(\dgform, \dgcallback, \consthonestfee)$.
Ethereum does not allow money to change hands without the payer explicitly sending money.
Therefore we must only examine the explicit function invocations and monetary transfers initiated by $\reqcont$ in connection with the request.
It is impossible for $\reqcont$ to lose more money than she gives up in these transactions even if \tc is malicious.

\begin{itemize}
\item {\it Request Delivered:}
If protocol line $(4)$ is reached, then we are guaranteed that $\dgform = \dgform'$ and $\gasdeliver \geq \consthonestfee$.
By Theorem~\ref{thm:authenticity}, the datagram must therefore be authentic for $\dgform$.
Because $\consthonestfee$ is chosen honestly for $\dgcallback$, $\consthonestfee - \constgasmin$ is enough gas to execute $\dgcallback$,
so $\dgcallback$ will be invoked with a datagram that is a valid and matches the request parameters.

In this case, the honest requester will have spent $\constgasrequest$ to invoke {\bf Request} and $\consthonestfee$ in paying \tc's cost for {\bf Deliver}.
The requester may have also invoked {\bf Cancel} at most once at the cost of $\constgasinvokecancel$.
While $\reqcont$ may not receive any refund due to {\bf Cancel} aborting, $\reqcont$ will still have spent at most $\constgasrequest + \constgasinvokecancel + \consthonestfee$.


\item {\it Request not Delivered:}
The request not being delivered means that line $(4)$ is never reached.
This can only happen if {\bf Deliver} is never called with a valid response or if ${\sf isCanceled}[\dgid]$ is set before deliver is called.
The only way to set ${\sf isCanceled}[\dgid]$ is for $\reqcont$ to invoke {\bf Cancel} with ${\sf isDelivered}[\dgid]$ not set.
If deliver is not executed, we assume that an honest requester will eventually invoke {\bf Cancel}, so this case will always reach line $(5)$.
When line $(5)$ is reached, then $\reqcont$ will have spent $\constgasrequest + \consthonestfee$ while executing {\bf Request},
and spent $\constgasinvokecancel$ in {\bf Cancel} and will attempt to retrieve $\consthonestfee - \constgascancel$.

The retrieval will succeed because $\tcont$ will always have the funds to send $\reqcont$ $\consthonestfee - \constgascancel$.
To see this, Lemma~\ref{lem:no-money-theft} allows us to consider only {\bf Deliver} and {\bf Cancel} calls associated with $\dgid$.

Since line $(5)$ is reached, it must be the case the ${\sf isDelivered}[\dgid]$ is not set.
This means that neither lines $(2)$ nor $(3)$ were reached since the line before each sets ${\sf isDelivered}[\dgid]$.
The lines preceding those two and $(5)$ are the only lines that remove money from the contract.
Line $(5)$ cannot have been reached before because $\reqcont$ is assumed to be honest, so she will not invoke {\bf Cancel} twice for the same request
and if any other user invokes {\bf Cancel} for this request, the $\reqcont = \reqcont'$ assertion will fail and the invocation will abort before line $(5)$.
Because none of $(2)$, $(3)$, or $(5)$ has been reached before and $\reqcont$ deposited $\consthonestfee > \constgasmin > \constgascancel$ on {\bf Request},
it must be the case that $\tcont$ has $\consthonestfee - \constgascancel$ left.

This means the total expenditure in this case will be
\begin{align*}
  \constgasrequest + \constgasinvokecancel & + \consthonestfee - (\consthonestfee - \constgascancel) \\
                                           & = \constgasrequest + \constgasinvokecancel + \constgascancel.
\end{align*}
\end{itemize}
\end{proof}

