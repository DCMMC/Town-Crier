\section{Future Work}
\label{sec:future-work}

We plan to develop \tc after its initial deployment to incorporate a number of additional features.
We discuss a few of those features here.

\paragraph{Freeloading Protection.}
There are concerns in the Ethereum community about ``parasite contracts'' that forward or resell datagrams from fee-based data feeds \cite{parasite}.
As a countermeasure, we plan to deploy the following mechanism in \tc inspired by designated verifier proofs \cite{JakobssonSI1996}.
The set of $n$ users ${\cal U} = \{U_1, \ldots, U_n\}$ of a requesting contract generate an $(n,n)$-secret-shared key pair $(\sk_{\cal U}, \pk_{\cal U})$.
They submit their $n$ individual shares to the \tc\ \encname (e.g., as ciphertexts under $\pkTC$ sent to \tcont).

\tc now can sign datagrams using $\sk_{\cal U}$. Each user $U_i$ can be sure individually that a datagram produced by \tc is valid, since she did not collude in its creation. Potential parasitic users, however, cannot determine whether the datagram was produced by \tcont or by ${\cal U}$, and thus whether or not it is valid.
Such a \emph{source-equivocal datagram} renders parasite contracts less trustworthy and thus less attractive.

\paragraph{Revocation Support.}
There are two forms of revocation relevant to \tc.
First, the certificates of data sources may be revoked.
Since \tc already uses HTTPS, it could easily use the Online Certificate Status Protocol (OCSP) to check TLS certificates.
Second, an SGX host could become compromised, prompting revocation of its EPID signatures by Intel.
The Intel Attestation Service (IAS) will reportedly disseminate such revocations.
Conveniently, clients already use the IAS when checking the attestation \sigatt, so revocation checking will require no modification to \tc.

\paragraph{Hedging Against SGX Compromise.}
We discussed in Section~\ref{subsec:enhanced_robustness} how \tc can support majority voting across SGX hosts and data sources.
Design enhancements to \tc could reduce associated latency and gas costs.
For SGX voting, we plan to investigate a scheme in which SGX-enabled \tc hosts agree on a datagram value $X$ via Byzantine consensus.
The hosts may then use a threshold digital signature scheme to sign the datagram response from \tcadd,
and each participating host can monitor the blockchain to ensure delivery.

\paragraph{Updating \tc's Code.}
As with any software, we may discover flaws in \tc or wish to add new functionality after initial deployment.
With \tc as described above, however, updating \engine would cause the \encname to lose access to \skTC and thus be unable to respond to requests in \tcont.
The \tc operators could set up a new contract $\tcont'$ referencing new keys, but this would be expensive and burdensome for \tc's operators and users.
While arbitrary code changes would be insecure, we could create a template for user contracts that includes a means to approve upgrades.
We plan to investigate this and other mechanisms.

\paragraph{Generalized Custom Datagrams and Within-Enclave Smart-Contract Execution.}
In our {\sf SteamTrade} example contract we demonstrated a custom datagram that scrapes a user's online account using her credentials.
A more generic approach would allow users to supply their own general-purpose code to \tc and data-source-enriched emulation of private contracts as in Hawk \cite{hawk}, but with considerably less computational overhead.
Placing such large requests on the blockchain would be prohibitively expensive, but code could easily be loaded into the \tc enclave off-chain.
Of course, deploying arbitrary user code raises many security and confidentiality concerns which \tc would need to address. \tc offers a basic framework, however, within which to provide confidential, integrity-protected smart-contract code execution off-chain with trustworthy integration into on-chain smart-contract code.

