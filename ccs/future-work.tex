\section{Future Work}
\label{sec:future-work}

We plan to develop \tc after its initial deployment to incorporate a number of additional features.
We discuss a few of those features here.

\paragraph{Freeloading Protection.}
There are concerns in the Ethereum community about ``parasite contracts'' that forward or resell datagrams from fee-based data feeds \cite{parasite}.
In order to guard against these parasites, we plan to deploy a mechanism in \tc inspired by designated verifier proofs \cite{JakobssonSI1996}.
All users ${\cal U}$ of a requesting contract would generate keys for a multi-party signature and submit the private keys to \tcont encrypted under \pkTC.
\tc will then produce a datagram signed with the combination of all supplied keys.

With all of the associated secret keys, \tcont can produce a datagram with the appropriate signature and each user $U_i$ can be sure the datagram is valid since she did not collude in its creation.
However, potential parasitic users cannot determine whether the datagram was produced by \tcont or by ${\cal U}$, and thus whether or not it is valid.
Such a \emph{source-equivocal datagram} renders parasite contracts less trustworthy and thus less attractive.

\paragraph{Revocation Support.}
There are two forms of revocation relevant to \tc.
First, the certificates of data sources may be revoked.
Since \tc already uses HTTPS, it could easily use an Online Certificate Status Protocol (OCSP) to check TLS certificates.
Second, an SGX host could become compromised, prompting revocation of its EPID signatures by Intel.
The Intel Attestation Service (IAS) will reportedly provide a means of disseminating such revocations.
Conveniently, clients already use the IAS when checking the attestation \sigatt, so this requires no modification to \tc.

\paragraph{Hedging Against SGX Compromise.}
We discussed in Section~\ref{subsec:enhanced_robustness} how \tc can support majority voting across SGX hosts and data sources.
Design enhancements to \tc could reduce associated latency and gas costs.
For SGX voting, we plan to investigate a scheme in which SGX-enabled \tc hosts agree on a datagram value $X$ via Byzantine consensus.
The hosts may then use a threshold digital signature scheme to sign the datagram response from \tcadd,
and each participating host can monitor the blockchain to ensure delivery.

\paragraph{Updating \tc's Code.}
As with any software, we may discover flaws in \tc or wish to add new functionality after initial deployment.
However, with \tc as described above, updating \engine would cause the \encname to lose access to \skTC and thus be unable to respond to requests in \tcont.
The \tc operators could set up a new contract $\tcont'$ referencing the new keys, but this is expensive and burdensome for \tc's operators and users.
While arbitrary code changes would be highly insecure, we could create a template for user contracts that includes a means to approve upgrades.
We plan to investigate this and other mechanisms.

\paragraph{Generalized Custom Datagrams.}
In our {\sf SteamTrade} example contract we demonstrated a custom datagram that scrapes a user's online account using her credentials.
A more general approach would allow users to supply their own general purpose code and achieve inexpensive data-source-enriched emulation of private contracts in Hawk \cite{hawk}.
Placing such large requests on the blockchain would be extremely expensive, but code could be easily loaded off-chain.
Of course, deploying arbitrary user code raises many security and confidentiality concerns which \tc would need to address.

