
\subsection{A Payment-Free Basic Protocol}
\label{sec:payment-free-protocol}

For simplicity, we first specify a payment-free version of our basic protocol, i.e.~one that does not include gas or fees. Later, in our implementation discussion, we explain how we handle these two resources and we prove payment-related properties in the paper appendix. For simplicity, we assume a single instance of \engine, although our architecture could scale up to multiple enclaves and even server instances. To show messages corresponding to those in Fig.~\ref{fig:dataflow}, we use the label $(\msgi{i})$.

%\vspace{-3mm}
\paragraph{The Requester Contract $\reqcont$.}
The requester contract $\reqcont$ sends a request of the form $(\dgform, \dgcallback)$ to the \tcontract \tcont.

%\vspace{-3mm}
\paragraph{The \tcontract \tcont.} 
The \tcontract accepts a datagram request from \reqcont, assigns it a unique ${\sf id}$, and records the request.
Our \tcs\ \medname\ \relay monitors requests received by \tcont and forwards them to an SGX enclave.
When $\tcont$ obtains a valid response from $\tcadd$, it sends the resulting datagram $\dgm$ to the entry point \dgcallback specified by the requesting contract \reqcont.
As explained in Section~\ref{sec:shrinking-tcb}, \tcont must check that the response comes from \tcadd and that $\dgform' = \dgform$ to ensure validity.
The first is sufficient to prove that the response was produced by \engine, while the second ensures that \relay cannot corrupt requests despite \engine not performing explicit validation.
\tcont is specified in Fig.~\ref{fig:tc-contract}. Here, Call denotes a call to a contact entry point. 

\begin{figure}[!htb]
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}r@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{{\bf Program for Town Crier blockchain contract \tcont}} \\ [1ex]

  {\bf Initialize:} &  Counter := 0 \\[1ex]

  {\bf Request:} & On recv $(\dgform, \dgcallback)$ from some $\reqcont$: \\
                 & \dgid :=  Counter; \ \ Counter := Counter + 1 \\
                 & Record $(\dgid, \dgform, \dgcallback)$ \hfill \sgray{\it //~\msgi{1}} \\[1ex]

  {\bf Deliver:} & On recv $(\dgid, \dgform, \dgm)$ from $\tcadd$: \\
                 & Retrieve recorded $(\dgid, \dgform', \dgcallback)$ \\
                 & Assert $\dgform = \dgform'$ \\
                 & Call ${\dgcallback}({\dgm})$ \hfill \sgray{\it //~\msgi{4}} \\

  \hline
\end{tabularx}
\caption{
The Town Crier \tcontract \tcont.
}
\label{fig:tc-contract}
\end{figure}

%\vspace{-3mm}
\paragraph{The \encname \engine.} When initialized through {\bf Initialize}(), \engine ingests the current wall-clock time; by storing this time and setting a clock reference point, it calibrates its absolute clock. It generates an ECDSA keypair $(\pkTC,\skTC)$ (parameterized as in Ethereum), where $\pkTC$ is bound to the \engine instance through insertion into attestations.  

Upon a call to {\bf Resume}$({\sf id}, {\sf params})$, \engine contacts the data source specified by {\sf params} via HTTPS and checks that the corresponding certificate {\sf cert} is valid. (We discuss certificate checking in Appendix~\ref{sec:impl}.) Then \engine fetches the requested datagram and returns it to \relay along with $\dgform$ and $\dgid$, all digitally signed with $\skTC$.  Fig.~\ref{fig:engineprotocol} shows the protocol for \engine.

\begin{figure}[!h]
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf Program for \tcs~\encname ($\enclaveprog$)}
\end{center}
\begin{tabular}{l} 
{\bf Initialize}\,$({\sf void})$ \\ %{\it //~called only once upfront}\\
%\quad Set clock reference point\\
%\quad Record $T_0$ \elaine{this is never used} \\ 
%\elaine{i deleted the clock implementation, we can separate abstraction from implementation.}\\
\quad \sgray{\it// Subroutine call from $\fsgx$, which attests to}\\ 
\quad \sgray{\it// $\enclaveprog$ and $\pkTC$. See Figure~\ref{fig:SGX_abstraction}.} \\
\quad $(\pkTC, \skTC) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
%\quad Record $(\pkTC, \skTC)$\\
\quad Output $\pkTC$   \\[3pt]

%{\bf Attest}:  On recv \attcall: \\ %{\it //~called only once upfront}\\
%\quad $T := \clock()$\\
%\quad Call quoting enclave with supp.~data $(\pkTC, T)$
%\\[5pt]

{\bf Resume}\,$(\dgid, \dgform)$\\
\quad Parse ${\sf params}$ as $(\weburl, \dgspec, T) $:\\
\quad Assert $\clock() \geq T.{\sf min}$\\
\quad Contact $\weburl$ via HTTPS, obtaining ${\sf cert}$ \\
\quad Verify {\sf cert} is valid for time $\clock()$\\
\quad Obtain webpage $w$ from $\weburl$ \\
\quad Assert $\clock() \leq T.{\sf max}$\\
\quad Parse $w$ to extract \dgm with specification \dgspec \\
\quad $\sigma := \Sigma.{\sf Sign}({\skTC}, ({\sf id}, {\sf params}, {\sf data}))$\\
\quad Output $(({\sf id}, {\sf params}, {\sf data}), \sigma)$
\end{tabular}
\end{boxedminipage}
\caption{
The \tcs~\encname \engine.
} 
\label{fig:engineprotocol}
\end{figure}

%\vspace{-3mm}
\paragraph{The \medname \relay.}
As noted in Section~\ref{sec:architecture},
\relay bridges the gap between the \encname and the blockchain in three ways.
(1) It scrapes the blockchain and monitors \tcont for new requests $(\dgid, \dgform)$.
(2) It boots the \encname with \engine.{\bf Initialize}() and calls \engine.{\bf Resume}$(\dgid, \dgform)$ on incoming requests.
(3) it forwards datagrams from \engine to the blockchain.
Recall that it forwards already-signed transacations to the blockchain as \tcadd.
%Recall that it sends transactions to the blockchain and thus forwards responses as \tcadd.
The program for \relay is shown in Fig.~\ref{fig:relayprotocol}.
The function {\sf AuthSend} inserts a transaction to blockchain (``as $\tcadd$'' means the transaction is already signed with $\skTC$).
An honest \medname will invoke \engine.{\bf Resume} exactly once with the parameters of each valid request and never otherwise.

\begin{figure}[h!]
\begin{tabularx}{\linewidth}{|@{\hspace{3pt}}p{1em}@{\hspace{1ex}}X@{\hspace{3pt}}|}
  \hline

  \multicolumn{2}{|c|}{\bf Program for Town Crier \medname $\relay$} \\[1ex]

  \multicolumn{2}{|l|}{\bf Initialize:} \\
                    & Send \initcall to $\fsgx[\enclaveprog, \relay]$ \\
                    & On recv $(\pkTC, \sigatt)$ from $\fsgx[\enclaveprog, \relay]$: \\
                    & \quad Publish $(\pkTC, \sigatt)$ \\[1ex]

  \multicolumn{2}{|l|}{{\bf Handle}$(\dgid, \dgform)$:} \\
                    & Parse \dgform as $(\_, \_, T)$ \\
                    & Wait until ${\sf clock}() \geq T.{\sf min}$ \\
                    & Send $(\text{\resumecall}, \dgid, \dgform)$ to $\fsgx[\enclaveprog, \relay]$ \\
                    & On recv $((\dgid, \dgform, \dgm), \sigma)$ from \\ & $\fsgx[\enclaveprog, \relay]$: \\
                    & \quad  {\sf AuthSend} $(\dgid, \dgform, \dgm)$ to \tcont as \tcadd \\
                    & \quad \sgray{\it //~send out $\msgi{3}$} \\[1ex]

  \multicolumn{2}{|l|}{\bf Main:} \\
                    & Loop Forever: \\
                    & \quad Wait for \tcont to records request $(\dgid, \dgform, \_)$: \\
                    & \quad Fork a process of {\bf Handle}$(\dgid, \dgform)$ \\
                    & End \\

  \hline
\end{tabularx}
\caption{The Town Crier \medname \relay.}
\label{fig:relayprotocol}
\end{figure}
