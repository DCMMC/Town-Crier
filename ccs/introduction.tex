\section{Introduction}

Smart contracts are computer programs that autonomously execute the terms of a contract.
For decades they have been envisioned as a way to render legal agreements more precise, pervasive, and efficiently executable.
Szabo, who popularized the term ``smart contact'' in a seminal 1994 essay~\cite{szabosmartcontract94}, gave as an example a smart contract that enforces car loan payments. If the owner of the car fails to make a timely payment, a smart contract could programmatically revoke physical access and return control of the car to the bank. %The contract could additionally be programmed to do so only at a time that is safe for the the owner, e.g., while the car is parked.

Cryptocurrencies such as Bitcoin~\cite{bitcoin} provide key technical underpinnings for smart contracts: direct control of money by programs and fair, automated code execution through the decentralized consensus mechanisms underlying  blockchains. 
The recently launched Ethereum~\cite{yellowpaper,whitepaper} supports Turing-complete code and thus fully expressive, self-enforcing, decentralized smart contracts, a big step toward the vision of researchers and proponents.  
As Szabo's example shows, however, the most compelling applications of smart contracts---such as financial instruments---additionally require access to {\em data about real-world state and events}. 
%Similarly, financial contracts and derivatives, key applications for Ethereum~\cite{yellowpaper,whitepaper}, rely on data about financial markets such as equity prices. %Applications such as insurance policies are only realizable with data about weather, flights, delivery of goods, and so forth. 

\emph{Data feeds} (also known as ``oracles'') aim to meet this need. Very simply, data feeds are contracts on the blockchain that serve data requests by other contracts~\cite{whitepaper,yellowpaper}. A few data feeds exist for Ethereum today that source data from trustworthy websites, but provide no assurance of correctly relaying such data beyond the reputation of their operators (typically individuals or small entities). HTTPS connection to a trustworthy website would seem to offer a solution. Smart contracts, though, lack network access, and HTTPS does not digitally sign data for out-of-band verification. The lack of a substantive ecosystem of trustworthy data feeds is frequently cited as critical obstacle to the evolution of Ethereum and decentralized smart contracts 
in general~\cite{commblockstream}.

\paragraph{\bf Town Crier.} We introduce a system called \emph{Town Crier} (\tc) that addresses this challenge by providing an \emph{authenticated data feed} (ADF) for smart contracts. \tc acts as a high-trust bridge between existing HTTPS-enabled data websites and the Ethereum blockchain. It retrieves website data and serves it to relying contracts on the blockchain as concise pieces of data (e.g., stock quotes) called \emph{datagrams}. \tc uses a novel combination of Software Guard Extensions (SGX), Intel's recently released trusted hardware capability, and a smart-contract front end. It executes its core functionality as a trusted piece of code in an SGX \emph{enclave}, which protects against malicious processes and the OS and can \emph{attest} (prove) to a remote client that the client is interacting with a legitimate, SGX-backed instance of the \tc code. 

The smart-contract front end of \tcs responds to requests by contracts on the blockchain with attestations of the following form:

\vspace{-1ex}
\begin{itemize}[leftmargin=3mm]
  \item[] {``Datagram $X$ specified by parameters $\dgform$ is served by an HTTPS-enabled website $Y$ during a specified time frame $T$.''}
\end{itemize}
\vspace{-1ex}

\noindent A relying contract can verify the correctness of $X$ in such a datagram assuming trust only in the security of SGX, the (published) \tc code, and the validity of source data in the specified interval of time. 

Another critical barrier to smart contract adoption is the lack of {\em confidentiality} in today's ecosystems; all blockchain state is publicly visible, and existing data feeds publicly expose requests. \tc provides confidentiality by supporting {\em private} datagram requests, in which the parameters $\dgform$ are encrypted under a \tc public key for ingestion in \tc's SGX enclave and are therefore concealed on the blockchain. \tc also supports {\em custom} datagram requests, which securely access the online resources of requesters (e.g. online accounts) by ingesting encrypted user credentials, permitting \tc to securely retrieve access-controlled data.

We designed and implemented \tc as a complete, highly scalable, end-to-end system that offers formal security guarantees at the cryptographic protocol level. \tc runs on real, SGX-enabled host, as opposed to an emulator (e.g.~\cite{haven,VC3}). We plan to launch a version of \tc as an open-source, production service atop Ethereum, pending the near-future availability of the Intel Attestation Service (IAS), which is needed for use of SGX attestations. 

%In its initial form, \tcs will serve basic datagram requests to smart contract users essentially for free, requiring users only to defray the (small) cost of invoking \tc on the Ethereum blockchain. 

\paragraph{Technical challenges.} Smart contracts execute in an adversarial environment where parties can reap financial gains by subverting the contracts or services on which they rely. Formal security is thus vitally important. We adopt a rigorous approach to the design of \tcs by modeling it in the Universal Composibility (UC) framework, building on~\cite{hawk,sgxsok} to achieve an interesting formal model that spans a blockchain and trusted hardware. We formally define and prove that \tc achieves the basic property of datagram {\em authenticity}---informally that \tc faithfully relays current data from a target website. We additionally prove {\em fair expenditure} for an honest requester, informally that the fee paid by a user contract calling \tc is at most a small amount to cover the operating costs of the \tc service, even if the \tc host and other blockchain entities are malicious.
\ethan{Other blockchain entities? What is that referring to? Can we just remove that?}

Another contribution of our work is introducing and showing how to achieve two key security properties: {\em gas sustainability} and {\em TCB code minimization} within a new TCB model created by \tc's combination of a blockchain with SGX. 

Because of the high resource costs of decentralized code execution and risk of application-layer denial-of-service (DoS) attacks, Ethereum includes an accounting resource called {\em gas} to pay for execution costs.  Informally, {\em gas sustainability} means that an Ethereum service never runs of out of gas, a general and fundamental availability property. We give a formal definition of gas sustainability applicable to any Ethereum service, and prove that \tc satisfies it.

% offering a model for proving the property in other Ethereum services and one that may be extensible to other decentralized smart contract systems. 

We believe that the combination of blockchains with SGX introduced in our work will prove to be a powerful, general way to achieve confidentiality in smart contract systems and network them with off-chain systems. This new security paradigm, however, introduces a hybridized trusted computing base (TCB) that spans components with different trust models. We introduce techniques for using such a hybridized TCB securely while {\em minimizing the TCB code size}. In \tc, we show how to avoid constructing an authenticated channel from the blockchain to the enclave---bloating the enclave with an Ethereum client---by instead authenticating enclave outputs on the blockchain. We also show how to minimize on-chain signature-verification code. These techniques are general; they apply to any use of a similar hybridized TCB.

Other interesting smaller challenges arise in the design of \tc. One is deployment of TLS in an enclave. Enclaves lack networking capabilities, so TLS code must be carefully partitioned between the enclave and untrusted host environment. Another is hedging in \tc against the risk of compromise of a website or single SGX instance, which we accomplish with various modes of majority voting: among multiple websites offering the same piece of data (e.g. stock price) or among multiple SGX platforms.

\paragraph{Applications and performance.} 
%Today, smart contracts in Ethereum tend to be blockchain-bound, with little or no use of external data~\cite{}. 
We believe that \tc can spur deployment of a rich spectrum of smart contracts that are hard to realize in the existing Ethereum ecosystem. We explore three examples that demonstrate \tc's capabilities: (1) A financial derivative (cash-settled put option) that consumes stock ticker data; (2) A flight insurance contract that relies on private data requests about flight cancellations; and (3) A contract for sale of virtual goods and online games (via Steam Marketplace) for Ether, the Ethereum currency, using custom data requests to access user accounts. 

Our experiments with these three applications show that \tc is highly scalable. Running on just a single SGX host, \tc achieves throughputs of 15-65 tx/sec. \tc is easily parallelized across many hosts, as separate \tc hosts can serve requests with no interdependency. (For comparison, Ethereum handles less than 1 tx/sec today and recent work~\cite{blockchainscaling} suggests that Bitcoin can scale safely to no more 26 tx/sec with reparametrization.) For these same applications, experimental response times for datagram requests range from 192-1309 ms---much less than an Ethereum block interval (12 seconds on average). These results suggest that a few SGX-enabled hosts can support \tc data feed rates well beyond the global transaction rate of a modern decentralized blockchain.

\paragraph{\bf Contributions.}
We offer the following contributions:
\begin{itemize}[leftmargin=5mm]
\item
  \setlength{\itemsep}{2pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
We introduce and report on an end-to-end implementation of \tcs, an authenticated data feed system that addresses critical barriers to the adoption of decentralized smart contracts. \tc combines a smart-contract front end in Ethereum and an SGX-based trusted hardware back end to: (1) Serve authenticated data to smart contracts without a trusted service operator and (2) Support {\em private} and {\em custom} data requests, enabling encrypted requests and secure use of access-controlled, off-chain data sources. We plan to launch a version of \tc soon as an open-source service.
\item We formally analyze the security of \tc within the Universal Composibility (UC) framework, defining functionalities to represent both on-chain and off-chain components. We formally define and prove the basic properties of datagram {\em authenticity} and {\em fair expenditure} as well as {\em gas sustainability}, a fundamental availability property for any Ethereum service. 
\item We introduce in \tc a hybridized TCB spanning the blockchain and an SGX enclave, a powerful new paradigm of trustworthy system composition. We present generic techniques that help shrink the TCB code size within this model as well as techniques to hedge against individual SGX platform compromises. 
\item We explore three \tc applications that show \tc's ability to support a rich range of services well beyond those in Ethereum today. Experiments with these applications also show that \tc can easily meet the latency and throughput requirements of modern decentralized blockchains. 

\end{itemize}

%\paragraph{\em Organization:} We present basic technical background for \tc (Section~\ref{sec:background}), followed by an architectural description (Section~\ref{sec:architecture}), a basic set of protocols (Section~\ref{sec:protocols}), the full, enhanced system protocols (Section~\ref{sec:enhanced_protocol}), and a formal security analysis (Section~\ref{sec:analysis}). We then present three example applications (Section~\ref{sec:applications}) which we use as the basis for performance evaluations of \tc (Section~\ref{sec:experiments}).  After presenting related work (Section~\ref{sec:related}), we conclude the paper (Section~\ref{sec:conclude}). The paper appendix includes implementation details, formal modeling and proofs, and future directions omitted from the paper body.




