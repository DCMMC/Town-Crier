\section{TCB Hybirdization}
\label{sec:tcb-hybridization}

\begin{figure}[ht]
\begin{boxedminipage}{\columnwidth}
\begin{center}
  {\bf $\textsf{prog}_{\textsf{Off}}$: abstraction for Off-Chain TCB}
\end{center}
\vspace{-2mm}
\begin{tabular}{ll}
  {\bf Initialize:} & $(\pk, \sk) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
                    & Output $\pk$  \\
  {\bf Resume:} & On receive (\textsf{req}): \\
                & {\color{red} Assert $\mathcal{O}_\textsf{auth}$(\textsf{req}) }\\
                & \textsf{resp} := $f(\textsf{req})$ \\
                & $\sigma := \Sigma.{\sf Sign}({\sk}, (\textsf{req}, {\sf resp}))$\\
                & Output $(({\sf req}, {\sf resp}), \sigma)$ \\
\end{tabular}

\begin{center}
  {\bf $\mathcal{F}_{\textsf{On}}$: abstraction for On-Chain TCB}
\end{center}
\vspace{-2mm}
\begin{tabular}{ll}
  {\bf Request:} & On recv $(\textsf{req})$ from some $\reqcont$: \\
                 & Send $(\textsf{req})$  to $\fsgx[\textsf{prog}_{\textsf{Off}}, \relay]$\\

  {\bf Deliver:} & On recv $((\textsf{req}', \textsf{resp}), \sigma)$ from \fsgx: \\
                 & {\color{red} $\Sigma$.Verify($((\textsf{req}', \textsf{resp}), \sigma)$) }\\
                 & // \sgray{can use $\textsf{resp}$ from now on}
\end{tabular}
\end{boxedminipage}
\caption{Systems like \tc have a hybrid TCB. Authentication between two parts can incur large
TCB size if implemented naively. We proposed tricks to eliminate the expensive parts (
highlighted in red).}
\label{fig:tcb-hybridization}
\end{figure}

In a system involving a smart contract interacting with an off-chain trusted computing environment (e.g. an SGX),
the TCB is a hybridization of two components with distinct properties.
Computation in the smart contract is slow, costly, and completely transparent, meaning it cannot rely on secrets.
An SGX is computationally powerful and executes privately, but all external interaction, notably including communication with the contract, must go through an untrusted intermediary.
This presents a challenge to establishing secure communication between the components while minimizing the TCB to allow for easier correctness analysis.

%In a system involving an off-chain trusted execution environment such as SGX
%interacting with a smart contract, its TCB is a hybridization of two
%heterogeneous functionalities with distinct properties.  The SGX part, or the
%off-chain part of the TCB, is computationally powerful and can be executed
%privately. On the other hand, the computation in the on-chain part (i.e. the
%smart contract) is relatively slow and costly but verifiable. Moreover,
%since the execution of smart contracts is transparent, it is impossible to sign
%or computing MAC from within a smart contract. Both parts enjoy the integrity guarantee,
%but all interaction must go through an untrusted intermediary. 
%The challenge, therefore, is to establish secure communication channels between
%them and keep the TCB minimal. 

Fig. \ref{fig:tcb-hybridization} depicts the
ideal functionalities of off-chain and on-chain TCB that we need to realize.
In Fig. \ref{fig:tcb-hybridization}, we model the authentication of on-chain
messages by an oracle $\mathcal{O}_\textsf{auth}$, which takes in a message
and returns a boolean indicating whether the input is valid.
Since the blockchain we are working with is self-authenticated using Merkle
tree~\fan{ref}, in theory we can realize $\mathcal{O}_\textsf{auth}$
by including a Ethereum client in the TCB. But doing so blows the TCB size up 
significantly \fan{fill in concrete LoC}.
Similarly, in the other direction a smart contract can
authenticate the messages coming from an SGX platform by checking the
signatures. But implementing
signature verification in a smart contract is error-prone and 
computationally expensive. Verifying ECDSA signatures
is supported in Solidity \fan{ref} but still costs extra gas.
Therefore we applied two tricks here to eliminate both $\mathcal{O}_\textsf{auth}$
and signature verification from the TCB.


\iffalse
As described in Section~\ref{sec:architecture}, \tc has two trusted components: the \encname and \tcont.
These components must communicate with each other, but can only do so over insecure channels (through the \medname).
Moreover, these components comprise very different properties.
\tcont resides on the blockchain where users can interact directly with \tc and all computation is verifiable, expensive, and transparent.
The \encname provides a private and less expensive environment, but all interaction (user or otherwise) must go through an untrusted intermediary.

The simplest way to ensure authentic communication between the components is to have both perform verification;
\tcont receives signed messages from the \encname and verifies the signatures,
and the \encname receives raw blocks and verifies that they are well-formed.
Unfortunately, both of these verification mechanisms require a large amount of computation and complex code.
\fi

\paragraph{Eliminating explicit signature verification}

We describe above how we bind the \encname to an Ethereum wallet, which removes the need to do explicit signature verification in \tcont (which would be extremely expensive).
\fan{To be filled. Plan to borrow some text from the section (4.3).}

\paragraph{Eliminating $\mathcal{O}_\textsf{auth}$}

\fan{Below is Ethan's text. Plan to make it not TC-specific.}
In order to reduce the cost of calling $\mathcal{O}_\textsf{auth}$ inside the \encname, we leverage the fact that all messages from the \encname to \tcont are responses to existing requests.
Instead of verifying the request parameters in the \encname, we can verify in \tcont that the \encname is responding to the correct request.
For each request, \tcont stores the parameters of that request and the \encname includes the parameters it used to fulfill a request in its response.
This allows \tcont to check that the parameters match and simply reject the response if they do not.
Because storing parameters and checking equality are extremely simple, this removes a complex verification step from the TCB.

While this may appear to open some attack (e.g., the \medname can send bogus requests and the \encname will attempt to respond),
all of these attacks amount to DoS attacks from the network or the \medname---attacks to which we were already susceptible.

We note that this technique is actually quite general.
Given any system with two trusted components communicating over an insecure channel, if one component only response to requests from the other,
the requesting component can store parameters and the responding component can include them in a response.
This allows the responding component to omit integrity verification on its incoming requests without compromising the integrity of the system as a whole.





