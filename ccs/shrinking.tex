\section{TCB Hybirdization}
\label{sec:tcb-hybridization}

%% some macros used within this doc
\newcommand{\tcboff}{\ensuremath{\textsf{prog}_{\textsf{Off}}}\xspace}
\newcommand{\tcbon}{\ensuremath{\mathcal{F}_{\textsf{On}}}\xspace}
\newcommand{\oauth}{\ensuremath{\mathcal{O}_{\textsf{Auth}}}\xspace}

\begin{figure}[ht]
\begin{boxedminipage}{\columnwidth}
\begin{center}
  {\bf \tcboff: abstraction for off-chain TCB}
\end{center}
\vspace{-2mm}
\begin{tabular}{l}
  {\bf Initialize}(\textsf{void}):  \\
    \quad $(\pk, \sk) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
    \quad Output $\pk$  \\[2mm]
  {\bf Resume}(\textsf{req}): \\

  \quad {\color{red} Assert \oauth (\textsf{req}) }\\
  \quad \textsf{resp} := $f(\textsf{req})$ \\
  \quad $\sigma := \Sigma.{\sf Sign}({\sk}, (\textsf{req}, {\sf resp}))$\\
  \quad Output $(({\sf req}, {\sf resp}), \sigma)$ \\
\end{tabular}

\begin{center}
  {\bf \tcbon: abstraction for on-chain TCB}
\end{center}
\vspace{-2mm}
\begin{tabular}{l}
  {\bf Request:} \\ 
  On recv $(\textsf{req})$ from some $\reqcont$: \\
  \quad Send $(\textsf{req})$  to $\fsgx[\textsf{prog}_{\textsf{Off}}, \relay]$\\[2mm]

  {\bf Deliver:} \\
  On recv $((\textsf{req}', \textsf{resp}), \sigma)$ from \fsgx: \\
  \quad {\color{red} $\Sigma$.Verify($((\textsf{req}', \textsf{resp}), \sigma)$) }\\
  \quad // \sgray{can use $\textsf{resp}$ from now on}
\end{tabular}
\end{boxedminipage}
\caption{Systems like \tc have a hybrid TCB. Authentication between two parts
can incur large TCB size if implemented naively. We proposed tricks to eliminate
the expensive parts (highlighted in red).}
\label{fig:tcb-hybridization}
\end{figure}

In a system involving a smart contract interacting with an off-chain trusted computing environment (e.g. an SGX),
the TCB is a hybridization of two components with distinct properties.
Computation in the smart contract is slow, costly, and completely transparent, meaning it cannot rely on secrets.
An SGX is computationally powerful and executes privately, but all external interaction, notably including communication with the contract, must go through an untrusted intermediary.
This presents a challenge to establishing secure communication between the components while minimizing the TCB to allow for easier correctness analysis.

%In a system involving an off-chain trusted execution environment such as SGX
%interacting with a smart contract, its TCB is a hybridization of two
%heterogeneous functionalities with distinct properties.  The SGX part, or the
%off-chain part of the TCB, is computationally powerful and can be executed
%privately. On the other hand, the computation in the on-chain part (i.e. the
%smart contract) is relatively slow and costly but verifiable. Moreover,
%since the execution of smart contracts is transparent, it is impossible to sign
%or computing MAC from within a smart contract. Both parts enjoy the integrity guarantee,
%but all interaction must go through an untrusted intermediary. 
%The challenge, therefore, is to establish secure communication channels between
%them and keep the TCB minimal. 

Fig. \ref{fig:tcb-hybridization} depicts the
ideal functionalities of off-chain and on-chain TCB that we need to realize.
In Fig. \ref{fig:tcb-hybridization}, we model the authentication of on-chain
messages by an oracle \oauth, which takes in a message
and returns a boolean indicating whether the input is valid.
Since the blockchain we are working with is self-authenticated using Merkle
tree~\fan{ref}, in theory we can realize \oauth
by including a Ethereum client in the TCB. But doing so blows the TCB size up 
significantly \fan{fill in concrete LoC}.
Similarly, in the other direction a smart contract can
authenticate the messages coming from an SGX platform by checking the
signatures. But implementing
signature verification in a smart contract is error-prone and 
computationally expensive. Verifying ECDSA signatures
is supported in Solidity \fan{ref} but still costs extra gas.
Therefore we applied two tricks here to eliminate both \oauth
and explicit signature verification from the TCB.


\iffalse
As described in Section~\ref{sec:architecture}, \tc has two trusted components: the \encname and \tcont.
These components must communicate with each other, but can only do so over insecure channels (through the \medname).
Moreover, these components comprise very different properties.
\tcont resides on the blockchain where users can interact directly with \tc and all computation is verifiable, expensive, and transparent.
The \encname provides a private and less expensive environment, but all interaction (user or otherwise) must go through an untrusted intermediary.

The simplest way to ensure authentic communication between the components is to have both perform verification;
\tcont receives signed messages from the \encname and verifies the signatures,
and the \encname receives raw blocks and verifies that they are well-formed.
Unfortunately, both of these verification mechanisms require a large amount of computation and complex code.
\fi


\paragraph{Eliminating \oauth}

In order to reduce
the cost of calling \oauth inside the \tcboff, we leverage
the fact that all messages from the \tcboff to \tcbon  are responses to existing
requests.  Instead of verifying the request parameters in the \tcboff, we can
verify in \tcbon that the \tcboff is responding to the correct request.  For
each request, \tcbon stores the parameters of that request and the \tcboff
includes the parameters it used to fulfill a request in its response.  This
allows \tcbon to check that the parameters match and simply reject the response
if they do not.  Because storing parameters and checking equality are extremely
simple, this removes a complex verification step from the TCB.

While this may appear to open some attack (e.g., the \medname can send bogus
requests and the \tcboff will attempt to respond), all of these attacks amount
to DoS attacks from the network or the \medname---attacks to which we were
already susceptible.


\paragraph{Eliminating explicit signature verification
by binding \tcboff to an Ethereum wallet \tcadd}

Unlike in off-chain TCB, computation in on-chain TCB is so slow and expensive, which
essentially eliminates the possibility of implementing any digital signature
verification (e.g. Intel's EPID) as part of the smart contract.
Although ECDSA signature verification happens to be supported in Ethereum via
precompiled contracts \fan{ref to YP}, but it still costs extra gas.
We'll describe below how we can bind the identity of \tcboff 
to an Ethereum wallet, which removes
the need to do any form of explicit signature verification in \tcbon.

The key observation is that information can only be inserted into the blockchain
in Ethereum as a transaction from a wallet.  Thus, the only way the \medname can
relay messages from the \tcboff to \tcbon is through a wallet \tcadd.  
Since Ethereum itself already verifies
signatures on transactions from externally owned accounts (i.e., users interact
with the Ethereum blockchain through an authenticated channel), we can 
piggyback verification of \tcboff signatures on top of Ethereum's
already existing transaction signature verification mechanism.  Very simply,
the \tcboff creates \tcadd with the fresh public key \pk known only to 
\tcboff itself. 

To make this idea work fully, the public key $\pk$ must be hardcoded into
\tcbon. A client creating or relying on a contract that uses \tcbon is
responsible for making sure that this hardcoded $\pk$ has an appropriate SGX
attestation before interacting with the $\tcbon$.  Let {\sf
Verify} denote a verification algorithm for EPID signatures.
Fig.~\ref{fig:att_check} gives the protocol for a client to check that \tcbon is
backed by a valid \tcboff instance. (We omit modeling here of IAS online
revocation checks.)

In summary, then, we may assume in our protocol specifications that {\em relying
clients have verified an attestation for \tcboff and thus that datagram
responses sent from \tcadd to \tcbon are trusted to originate from \tcboff},
thus eliminating the need to do costly EPID signature verification in \tcbon.

We note that this technique is actually quite general.  Given any system with
two trusted components communicating over an insecure channel, if one component
only response to requests from the other, the requesting component can store
parameters and the responding component can include them in a response.  This
allows the responding component to omit integrity verification on its incoming
requests without compromising the integrity of the system as a whole.

\begin{figure}[htb!]
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf User: offline verification of SGX attestation}
\end{center}
\vspace{-1ex}
\begin{tabular}{l}
{\bf {\em Inputs}}: $\pkM$, $\pkTC$, $\enclaveprog$, $\sigatt$ \\[5pt]
{\bf Verify:} \\
Assert $\enclaveprog$ is the expected enclave code\\
Assert $\sigsgx.{\sf Verify}(\pkM, \sigatt, (\enclaveprog, \pkTC))$ \\
Assert \tcont is correct and parametrized w/ \pkTC\\
\sgray{\it //~now okay to rely on \tcont}
\end{tabular}
\end{boxedminipage}
\caption{A client checks an SGX attestation on the enclave's code $\enclaveprog$ and public key $\pkTC$.
  The client also checks that $\pkTC$ is hardcoded into \tc blockchain contract \tcont before using \tcont.
} 
\label{fig:att_check}
\end{figure}
