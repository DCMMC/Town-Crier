\section{TCB Hybirdization}
\label{sec:tcb-hybridization}

\begin{figure}[ht]
\begin{boxedminipage}{\columnwidth}
\begin{center}
  {\bf $\textsf{prog}_{\textsf{Off}}$: abstraction for Off-Chain TCB}
\end{center}
\vspace{-2mm}
\begin{tabular}{ll}
  {\bf Initialize:} & $(\pk, \sk) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
                    & Output $\pk$  \\
  {\bf Resume:} & On receive (\textsf{req}): \\
                & {\color{red} Assert $\mathcal{O}_\textsf{auth}$(\textsf{req}) }\\
                & \textsf{resp} := $f(\textsf{req})$ \\
                & $\sigma := \Sigma.{\sf Sign}({\sk}, (\textsf{req}, {\sf resp}))$\\
                & Output $(({\sf req}, {\sf resp}), \sigma)$ \\
\end{tabular}

\begin{center}
  {\bf $\mathcal{F}_{\textsf{On}}$: abstraction for On-Chain TCB}
\end{center}
\vspace{-2mm}
\begin{tabular}{ll}
  {\bf Request:} & On recv $(\textsf{req})$ from some $\reqcont$: \\
                 & Send $(\textsf{req})$  to $\fsgx[\textsf{prog}_{\textsf{Off}}, \relay]$\\

  {\bf Deliver:} & On recv $((\textsf{req}', \textsf{resp}), \sigma)$ from \fsgx: \\
                 & {\color{red} $\Sigma$.Verify($((\textsf{req}', \textsf{resp}), \sigma)$) }\\
                 & // \sgray{can use $\textsf{resp}$ from now on}
\end{tabular}
\end{boxedminipage}
\caption{Hybrid TCB} 
\label{fig:tcb-hybridization}
\end{figure}

In a system involving an off-chain trusted execution environment such as SGX
interacting with a smart contract, its TCB is a hybridization of two
heterogeneous functionalities with distinct properties.  The SGX part, or the
off-chain part of the TCB, is computationally powerful and can be executed
privately. On the other hand, the on-chain part (i.e. the smart contract) is
relatively slow and costly to perform any computation. Moreover, since the
execution of smart contracts is transparent, it is impossible to sign or
authenticate messages from within a smart contract.  Assuming the security of
trusted hardware and smart contracts, the integrity of both parts is guaranteed.
The challenge, however, is to establish secure communication channels between them
and keep the TCB minimal. 

Fig. \ref{fig:tcb-hybridization} depicts the
ideal functionalities of off-chain and on-chain TCB that we need to realize.
In Fig. \ref{fig:tcb-hybridization}, we model the authentication of on-chain
messages by an oracle $\mathcal{O}_\textsf{auth}$, which takes in a message
and returns a boolean indicating whether the input is indeed present on the
blockchain. 
Since the blockchain we are working with is self-authenticated using Merkle
tree~\fan{ref}, in theory we can to realize $\mathcal{O}_\textsf{auth}$
by including a Ethereum client in the TCB. But doing so blows the TCB size up 
significantly \fan{fill in concrete LoC}.
Similarly, in the other direction a smart contract can
authenticate the messages coming from an SGX platform by checking the
signatures signed by $\textsf{prog}_\textsf{Off}$. However implementing
signature verification in smart contract is error-prone and 
computationally expensive. Verifying ECDSA signatures
is supported in Solidity \fan{ref} but still costs extra gas.

\fan{I stopped here.}

As described in Section~\ref{sec:architecture}, \tc has two trusted components: the \encname and \tcont.
These components must communicate with each other, but can only do so over insecure channels (through the \medname).
Moreover, these components comprise very different properties.
\tcont resides on the blockchain where users can interact directly with \tc and all computation is verifiable, expensive, and transparent.
The \encname provides a private and less expensive environment, but all interaction (user or otherwise) must go through an untrusted intermediary.

The simplest way to ensure authentic communication between the components is to have both perform verification;
\tcont receives signed messages from the \encname and verifies the signatures,
and the \encname receives raw blocks and verifies that they are well-formed.
Unfortunately, both of these verification mechanisms require a large amount of computation and complex code.

We describe above how we bind the \encname to an Ethereum wallet, which removes the need to do explicit signature verification in \tcont (which would be extremely expensive).
In order to reduce the cost of this verification inside the \encname, we leverage the fact that all messages from the \encname to \tcont are responses to existing requests.
Instead of verifying the request parameters in the \encname, we can verify in \tcont that the \encname is responding to the correct request.
For each request, \tcont stores the parameters of that request and the \encname includes the parameters it used to fulfill a request in its response.
This allows \tcont to check that the parameters match and simply reject the response if they do not.
Because storing parameters and checking equality are extremely simple, this removes a complex verification step from the TCB.

While this may appear to open some attack (e.g., the \medname can send bogus requests and the \encname will attempt to respond),
all of these attacks amount to DoS attacks from the network or the \medname---attacks to which we were already susceptible.

We note that this technique is actually quite general.
Given any system with two trusted components communicating over an insecure channel, if one component only response to requests from the other,
the requesting component can store parameters and the responding component can include them in a response.
This allows the responding component to omit integrity verification on its incoming requests without compromising the integrity of the system as a whole.





