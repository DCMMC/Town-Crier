\section{Two Key Security Properties}

Before presenting the \tc protocol in detail,  we now discuss two key security properties informing its design: gas sustainability and TCB minimization within the hybridized TCB model that \tc introduces. While we introduce them in this work, as we shall explain, they are of broad and general applicability.

\subsection{Gas Sustainability}
\label{sec:gas-sustainability}

%Recall from Section~\ref{sec:contracts-and-gas} that computation in Ethereum is not free; it employs \emph{gas} to fuel contracts.
%For a call to a contract, that cost is paid by the user who initiates the transaction, regardless of what other contracts are called as part of execution.
As explained above, Ethereum's fee model requires that gas be paid by the user who initiates a transaction, including all gas resulting from dependent calls. 
This means that a service that initiates calls to Ethereum contracts must spend money to execute those calls.
Without careful design, such services run the risk of malicious users (or protocol bugs) draining financial resources by triggering blockchain calls for which the service's fees will not be reimbursed, resulting in financial depletion of the service and an application-layer denial-of-service attack.
It is thus critical for the availability of Ethereum-based services that they always be reimbursed for blockchain computation they initiate.

To ensure that a service is not vulnerable to such attacks, we define \emph{gas sustainability}, a new condition necessary for the liveness of blockchain contract-based services. Gas sustainability is a basic requirement for any self-perpetuating Ethereum service. It can also generalize beyond Ethereum: Any decentralized blockchain-based smart contract system must require fees of some kind to reimburse miners for performing and verifying computation. 

Let \bal{\wallet} denote the balance of an Ethereum wallet \wallet.

\begin{definition}[$K$-Gas Sustainability]
  \label{def:gas-sustainability}
  A service with wallet \wallet and blockchain functions $f_1, \dotsc, f_n$ is \emph{$K$-gas sustainable} if the following holds.
If $\bal{\wallet} \geq K$ prior to execution of any $f_i$ and the service behaves honestly,
  then after each execution of an $f_i$ initiated by \wallet, $\bal{\wallet} \geq K$.
\end{definition}

Recall that a call made in Ethereum with insufficient gas will abort, but spend all provided gas. While Ethereum trivially guarantees 0-gas sustainability, if a transaction is submitted by a wallet with insufficient funds, the wallet's balance will drop to 0.
Therefore, to be $K$-gas sustainable for $K > 0$, each blockchain call made by the service must reimburse gas expenditures.
Moreover, the service must have sufficient gas for each call. Otherwise such reimbursement will be reverted with the rest of the transaction.

The need for gas sustainability (with $K > 0$, as required by \tc) informs our protocol design in Section~\ref{sec:protocol}. We prove that \tc achieves this property in Section~\ref{sec:analysis}.

\subsection{TCB Hybridization Model and TCB Minimization}
\label{sec:tcb-hybridization}

%% some macros used within this doc
\newcommand{\tcboff}{\ensuremath{\mathcal{A}_{\textsf{Off}}}\xspace}
\newcommand{\tcbon}{\ensuremath{\mathcal{A}_{\textsf{On}}}\xspace}
\newcommand{\oauth}{\ensuremath{\mathcal{O}_{\textsf{Auth}}}\xspace}
\newcommand{\pkoff}{\ensuremath{\textsf{pk}_{\textsf{Off}}}\xspace}

\begin{figure}[ht]
\begin{boxedminipage}{\columnwidth}
\begin{center}
  {\bf \tcboff: abstraction for off-chain TCB}
\end{center}
\vspace{-1ex}
\begin{tabular}{l}
  {\bf Initialize}(\textsf{void}):  \\
    \quad $(\pk, \sk) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
    \quad Output $\pk$  \\[1ex]

  {\bf Resume}(\textsf{req}): \\
    \quad {\color{red} Assert $\oauth ({\sf req})$}\\
    \quad \textsf{resp} := $f(\textsf{req})$ \\
    \quad $\sigma := \Sigma.{\sf Sign}({\sk}, (\textsf{req}, {\sf resp}))$\\
    \quad Output $(({\sf req}, {\sf resp}), \sigma)$ \\
\end{tabular}

\begin{center}
  {\bf \tcbon: abstraction for on-chain TCB}
\end{center}
\vspace{-1ex}
\begin{tabular}{l}
  {\bf Request:} \\ 
    On recv $(\textsf{req})$ from some $\reqcont$: \\
    \quad Send $(\textsf{req})$  to $\fsgx[\textsf{prog}_{\textsf{Off}}, \relay]$\\[1ex]

  {\bf Deliver:} \\
    On recv $((\textsf{req}', \textsf{resp}), \sigma)$ from \fsgx: \\
    \quad {\color{red} $\Sigma.{\sf Verify}((\textsf{req}', \textsf{resp}), \sigma)$} \\
    \quad \sgray{//~can now use {\sf resp} as trusted}
\end{tabular}
\end{boxedminipage}
\caption{Systems like \tc have a hybrid TCB. Authentication between two components
can greatly increase TCB complexity of implemented naively.
We propose techniques to eliminate the most expensive operations (highlighted in red).}
\label{fig:tcb-hybridization}
\end{figure}

In a system involving a smart contract interacting with an off-chain trusted computing environment (e.g. SGX),
the TCB is a hybridization of two components with distinct properties.
Computation in the smart contract is slow, costly, and completely transparent, meaning it cannot rely on secrets.
An SGX enclave is computationally powerful and executes privately, but all external interaction, notably including communication with the contract, must go through an untrusted intermediary. While this hybridized TCB is powerful and generally useful well beyond \tc, it presents a challenge: establishing secure communication between the components while minimizing the code in the TCB.

%In a system involving an off-chain trusted execution environment such as SGX
%interacting with a smart contract, its TCB is a hybridization of two
%heterogeneous functionalities with distinct properties.  The SGX part, or the
%off-chain part of the TCB, is computationally powerful and can be executed
%privately. On the other hand, the computation in the on-chain part (i.e. the
%smart contract) is relatively slow and costly but verifiable. Moreover,
%since the execution of smart contracts is transparent, it is impossible to sign
%or computing MAC from within a smart contract. Both parts enjoy the integrity guarantee,
%but all interaction must go through an untrusted intermediary. 
%The challenge, therefore, is to establish secure communication channels between
%them and keep the TCB minimal. 

We begin by defining abstractions for both TCB components, shown in Fig.~\ref{fig:tcb-hybridization}. To distinguish these abstractions from formal ideal functionalities, we denote them by $\mathcal{A}$, rather than $\mathcal{F}$.
We model the authentication of on-chain messages by an oracle \oauth, which takes a message and returns true if the input is a valid blockchain transaction.
Since Ethereum blocks are self-authenticated using Merkle trees \cite{whitepaper,yellowpaper},
in principle we can realize \oauth by including an Ethereum client in the TCB.
However, doing so drastically increases the code footprint, as the core Ethereum implementation is about 50k lines of C++.
Similarly, a smart contract could authenticate messages from an SGX by checking attestations.
But implementing this verification in a smart contract would be error-prone and computationally (and thus financially) expensive.

Instead we propose two general techniques to avoid these calls and thereby minimize code size in the TCB.
The first applies to any hybrid system where one TCB component is a blockchain contract.
The second applies to any hybrid system where the TCB components communicate only to make and respond to requests.

%Fig. \ref{fig:tcb-hybridization} depicts the
%ideal functionalities of off-chain and on-chain TCB that we need to realize.
%In Fig. \ref{fig:tcb-hybridization}, we model the authentication of on-chain
%messages by an oracle \oauth, which takes in a message
%and returns a boolean indicating whether the input is a valid 
%transaction on the blockchain.
%Since Ethereum blockchain is self-authenticated using Merkle
%tree~\cite{yellowpaper}, in theory we can realize \oauth
%by including a Ethereum client in the TCB. But doing so blows the TCB size up 
%significantly (the core of Ethereum implements contains about 50k lines of C/C++ code).
%Similarly, in the opposite direction a smart contract can
%authenticate messages coming from an SGX by checking 
%attestations. But implementing
%signature verification in a smart contract is error-prone and 
%computationally expensive. Verification of ECDSA signatures
%happens to be supported in Ethereum via a precompiled contract~\cite{yellowpaper}
%but still costs extra gas.
%Therefore we proposed two techniques that eliminate both \oauth
%and explicit signature verification from the TCB. These techniques 
%are quite general and can be applied to any system involving
%such a hybrid TCB.
%
%\iffalse
%As described in Section~\ref{sec:architecture}, \tc has two trusted components: the \encname and \tcont.
%These components must communicate with each other, but can only do so over insecure channels (through the \medname).
%Moreover, these components comprise very different properties.
%\tcont resides on the blockchain where users can interact directly with \tc and all computation is verifiable, expensive, and transparent.
%The \encname provides a private and less expensive environment, but all interaction (user or otherwise) must go through an untrusted intermediary.
%
%The simplest way to ensure authentic communication between the components is to have both perform verification;
%\tcont receives signed messages from the \encname and verifies the signatures,
%and the \encname receives raw blocks and verifies that they are well-formed.
%Unfortunately, both of these verification mechanisms require a large amount of computation and complex code.
%\fi


\paragraph{Binding \tcboff to \tcadd.}
Due to the speed and cost of computation in the on-chain TCB, we wish to avoid implementing signature verification (e.g. Intel's EPID).
There does exist a precompiled Ethereum contract to verify ECDSA signatures \cite{yellowpaper}, but the operation requires a high gas cost.
Instead, we describe here how to bind the identity of \tcboff to an Ethereum wallet, which allows \tcbon to simply check the message sender,
which is already verified as part of Ethereum's transaction protocol.

The key observation is that information can only be inserted into the Ethereum blockchain as transactions from a wallet.
thus, the only way the \medname can relay messages from \tcboff to \tcbon is through a wallet \tcadd.
Since Ethereum itself already verifies signatures on transactions (i.e., users interact with Ethereum through an authenticated channel),
we can piggyback verification of \tcboff signatures on top of the existing transaction signature verification mechanism.
Simply put, the \tcboff creates \tcadd with a fresh public key \pkoff whose secret is known only to \tcboff.

To make this idea work fully, the public key \pkoff must be hardcoded into \tcbon.
A client creating or relying on a contract that uses \tcbon is responsible for ensuring that this hardcoded \pkoff has an appropriate SGX attestation before interacting with \tcbon.
Let {\sf Verify} denote a verification algorithm for EPID signatures.
Fig.~\ref{fig:att_check} gives the protocol for a client to check that \tcbon is backed by a valid \tcboff instance.
(We omit the modeling here of IAS online revocation checks.)

In summary, then, we may assume in our protocol specifications that relying
clients have verified an attestation for \tcboff and thus that datagram
responses sent from \tcadd to \tcbon are trusted to originate from \tcboff.
This eliminates the need to do costly EPID signature verification in \tcbon.

\begin{figure}[htb!]
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf User: offline verification of SGX attestation}
\end{center}
\vspace{-1ex}
\begin{tabular}{l}
{\bf {\em Inputs}}: $\pkM$, $\pkoff$, $\tcboff$, $\sigatt$ \\[5pt]
{\bf Verify:} \\
Assert $\pkoff$ is the expected enclave code\\
Assert $\sigsgx.{\sf Verify}(\pkM, \sigatt, (\tcboff, \pkoff))$ \\
Assert \tcbon is correct and parametrized w/ \pkoff\\
\sgray{\it //~now okay to rely on \tcbon}
\end{tabular}
\end{boxedminipage}
\caption{A client checks an SGX attestation on the enclave's code $\tcboff$
and public key $\pkoff$.  The client also checks that $\pkoff$ is hardcoded into
blockchain contract \tcbon before using \tcbon.} 
\label{fig:att_check}
\end{figure}


\paragraph{Eliminating \oauth.}
In order to eliminate the need to call \oauth inside of \tcboff, we leverage the fact that all messages from \tcboff to \tcbon are responses to existing requests.
Instead of verifying the request parameters in \tcboff, we can verify in \tcbon that \tcboff responded to the correct request.
For each request, \tcbon stores the parameters of that request.
In each response, \tcboff includes the parameters it used to fulfil the request.
This allows \tcbon to check that the parameters in the response match the stored parameters
and simply reject the response if they do not.
Storing parameters and checking equality are extremely simple operations, so this far simpler than calling \oauth inside \tcboff.

This may appear to open new attacks (e.g., the \medname can send bogus requests and the \tcboff will attempt to respond).
As we prove in Section~\ref{sec:analysis}, however, all such attacks reduce to DoS attacks from the network or the \medname---attacks to which hybrid TCB systems are inherently susceptible and which we do not aim to protect against in \tc.

%We note that this technique is actually quite general.  Given any system with
%two trusted components communicating over an insecure channel, if one component
%only response to requests from the other, the requesting component can store
%parameters and the responding component can include them in a response.  This
%allows the responding component to omit integrity verification on its incoming
%requests without compromising the integrity of the system as a whole.
%\ethan{Do we need this paragraph anymore?}

