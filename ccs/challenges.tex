\section{Two Key Security Properties}

Before presenting the \tc protocol in detail, we discuss two key security properties informing its design: gas sustainability and TCB minimization in the hybridized TCB model that \tc introduces. While we introduce them in this work, as we shall explain, they are of broad and general applicability.

\subsection{Gas Sustainability}
\label{sec:gas-sustainability}

%Recall from Section~\ref{sec:contracts-and-gas} that computation in Ethereum is not free; it employs \emph{gas} to fuel contracts.
%For a call to a contract, that cost is paid by the user who initiates the transaction, regardless of what other contracts are called as part of execution.
As explained above, Ethereum's fee model requires that gas be paid by the user who initiates a transaction, including all gas resulting from dependent calls. 
This means that a service that initiates calls to Ethereum contracts must spend money to execute those calls.
Without careful design, such services run the risk of malicious users (or protocol bugs) draining financial resources by triggering blockchain calls for which the service's fees will not be reimbursed, resulting in financial depletion of the service and an application-layer denial-of-service attack.
It is thus critical for the availability of Ethereum-based services that they always be reimbursed for blockchain computation they initiate.

To ensure that a service is not vulnerable to such attacks, we define \emph{gas sustainability}, a new condition necessary for the liveness of blockchain contract-based services. Gas sustainability is a basic requirement for any self-perpetuating Ethereum service. It can also generalize beyond Ethereum: Any decentralized blockchain-based smart contract system must require fees of some kind to reimburse miners for performing and verifying computation. 

Let \bal{\wallet} denote the balance of an Ethereum wallet \wallet.

\begin{definition}[$K$-Gas Sustainability]
  \label{def:gas-sustainability}
  A service with wallet \wallet and blockchain functions $f_1, \dotsc, f_n$ is \emph{$K$-gas sustainable} if the following holds.
If $\bal{\wallet} \geq K$ prior to execution of any $f_i$ and the service behaves honestly,
  then after each execution of an $f_i$ initiated by \wallet, $\bal{\wallet} \geq K$.
\end{definition}

Recall that a call made in Ethereum with insufficient gas will abort, but spend all provided gas. While Ethereum trivially guarantees 0-gas sustainability, if a transaction is submitted by a wallet with insufficient funds, the wallet's balance will drop to 0.
Therefore, to be $K$-gas sustainable for $K > 0$, each blockchain call made by the service must reimburse gas expenditures.
Moreover, the service must have sufficient gas for each call. Otherwise such reimbursement will be reverted with the rest of the transaction.

The need for gas sustainability (with $K > 0$, as required by \tc) informs our protocol design in Section~\ref{sec:protocol}. We prove that \tc achieves this property in Section~\ref{sec:analysis}.

\subsection{TCB Hybridization Minimization}
\label{sec:tcb-hybridization}


\begin{figure}[ht]
\begin{boxedminipage}{\columnwidth}
\begin{center}
  {\bf \tcboff: abstraction for off-chain TCB}
\end{center}
\vspace{-1ex}
\begin{tabular}{l}
  {\bf Initialize}(\textsf{void}):  \\
    \quad $(\pk, \sk) := \Sigma.{\sf KeyGen}(1^\lambda)$\\
    \quad Output $\pk$  \\[1ex]

  {\bf Resume}(\textsf{req}): \\
    \quad {\color{red} Assert $\oauth ({\sf req})$}\\
    \quad \textsf{resp} := $f(\textsf{req})$ \\
    \quad $\sigma := \Sigma.{\sf Sign}({\sk}, (\textsf{req}, {\sf resp}))$\\
    \quad Output $(({\sf req}, {\sf resp}), \sigma)$ \\
\end{tabular}

\begin{center}
  {\bf \tcbon: abstraction for on-chain TCB}
\end{center}
\vspace{-1ex}
\begin{tabular}{l}
  {\bf Request}(\textsf{req}): \\ 
  \quad Send $(\textsf{req})$  to \tcboff \\[1ex]

  {\bf Deliver}(\textsf{req}, \textsf{resp}, $\sigma$): \\
  \quad {\color{red} $\Sigma.{\sf Verify}((\textsf{req}, \textsf{resp}), \sigma)$} \\
  \quad \sgray{//~can now use {\sf resp} as trusted}
\end{tabular}
\end{boxedminipage}
\caption{Systems like \tc have a hybrid TCB. Authentication between two components
can greatly increase TCB complexity of implemented naively.
We propose techniques to eliminate the most expensive operations (highlighted in red).}
\label{fig:tcb-hybridization}
\vspace{-1.5em}
\end{figure}

In a system involving a smart contract interacting with an off-chain trusted computing environment (e.g. SGX),
the TCB is a hybridization of two components with distinct properties.
Computation in the smart contract is slow, costly, and completely transparent, meaning it cannot rely on secrets.
An SGX enclave is computationally powerful and executes privately, but all external interaction, notably including communication with the contract, must go through an untrusted intermediary. While this hybridized TCB is powerful and generally useful well beyond \tc, it presents a challenge: establishing secure communication between the components while minimizing the code in the TCB.

We define abstractions for both TCB components in Fig.~\ref{fig:tcb-hybridization}.
To distinguish these abstractions from formal ideal functionalities, we use \tcb (for trusted component), rather than $\mathcal{F}$.
We model the authentication of on-chain messages by an oracle \oauth, which returns true if an input is a valid blockchain transaction.
Since Ethereum blocks are self-authenticated using Merkle trees \cite{whitepaper,yellowpaper},
in principle we can realize \oauth by including an Ethereum client in the TCB.
Doing so drastically increases the code footprint, however, as the core Ethereum implementation is about 50k lines of C++.
Similarly, a smart contract could authenticate messages from an SGX by checking attestations,
but implementing this verification in a smart contract would be error-prone and computationally (and thus financially) expensive.

Instead we propose two general techniques to avoid these calls and thereby minimize code size in the TCB.
The first applies to any hybrid system where one TCB component is a blockchain contract.
The second applies to any hybrid system where the TCB components communicate only to make and respond to requests.


\paragraph{Binding \tcboff to \tcadd.}
Due to the speed and cost of computation in the on-chain TCB, we wish to avoid implementing signature verification (e.g. Intel's EPID).
There does exist a precompiled Ethereum contract to verify ECDSA signatures \cite{yellowpaper}, but the operation requires a high gas cost.
Instead, we describe here how to bind the identity of \tcboff to an Ethereum wallet, which allows \tcbon to simply check the message sender,
which is already verified as part of Ethereum's transaction protocol.

The key observation is that information can only be inserted into the Ethereum blockchain as transactions from a wallet.
thus, the only way the \medname can relay messages from \tcboff to \tcbon is through a wallet \tcadd.
Since Ethereum itself already verifies signatures on transactions (i.e., users interact with Ethereum through an authenticated channel),
we can piggyback verification of \tcboff signatures on top of the existing transaction signature verification mechanism.
Simply put, the \tcboff creates \tcadd with a fresh public key \pkoff whose secret is known only to \tcboff.

To make this idea work fully, the public key \pkoff must be hardcoded into \tcbon.
A client creating or relying on a contract that uses \tcbon is responsible for ensuring that this hardcoded \pkoff has an appropriate SGX attestation before interacting with \tcbon.
Let {\sf Verify} denote a verification algorithm for EPID signatures.
Fig.~\ref{fig:att_check} gives the protocol for a client to check that \tcbon is backed by a valid \tcboff instance.
(We omit the modeling here of IAS online revocation checks.)

In summary, then, we may assume in our protocol specifications that relying
clients have verified an attestation for \tcboff and thus that datagram
responses sent from \tcadd to \tcbon are trusted to originate from \tcboff.
This eliminates the need to do costly EPID signature verification in \tcbon.

\begin{figure}[htb!]
\begin{boxedminipage}{\columnwidth}
\begin{center}
{\bf User: offline verification of SGX attestation}
\end{center}
\vspace{-1ex}
\begin{tabular}{l}
{\bf {\em Inputs}}: $\pkM$, $\pkoff$, $\tcboff$, $\sigatt$ \\[5pt]
{\bf Verify:} \\
Assert $\pkoff$ is the expected enclave code\\
Assert $\sigsgx.{\sf Verify}(\pkM, \sigatt, (\tcboff, \pkoff))$ \\
Assert \tcbon is correct and parametrized w/ \pkoff\\
\sgray{\it //~now okay to rely on \tcbon}
\end{tabular}
\end{boxedminipage}
\caption{A client checks an SGX attestation on the enclave's code $\tcboff$
and public key $\pkoff$.  The client also checks that $\pkoff$ is hardcoded into
blockchain contract \tcbon before using \tcbon.} 
\label{fig:att_check}
\end{figure}


\paragraph{Eliminating \oauth.}
To eliminate the need to call \oauth from \tcboff, we leverage the fact that all messages from \tcboff to \tcbon are responses to existing requests.
Instead of verifying request parameters in \tcboff, we can verify in \tcbon that \tcboff responded to the correct request.
For each request, \tcbon stores the parameters of that request.
In each response, \tcboff includes the parameters it used to fulfill the request.
\tcbon can then check that the parameters in a response match the stored parameters and, if not,
and simply reject.
Storing parameters and checking equality are simple operations, so this vastly simpler than calling \oauth inside \tcboff.

This approach may appear to open new attacks (e.g., the \medname can send bogus requests to which the \tcboff respond).
As we prove in Section~\ref{sec:analysis}, however, all such attacks reduce to DoS attacks from the network or the \medname---attacks to which hybrid TCB systems are inherently susceptible and which we do not aim to protect against in \tc.

%We note that this technique is actually quite general.  Given any system with
%two trusted components communicating over an insecure channel, if one component
%only response to requests from the other, the requesting component can store
%parameters and the responding component can include them in a response.  This
%allows the responding component to omit integrity verification on its incoming
%requests without compromising the integrity of the system as a whole.
%\ethan{Do we need this paragraph anymore?}

